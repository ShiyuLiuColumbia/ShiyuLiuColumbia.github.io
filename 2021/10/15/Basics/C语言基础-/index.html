<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>C语言 - Shiyu - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Shiyu - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Shiyu - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="计算机和编程语言 解释性语言vs编译语言：语言本无解释&amp;#x2F;编译之分，只是常用的执行方式而已，比如我们常说C语言是编译性语言，是因为大多数时候我们运行C语言都是先编译后运行，但是其实也是有C语言解释器存在的。 C语言发展与版本 1989年ANSI发布了第一个标准-ANSI C 1990年ISO接受了ANCI的标准-C89 C的标准在1995年和1999年两次更新-C95和C99 本课程使用C99版本教"><meta property="og:type" content="blog"><meta property="og:title" content="C语言"><meta property="og:url" content="https://shiyuliucolumbia.github.io/2021/10/15/Basics/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-/"><meta property="og:site_name" content="Shiyu - Blog"><meta property="og:description" content="计算机和编程语言 解释性语言vs编译语言：语言本无解释&amp;#x2F;编译之分，只是常用的执行方式而已，比如我们常说C语言是编译性语言，是因为大多数时候我们运行C语言都是先编译后运行，但是其实也是有C语言解释器存在的。 C语言发展与版本 1989年ANSI发布了第一个标准-ANSI C 1990年ISO接受了ANCI的标准-C89 C的标准在1995年和1999年两次更新-C95和C99 本课程使用C99版本教"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://shiyuliucolumbia.github.io/img/og_image.png"><meta property="article:published_time" content="2021-10-16T01:36:49.000Z"><meta property="article:modified_time" content="2021-11-12T18:05:26.431Z"><meta property="article:author" content="Shiyu Liu"><meta property="article:tag" content="C"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://shiyuliucolumbia.github.io/2021/10/15/Basics/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-/"},"headline":"C语言","image":["https://shiyuliucolumbia.github.io/img/og_image.png"],"datePublished":"2021-10-16T01:36:49.000Z","dateModified":"2021-11-12T18:05:26.431Z","author":{"@type":"Person","name":"Shiyu Liu"},"publisher":{"@type":"Organization","name":"Shiyu - Blog","logo":{"@type":"ImageObject","url":{"text":"Shiyu - Blog"}}},"description":"计算机和编程语言 解释性语言vs编译语言：语言本无解释&#x2F;编译之分，只是常用的执行方式而已，比如我们常说C语言是编译性语言，是因为大多数时候我们运行C语言都是先编译后运行，但是其实也是有C语言解释器存在的。 C语言发展与版本 1989年ANSI发布了第一个标准-ANSI C 1990年ISO接受了ANCI的标准-C89 C的标准在1995年和1999年两次更新-C95和C99 本课程使用C99版本教"}</script><link rel="canonical" href="https://shiyuliucolumbia.github.io/2021/10/15/Basics/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Shiyu - Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-10-16T01:36:49.000Z" title="10/15/2021, 8:36:49 PM">2021-10-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-12T18:05:26.431Z" title="11/12/2021, 12:05:26 PM">2021-11-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">an hour read (About 7100 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">C语言</h1><div class="content"><h1 id="计算机和编程语言"><a href="#计算机和编程语言" class="headerlink" title="计算机和编程语言"></a>计算机和编程语言</h1><ol>
<li>解释性语言vs编译语言：语言本无解释/编译之分，只是常用的执行方式而已，比如我们常说C语言是编译性语言，是因为大多数时候我们运行C语言都是先编译后运行，但是其实也是有C语言解释器存在的。</li>
<li>C语言发展与版本<ul>
<li>1989年ANSI发布了第一个标准-ANSI C</li>
<li>1990年ISO接受了ANCI的标准-C89</li>
<li>C的标准在1995年和1999年两次更新-C95和C99</li>
<li>本课程使用C99版本教学</li>
</ul>
</li>
</ol>
<span id="more"></span>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><ol>
<li>变量名在C语言里面属于标识符（identifier），命名有严格的规范。<ul>
<li>只能由字母（包括大写和小写）、数字和下划线（_）组成。</li>
<li>不能以数字开头。</li>
<li>长度不能超过63个字符。</li>
</ul>
</li>
<li>变量名区分大小写，star、Star、STAR都是不同的变量。</li>
<li>并非所有的词都能用作变量名，有些词在C语言里面有特殊含义，比如<code>int</code>，<code>return</code>，它们是C语言的关键字。</li>
</ol>
<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><ol>
<li>C语言的变量，必须先声明后使用。如果一个变量没有声明，就直接使用，会报错。每个变量都有自己的类型（type）。声明变量时，必须把变量的类型告诉编译器。<code>int height;</code></li>
</ol>
<h2 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h2><ol>
<li><strong>C语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。</strong>所以，变量一定要赋值以后才能使用。</li>
<li>赋值操作通过赋值运算符（=）完成。下面示例中，第一行声明了一个整数变量num，第二行给这个变量赋值。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">num = <span class="number">42</span>;</span><br></pre></td></tr></table></figure></li>
<li>变量的声明和赋值，也可以写在一行。比如<code>int num = 42;</code>。多个相同类型变量的赋值，可以写在同一行。比如<code>int x = 1, y = 2;</code>。</li>
<li>注意，赋值表达式有返回值，等于等号右边的值。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = (x = <span class="number">2</span> * x);</span><br></pre></td></tr></table></figure>
 上面代码中，变量y的值就是赋值表达式（x = 2 * x）的返回值2。<br> 由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, z, m, n;</span><br><span class="line"></span><br><span class="line">x = y = z = m = n = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
 上面的代码是合法代码，一次为多个变量赋值。赋值运算符是从右到左执行，所以先为n赋值，然后依次为m、z、y和x赋值。</li>
</ol>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><ol>
<li>算术运算符专门用于算术运算，主要有下面几种。</li>
</ol>
<p>+：正值运算符（一元运算符），结合关系：自右向左<br>-：负值运算符（一元运算符），结合关系：自右向左<br>+：加法运算符（二元运算符）<br>-：减法运算符（二元运算符）<br>*：乘法运算符<br>/：除法运算符<br>%：余值运算符<br>=：赋值运算符，结合关系：自右向左<br>2. 我们可以看到，<code>+</code>和<code>-</code>既可以做一元运算符，也可以做二元运算符。做一元运算符的时候，指的是为一个值取正或取负，并且做一元运算符的时候，与赋值运算符一样，结合关系是自右向左<br>3. 如果变量对自身的值进行算术运算，C 语言提供了简写形式，允许将赋值运算符和算术运算符结合成一个运算符。<code>+= -= *= /= %=</code>。由于赋值运算符的优先级最低，所以当出现<code>a+=b+3</code>时，C语言会先计算b+3的结果，然后计算a = a + (b+3)的结果</p>
<h2 id="自增运算符，自减运算符"><a href="#自增运算符，自减运算符" class="headerlink" title="自增运算符，自减运算符"></a>自增运算符，自减运算符</h2><ol>
<li>C 语言提供两个运算符，对变量自身进行+ 1和- 1的操作。++：自增运算符；–：自减运算符 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i++; <span class="comment">// 等同于 i = i + 1</span></span><br><span class="line">i--; <span class="comment">// 等同于 i = i - 1</span></span><br></pre></td></tr></table></figure>
 这两个运算符放在变量的前面或后面，结果是不一样的。++var和–var是先执行自增或自减操作，再返回操作后var的值；var++和var–则是先返回操作前var的值，再执行自增或自减操作。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">j = (i++ + <span class="number">10</span>);</span><br><span class="line"><span class="comment">// i: 43</span></span><br><span class="line"><span class="comment">// j: 52</span></span><br><span class="line"></span><br><span class="line">j = (++i + <span class="number">10</span>)</span><br><span class="line"><span class="comment">// i: 44</span></span><br><span class="line"><span class="comment">// j: 54</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><ol>
<li>C 语言用于比较的表达式，称为“关系表达式”（relational expression），里面使用的运算符就称为“关系运算符”（relational operator），主要有下面6个。<blockquote>
<p>大于运算符<br>&lt; 小于运算符<br>= 大于等于运算符<br>&lt;= 小于等于运算符<br>== 相等运算符<br>!= 不相等运算符</p>
</blockquote>
</li>
<li><strong>关系表达式通常返回0或1，表示真伪。C语言中，0表示伪，所有非零值表示真。比如，20 &gt; 12返回1，12 &gt; 20返回0。</strong></li>
<li>关系运算符不宜连用：<code>(i &lt; j) &lt; k</code>。这个式子中，i &lt; j返回0或1，所以最终是0或1与变量k进行比较。如果想要判断变量j的值是否在i和k之间，应该使用下面的写法：<code>i &lt; j &amp;&amp; j &lt; k</code></li>
</ol>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ol>
<li>逻辑运算符提供逻辑判断功能，用于构建更复杂的表达式，主要有下面三个运算符。<br>!：否运算符（改变单个表达式的真伪）。<br>&amp;&amp;：与运算符（两侧的表达式都为真，则为真，否则为伪）。<br>||：或运算符（两侧至少有一个表达式为真，则为真，否则为伪）。</li>
<li>下面是 否运算符 的例子。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(x &lt; <span class="number">12</span>))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x is not less than 12\n&quot;</span>);</span><br></pre></td></tr></table></figure>
 上面示例中，由于否运算符!具有比&lt;更高的优先级，所以必须使用括号，才能对表达式x &lt; 12进行否运算。当然，合理的写法是if (x &gt;= 12)，这里只是为了举例。</li>
<li>对于逻辑运算符来说，任何非零值都表示真，零值表示伪。比如，5 || 0会返回1，5 &amp;&amp; 0会返回0。</li>
<li>逻辑运算符还有一个特点，它总是先对左侧的表达式求值，再对右边的表达式求值，这个顺序是保证的。如果左边的表达式满足逻辑运算符的条件，就不再对右边的表达式求值。这种情况称为“短路”。</li>
</ol>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><ol>
<li>逗号运算符用于将多个表达式写在一起，从左到右依次运行每个表达式。<code>x = 10, y = 20;</code>。上面示例中，有两个表达式（x = 10和y = 20），逗号使得它们可以放在同一条语句里面。</li>
<li>逗号运算符返回最后一个表达式的值，作为整个语句的值。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
 上面示例中，逗号的优先级低于赋值运算符，所以先执行赋值运算，再执行逗号运算，变量x等于1。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
 上面示例中，由于有了括号的存在，先执行逗号运算，我们使用最右边的值作为表达式的值，然后赋给x，变量x等于3。</li>
</ol>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><ol>
<li>运算符的优先级顺序很复杂。下面是部分运算符的优先级顺序（按照优先级从高到低排列）。<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/language/operator_precedence">https://en.cppreference.com/w/c/language/operator_precedence</a><br>圆括号（()）从左到右<br>所有单目运算符：自增运算符（++），自减运算符（–），一元运算符（+和-），否运算符（!）<br>乘法（*），除法（/），取余（%）<br>加法（+），减法（-）<br>关系运算符（&lt;、&gt;等）<br>== !=<br>&amp;&amp;<br>||<br>赋值运算符（=）,其他赋值运算符（+=, -=）<br>逗号运算符(,)</li>
</ol>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ol>
<li><a target="_blank" rel="noopener" href="https://wangdoc.com/clang/flow-control.html">https://wangdoc.com/clang/flow-control.html</a></li>
<li><strong>老师有一点讲的很好：switch-case语句中，case并不是用来分割语句的，case只是用来决定语句从什么地方开始执行。我们在使用switch-case语句的时候，可以无视case，把剩下的所有语句当成一段要执行的代码，case只是选择从哪一句开始执行，然后程序会一直执行下面的代码，直到遇到break为止</strong></li>
</ol>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li>函数声明：C语言中的函数在使用前必须先进行定义，这点与Java不同，Java的函数可以定义在任何位置。如果C语言想要在未定义函数前就进行使用，那么就需要使用函数声明。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> twice(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twice</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>调用函数时给的值与参数的类型不匹配是C语言传统上的最大的漏洞，编译器总是悄悄的替你把类型转换好，但是这很可能不是我们所期望的，后续的语言，比如C++和Java在这方面很严格。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	test(<span class="number">2.4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 上面的程序编译会通过，虽然会有一个warning，这种程序对于Java根本不可能通过编译<br> hello.c:8:10: warning: implicit conversion from ‘double’ to ‘int’ changes value from 2.4 to 2 [-Wliteral-conversion]<pre><code> test(2.4);
 ~~~~ ^~~
</code></pre>
 1 warning generated.</li>
<li><strong>C语言在调用函数的时候，永远只能传值给函数</strong><br> 值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br> 引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。<br> 更精辟的理解：操作的是一块内存(引用传递)还是新开辟了一块内存(值传递)的区别<br> 所以我们看到下面的程序是不会有效的： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">Swap(a, b); <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure>
 对于Java来说：Java中本质上是值传递的，只不过对于对象参数(非primitive的所有对象)，值的内容是对象的引用(地址)，通俗的来说，如果Java中函数的参数是一个对象，那么当我们call这个函数的时候，传进去的是这个对象引用(地址)的一份拷贝。<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31203609/answer/576030121">https://www.zhihu.com/question/31203609/answer/576030121</a></li>
<li>本地变量： 本地变量只在当前block中可用(函数参数也是本地变量)，程序进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了。如果在块里面定义了和外面同名的变量，则掩盖掉外面的(这点Java是不支持的)</li>
</ol>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ol>
<li><a target="_blank" rel="noopener" href="https://wangdoc.com/clang/array.html">https://wangdoc.com/clang/array.html</a></li>
<li>注意，如果引用不存在的数组成员（即越界访问数组），并不会报错，所以必须非常小心。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> scores[<span class="number">100</span>];</span><br><span class="line">scores[<span class="number">100</span>] = <span class="number">51</span>;</span><br></pre></td></tr></table></figure>
 上面示例中，数组scores只有100个成员，因此scores[100]这个位置是不存在的。但是，引用这个位置并不会报错，会正常运行，使得紧跟在scores后面的那块内存区域被赋值，而那实际上是其他变量的区域，因此不知不觉就更改了其他变量的值。这很容易引发错误，而且难以发现。</li>
<li>把一个数组的所有元素交给另一个数据，不能直接<code>int a[] = &#123;0, 1, 2&#125;; int b[] = a;</code>，而是只能遍历，后面介绍指针后会介绍具体原因。</li>
<li>求数组的长度：<code>sizeof(a)/sizeof(a[0])</code></li>
<li>数组作为函数参数的时候，我们无法直接通过上面的求数组长度的方法来得到它的长度，所以往往需要再用另一个参数来传入数组的大小，其原因是因为数组作为参数，传入的其实只是数组第一个值的地址，所以我们是没法知道长度的。这点与Java是不同的，Java的数组传入函数的是一个引用，可以直接使用<code>a.length</code>得到数组长度。</li>
</ol>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ol>
<li>运算符&amp;：获得变量的地址，它的操作数必须是变量 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x&#x27;s address is %p\n&quot;</span>, &amp;x);</span><br></pre></td></tr></table></figure>
 上面示例中，x是一个整数变量，&amp;x就是x的值所在的内存地址。printf()的%p是内存地址的占位符，可以打印出内存地址</li>
<li>变量地址的长度在不同的编译器架构中是不同的，32位编译器架构的变量地址的长度是4个字节，，64位编译器架构的变量地址的长度是8个字节。所以变量地址并不总是和int(4个字节)的长度相同，我们也不应该使用int来表示地址。</li>
<li>&amp;只能取变量的地址，对于表达式来说，是没有地址可以取的，所以下面都是错误的表示：<code>&amp;(a+b); &amp;(a++); &amp;(++a)</code></li>
<li>前面我们说过，一个变量的地址并不总是与int长度相等，所以我们需要一个用来储存地址的方法，<strong>指针就是保存地址的变量</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;i;</span><br><span class="line"><span class="keyword">int</span>* p,q;</span><br><span class="line"><span class="keyword">int</span> *p,q;</span><br></pre></td></tr></table></figure>
 上面的例子中，第三四行代表的都是p是一个指针，q只是一个int型的变量。<strong>所以，在C语言中，没有<code>int*</code>这种类型，而应该表达为<code>*p</code>是一个int类型的变量</strong>。如果要表示p和q都是指针，应该写为<code>int *p, *q;</code>。</li>
<li>运算符*：用来访问指针的值所表示的地址上的变量 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">*p = *p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 上面示例中，函数increment()的参数是一个整数指针p。函数体里面，<code>*p</code>就表示指针p所指向的那个值。对<code>*p</code>赋值，就表示改变指针所指向的那个地址里面的值。<br> 上面函数的作用是将参数值加1。该函数没有返回值，因为传入的是地址，函数体内部对该地址包含的值的操作，会影响到函数外部，所以不需要返回值。<strong>事实上，函数内部通过指针，将值传到外部，是C语言的常用方法。</strong></li>
<li>指针的作用：1.在函数中传入地址，那么我们修改改地址指向的变量，也就可以改变外面的变量，所以在C语言中写一个swap函数必须要传入地址。之前我们提到Java语言也是传值的，那么如果要写一个swap函数交换两个int值，那么往往需要借助数组或者对象，因为Java不提供指针。 2.当我们的函数需要多个返回值的时候，我们可以通过传入多个指针并把返回值写入这些指针指向的变量来达到这个目的 3.函数返回运算的状态，而运算的结果通过指针返回。由于C语言没有异常处理机制，所以我们的程序需要返回一个特殊值来说明是否运行正常，那么运算的结果就无法通过返回值来返回了，这时候可以使用指针。</li>
<li>指针最常见的错误：定义了指针变量，但是还没有指向任何变量(初始化)，就开始使用 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">*p = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
 这里p储存的地址完全是随机的，而我们想要改一个随地地址的变量的值。</li>
<li>数组的地址：数组是一连串连续储存的同类型值，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的地址。请看下面的例子。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);  <span class="comment">// Prints &quot;11&quot;</span></span><br></pre></td></tr></table></figure>
 上面示例中，&amp;a[0]就是数组a的首个成员11的内存地址，也是整个数组的起始地址。反过来，从这个地址（*p），可以获得首个成员的值11。<br> 由于数组的起始地址是常用操作，&amp;array[0]的写法有点麻烦，C 语言提供了便利写法，数组名等同于起始地址，也就是说，<strong>数组名就是指向第一个成员（array[0]）的指针</strong>。</li>
<li>指针与数组：前面我们提到过，数组传入函数中，我们是不能用参数列表的数组变量去计算数组的长度的，原因就是数组传入函数的时候被decay成一个指针，指向数组的起始地址，所以如果对函数内的数组变量使用sizeof，得到的并不是数组的字节长度，而是数组起始地址端的字节长度。这也是为什么在C语言中，当我们想要将一个数组传入函数的时候，我们还需要传入数组的长度，因为传入的参数只是一个指针，我们还需要另外一个变量来指明数组的长度</li>
<li>[]运算符可以对数组做，也可以对指针做；*运算符可以对指针做，也可以对数组做</li>
<li>数组与指针并不等价，只不过数组可以decay成指针来使用：不等价，数组能隐式转换成指针罢了。看到有书这么写的话应该考虑直接扔掉。数组和指针的区别应该是十分基础而显然的。定义一个指针对象 <code>T *ptr;</code> 后 ptr 这个对象里面没有 T 类型对象，不过可能可以通过 ptr 访问存在于别处的 T 类型对象。定义一个数组对象 <code>T arr[N];</code> 后 arr 这个对象里面有 N 个 T 类型对象。将 arr 隐式转换成指针后，能访问的 T 类型对象是 arr 里面的对象。<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/362176701/answer/956286999">https://www.zhihu.com/question/362176701/answer/956286999</a></li>
<li>指针与const：<ul>
<li>指针是const，表示一旦得到了某个变量的地址，不能在指向其他变量，但是已经指向的变量是可以改变的。数组其实就是一个const指针，<code>int[] a</code>等价于<code>int * const a</code>，这也就是为什么前面我们提到数组之间不能互相赋值(<code>int[] a = b</code>是不允许的)，因为这是在把一个const指针指向另一个变量。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> q = &amp;i;</span><br><span class="line">*q = <span class="number">26</span>; <span class="comment">//ok</span></span><br><span class="line">q++; <span class="comment">//error</span></span><br></pre></td></tr></table></figure></li>
<li>所指是const，表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const，也就是说那个变量本身是可以改变的，但你不能用这个指针去改变它）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line">*p = <span class="number">26</span>; <span class="comment">//error!(*p)是const</span></span><br><span class="line">i = <span class="number">26</span>;<span class="comment">//ok</span></span><br><span class="line">p= &amp;j;<span class="comment">//ok</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>判断哪个被const了的标志是const在*的前面还是后面：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;i;<span class="comment">//所指是const</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p2 = &amp;i;<span class="comment">//所指是const</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p3 = &amp;i;<span class="comment">//指针是const</span></span><br></pre></td></tr></table></figure></li>
<li>const数组： <code>const int a[] = &#123;1, 2, 3, 4, 5&#125;</code>。数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int，无法通过a[i]进行修改，所以必须通过初始化进行赋值。 </li>
<li>指针运算：对于指针的加1与减1并不是地址的加1或减1，而是表示指针的移动，移动的距离是取决于变量的大小，比如在32位编译器中int的大小是4，如果我们有一个int型的数组array[]，现在我们有<code>int *p = array;</code>，那么<code>*(p+n)</code>与<code>array[n]</code>是等价的。由于运算符<code>*</code>比<code>+</code>的优先级高，所以这里我们需要括号。</li>
<li>0地址：操作系统会为每个程序虚拟化一段内存，这些内存都有地址为0的一个的地址，但是这个0地址处储存着我们不能操作的数据，因此我们可以把用0指针代表返回的指针是无效的或者指针还没有被初始化(先初始化为0)。C语言中NULL是一个预定义的符号，代表0地址。</li>
<li>指针的类型：无论指针指向什么类型，所有的指针的大小都是一样的(大小取决于编译器)。但是指向不同类型的指针是不能直接互相赋值的，比如不能把一个int型的指针赋给double型的指针</li>
<li>指针的类型转换：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="keyword">void</span> *q = (<span class="keyword">void</span>*)p;</span><br></pre></td></tr></table></figure>
<code>void*</code>表示不知道指向什么东西的指针。这里把一个指向int的指针转化成<code>void*</code>的指针，<strong>但是这并不会改变p所指的变量的类型，他所指的仍旧是一个int型变量，只是这个时候我们用不同的眼光看待这个变量</strong></li>
<li>动态内存分配：假设我们的程序中要定义一个长度为n的数组，这个n是通过命令行输入的，这个时候我们可以使用变量n作为数组大小，但是这个feature是C99才引进的，之前ANSIC并不支持变量作为数组长度，那么我们该怎么做呢？答案是使用动态内存分配，我们可以使用malloc函数分配一段长度为n*sizeof(int)的内存：<code>int *a = (int*)malloc(n*sizeof(int))</code>。malloc函数的输入是分配内存的字节长度，malloc函数返回的是<code>void*</code>，我们使用强制类型转化变成int型的数组。malloc函数需要引入<code>#include &lt;stdlib.h&gt;</code>，<strong>malloc函数用完以后一定要用free函数释放内存</strong>、如果内存地址不够分配，malloc函数返回NULL</li>
</ol>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ol>
<li>C语言没有单独的字符串类型，字符串被当作字符数组，即char类型的数组。比如，字符串”Hello”是当作数组<code>&#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;&#125;</code>处理的。<br>编译器会给数组分配一段连续内存，所有字符储存在相邻的内存单元之中。在字符串结尾，C语言会自动添加一个全是二进制0的字节，写作\0字符，表示字符串结束。字符<code>\0</code>不同于字符0，前者的 ASCII 码是0（二进制形式00000000），后者的 ASCII 码是48（二进制形式00110000）。所以，字符串“Hello”实际储存的数组是<code>&#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;&#125;</code>。</li>
<li>字符<code>\0</code>标志字符串的结束，但它不是字符串的一部分，我们计算字符串的长度的时候不包含这个0。其实这点很好理解，这个0只是因为C语言不提供字符串类型，所以需要有一种方式去标记字符串的结束。</li>
<li>如果字符串过长，可以在需要折行的地方，使用反斜杠（\）结尾，将一行拆成多行。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello \</span></span><br><span class="line"><span class="string">world&quot;</span></span><br></pre></td></tr></table></figure>
 上面示例中，第一行尾部的反斜杠，将字符串拆成两行。<br> 上面这种写法有一个缺点，就是第二行必须顶格书写，如果想包含缩进，那么缩进也会被计入字符串。为了解决这个问题，C 语言允许合并多个字符串字面量，只要这些字符串之间没有间隔，或者只有空格，C 语言会将它们自动合并。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, &quot;</span><span class="string">&quot;how are you &quot;</span><span class="string">&quot;today!&quot;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, how are you today!&quot;</span>;</span><br></pre></td></tr></table></figure>
 这种新写法支持多行字符串的合并。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[<span class="number">50</span>] = <span class="string">&quot;Hello, &quot;</span></span><br><span class="line"><span class="string">&quot;how are you &quot;</span></span><br><span class="line"><span class="string">&quot;today!&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>字符串在内存中以字符数组的形式存在，所以不能用运算符对字符串进行操作(不能像Java一样字符串之间相加)。访问的时候可以使用指针或者数组，但是这两者在访问字符串的时候是有区别的。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>
 那么这两种声明方式有什么区别呢？首先我们需要知道的是，C语言的字符串字面量(也就是”Hello, world!”)都是生成在代码段的内存中的，这段区域是只可读的，这个时候如果我们尝试<code>s[0] = &#39;B&#39;</code>是会报错的，并且如果我们用指针方式声明相同的字符串，其实指针是会指向同一个地址的；而使用数组声明的字符串，编译器会给数组在栈区(stack，也就是局部变量和函数参数所在的地方，变量由系统自动分配与销毁)单独分配一段新内存，字符串字面量会被编译器解释成字符数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的，所以<code>s[0] = &#39;B&#39;</code>是允许的。</li>
<li>口语中，我们常说用<code>char*</code>定义一个字符串，但是<code>char*</code>声明的并不一定是字符串，也可能只是一个指向单个字符的滋镇，只有当它所指的是一个字符数组并且结尾是一个0的时候，才能说它指的是字符串。</li>
<li>字符串数组：介绍过字符串以后，那么字符串数组应该如何表示呢？可能的方案有：1.char ** a 2.char a[][] 3. char * a[]。方案一并不是字符串数组，而是表示a是一个指针，指向另一个指针，那个指针指向一个字符(串)；方案二可以在一定程度上代表字符串数组，但是有一个问题，二维数组的第二个维度必须是确定的，那么这里我们的字符串就会有一个长度限制 3.方案三代表的才是字符串数组，这里数组中只存放<code>char*</code>，也就是指针。</li>
<li>C语言标准库提供了很多处理字符串的函数，我们在使用之前需要先加上头文件<code>#include &lt;string.h&gt;</code>。<ul>
<li><code>size_t strlen(const char *s)</code>：返回字符串长度(不包括结尾的0)</li>
<li><code>int strcmp(const char *s1, const char *s2)</code>：比较两个字符串的长度，如果<code>s1==s2</code>，返回0，如果<code>s1&gt;s2</code>，返回1，如果<code>s1&lt;s2</code>，返回-1</li>
<li><code>char * strcpy(char *restrict dst, const char *restrict src)</code>：把第二个字符串拷贝到第一个字符串的位置，restricted代表两个字符串不重叠。返回的就是dst这个字符串，目的是为了能链起代码来</li>
<li><code>char * strcat(char *restrict s1, const char *restrict s2)</code>：把s2拷贝到s1后面，s1必须有足够的空间。strcat和strcpy都可能出现安全问题，因为目的地可能没有足够的空间，可以使用安全的版本strncpy和strncat，n代表最多能拷贝的字符</li>
<li><code>char * strchr(const char *s, int c); char * strrchr(const char *s, int c)</code>：在字符串中找第一个出现的c，没有返回0指针NULL，有的话返回对应指针，strrchr代表从右向左找，strchr代表从左向右找</li>
</ul>
</li>
</ol>
<h1 id="enum，struct与union"><a href="#enum，struct与union" class="headerlink" title="enum，struct与union"></a>enum，struct与union</h1><ol>
<li>enum：<a target="_blank" rel="noopener" href="https://wangdoc.com/clang/enum.html">https://wangdoc.com/clang/enum.html</a></li>
<li>struct：<a target="_blank" rel="noopener" href="https://wangdoc.com/clang/struct.html">https://wangdoc.com/clang/struct.html</a></li>
<li>struct赋值：除了逐一对struct的属性赋值，也可以使用大括号，一次性对 struct 结构的所有属性赋值。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line"><span class="keyword">float</span> price;</span><br><span class="line"><span class="keyword">int</span> speed;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> <span class="title">saturn</span> =</span> &#123;<span class="string">&quot;Saturn SL/2&quot;</span>, <span class="number">16000.99</span>, <span class="number">175</span>&#125;;</span><br></pre></td></tr></table></figure>
 上面示例中，变量saturn是struct car类型，大括号里面同时对它的三个属性赋值。如果大括号里面的值的数量，少于属性的数量，那么缺失的属性自动初始化为0。</li>
<li>struct复制：struct变量可以使用赋值运算符（=），复制给另一个变量，这时会生成一个全新的副本。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据。这一点跟数组的复制不一样，务必小心。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cat</span> &#123;</span> <span class="keyword">char</span> name[<span class="number">30</span>]; <span class="keyword">short</span> age; &#125; a, b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(a.name, <span class="string">&quot;Hula&quot;</span>);</span><br><span class="line">a.age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">b = a;</span><br><span class="line">b.name[<span class="number">0</span>] = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a.name); <span class="comment">// Hula</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, b.name); <span class="comment">// Mula</span></span><br></pre></td></tr></table></figure>
 上面示例中，变量b是变量a的副本，两个变量的值是各自独立的，修改掉b.name不影响a.name。<br> 上面这个示例是有前提的，就是 struct 结构的属性必须定义成字符数组，才能复制数据。如果稍作修改，属性定义成字符指针，结果就不一样。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cat</span> &#123;</span> <span class="keyword">char</span>* name; <span class="keyword">short</span> age; &#125; a, b;</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;Hula&quot;</span>;</span><br><span class="line">a.age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure>
 上面示例中，name属性变成了一个字符指针，这时a赋值给b，导致b.name也是同样的字符指针，指向同一个地址，也就是说两个属性共享同一个地址。因为这时，struct 结构内部保存的是一个指针，而不是上一个例子的数组，这时复制的就不是字符串本身，而是它的指针。并且，这个时候也没法修改字符串，因为字符指针指向的字符串是不能修改的。</li>
<li>struct作为函数参数：整个struct可以作为参数传入函数，这个时候是在函数内部新建一个struct并复制传入的struct的值；但是一般当struct很大的时候，常见的做法是传一个struct指针。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">happy</span><span class="params">(struct turtle* t)</span> </span>&#123;</span><br><span class="line">(*t).age = (*t).age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 上面示例中，<code>(*t).age</code>不能写成<code>*t.age</code>，因为点运算符.的优先级高于*。<code>*t.age</code>这种写法会将<code>t.age</code>看成一个指针，然后取它对应的值，会出现无法预料的结果。<br> <code>(*t).age</code>这样的写法很麻烦。C语言就引入了一个新的箭头运算符（-&gt;），可以从struct指针上直接获取属性，大大增强了代码的可读性。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">happy</span><span class="params">(struct turtle* t)</span> </span>&#123;</span><br><span class="line">t-&gt;age = t-&gt;age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>自定义数据类型：我们可以使用<code>typedef</code>来声明一个已有的数据类型的新名字，比如<code>typedef int Length;</code>。typedef命令也可以为struct结构指定一个别名，这样使用起来更简洁。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cell_phone</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> cell_no;</span><br><span class="line"><span class="keyword">float</span> minutes_of_charge;</span><br><span class="line">&#125; phone;</span><br><span class="line"></span><br><span class="line">phone p = &#123;<span class="number">5551234</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
 上面示例中，phone就是struct cell_phone的别名。</li>
<li>union：<a target="_blank" rel="noopener" href="https://wangdoc.com/clang/union.html">https://wangdoc.com/clang/union.html</a></li>
</ol>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C/">C</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/11/08/Basics/CSAPP/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">CSAPP</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/15/Basics/Intro%20to%20Operating%20System/"><span class="level-item">Intro to Operating System</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/Shiyu.jpg" alt="Shiyu Liu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Shiyu Liu</p><p class="is-size-6 is-block">Software Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Nashville</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">47</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">11</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ShiyuLiuColumbia" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ShiyuLiuColumbia"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Linkedin" href="https://www.linkedin.com/in/shiyu-liu-6623a3158/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:sl4401@columbia.edu"><i class="fas fa-envelope-open"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#计算机和编程语言"><span class="level-left"><span class="level-item">1</span><span class="level-item">计算机和编程语言</span></span></a></li><li><a class="level is-mobile" href="#变量"><span class="level-left"><span class="level-item">2</span><span class="level-item">变量</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#变量名"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">变量名</span></span></a></li><li><a class="level is-mobile" href="#变量的声明"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">变量的声明</span></span></a></li><li><a class="level is-mobile" href="#变量的赋值"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">变量的赋值</span></span></a></li></ul></li><li><a class="level is-mobile" href="#运算符"><span class="level-left"><span class="level-item">3</span><span class="level-item">运算符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#算术运算符"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">算术运算符</span></span></a></li><li><a class="level is-mobile" href="#自增运算符，自减运算符"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">自增运算符，自减运算符</span></span></a></li><li><a class="level is-mobile" href="#关系运算符"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">关系运算符</span></span></a></li><li><a class="level is-mobile" href="#逻辑运算符"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">逻辑运算符</span></span></a></li><li><a class="level is-mobile" href="#逗号运算符"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">逗号运算符</span></span></a></li><li><a class="level is-mobile" href="#运算符优先级"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">运算符优先级</span></span></a></li></ul></li><li><a class="level is-mobile" href="#流程控制"><span class="level-left"><span class="level-item">4</span><span class="level-item">流程控制</span></span></a></li><li><a class="level is-mobile" href="#数据类型"><span class="level-left"><span class="level-item">5</span><span class="level-item">数据类型</span></span></a></li><li><a class="level is-mobile" href="#函数"><span class="level-left"><span class="level-item">6</span><span class="level-item">函数</span></span></a></li><li><a class="level is-mobile" href="#数组"><span class="level-left"><span class="level-item">7</span><span class="level-item">数组</span></span></a></li><li><a class="level is-mobile" href="#指针"><span class="level-left"><span class="level-item">8</span><span class="level-item">指针</span></span></a></li><li><a class="level is-mobile" href="#字符串"><span class="level-left"><span class="level-item">9</span><span class="level-item">字符串</span></span></a></li><li><a class="level is-mobile" href="#enum，struct与union"><span class="level-left"><span class="level-item">10</span><span class="level-item">enum，struct与union</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Shiyu - Blog</a><p class="is-size-7"><span>&copy; 2021 Shiyu Liu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>