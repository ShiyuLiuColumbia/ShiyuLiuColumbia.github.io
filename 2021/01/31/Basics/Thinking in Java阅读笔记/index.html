<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Thinking in Java阅读笔记 - Shiyu - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Shiyu - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Shiyu - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Initialization &amp;amp; Clean upStatic data initialization 当新建一个类或者直接使用这个类里的static变量的时候，这个类里所有的static变量就会被初始化，static变量先于non-static变量进行初始化，并且整个程序中只有一份static变量的instance（即被所有对象共享） static block: 跟static变量一样，"><meta property="og:type" content="blog"><meta property="og:title" content="Thinking in Java阅读笔记"><meta property="og:url" content="https://shiyuliucolumbia.github.io/2021/01/31/Basics/Thinking%20in%20Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Shiyu - Blog"><meta property="og:description" content="Initialization &amp;amp; Clean upStatic data initialization 当新建一个类或者直接使用这个类里的static变量的时候，这个类里所有的static变量就会被初始化，static变量先于non-static变量进行初始化，并且整个程序中只有一份static变量的instance（即被所有对象共享） static block: 跟static变量一样，"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://shiyuliucolumbia.github.io/img/og_image.png"><meta property="article:published_time" content="2021-02-01T05:37:48.000Z"><meta property="article:modified_time" content="2021-11-12T18:05:42.159Z"><meta property="article:author" content="Shiyu Liu"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://shiyuliucolumbia.github.io/2021/01/31/Basics/Thinking%20in%20Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},"headline":"Thinking in Java阅读笔记","image":["https://shiyuliucolumbia.github.io/img/og_image.png"],"datePublished":"2021-02-01T05:37:48.000Z","dateModified":"2021-11-12T18:05:42.159Z","author":{"@type":"Person","name":"Shiyu Liu"},"publisher":{"@type":"Organization","name":"Shiyu - Blog","logo":{"@type":"ImageObject","url":{"text":"Shiyu - Blog"}}},"description":"Initialization &amp; Clean upStatic data initialization 当新建一个类或者直接使用这个类里的static变量的时候，这个类里所有的static变量就会被初始化，static变量先于non-static变量进行初始化，并且整个程序中只有一份static变量的instance（即被所有对象共享） static block: 跟static变量一样，"}</script><link rel="canonical" href="https://shiyuliucolumbia.github.io/2021/01/31/Basics/Thinking%20in%20Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Shiyu - Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-01T05:37:48.000Z" title="1/31/2021, 11:37:48 PM">2021-01-31</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-12T18:05:42.159Z" title="11/12/2021, 12:05:42 PM">2021-11-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">2 hours read (About 16225 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">Thinking in Java阅读笔记</h1><div class="content"><h1 id="Initialization-amp-Clean-up"><a href="#Initialization-amp-Clean-up" class="headerlink" title="Initialization &amp; Clean up"></a>Initialization &amp; Clean up</h1><h2 id="Static-data-initialization"><a href="#Static-data-initialization" class="headerlink" title="Static data initialization"></a>Static data initialization</h2><ol>
<li>当新建一个类或者直接使用这个类里的static变量的时候，这个类里所有的static变量就会被初始化，static变量先于non-static变量进行初始化，并且整个程序中只有一份static变量的instance（即被所有对象共享）</li>
<li>static block: 跟static变量一样，随着类的加载而执行，只执行一次，并优先于主函数，可用于给类进行初始化</li>
</ol>
<span id="more"></span>

<h1 id="Access-control"><a href="#Access-control" class="headerlink" title="Access control"></a>Access control</h1><p>public&gt;protected&gt;package(default)&gt;private</p>
<h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>所有人都有access</p>
<h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>当前package或者继承类有access</p>
<h2 id="package-default"><a href="#package-default" class="headerlink" title="package(default)"></a>package(default)</h2><p>只有当前package的其他class有access。需要注意的是，liushiy.package1和liushiy.package2是两个不同的package，即使某个variable在liushiy.package1是package access，我们在liushiy.package2是不能使用的</p>
<h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>只有当前这个class可以使用</p>
<h1 id="Reusing-Classes"><a href="#Reusing-Classes" class="headerlink" title="Reusing Classes"></a>Reusing Classes</h1><h2 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h2><ol>
<li>Composition(组合)是最常见的复用类的方法，当我们创建一个新类的时候，里面包含旧类的对象</li>
<li>组合是一种HAS-A的关系，新类中有旧类</li>
</ol>
<h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><ol>
<li><p>Inheritance(继承)是IS-A的关系，子类<strong>是</strong>一种父类</p>
</li>
<li><p>继承的关键字是extends，子类自动继承父类所有的属性(fields)和方法(methods）</p>
</li>
<li><p>子类并不局限于使用父类的fields和methods，可以创建自己的fields和methods</p>
</li>
<li><p>子类可以重写(override)父类已有的methods。重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！重载(overloading)是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法(或者构造函数)都必须有一个独一无二的参数类型列表。<br>子类进行重写的时候，可以在重写的方法上加上<code>@override</code>注解。<code>@override</code>注解不是必须的，加上的好处是编译器会确认注解后面的方法确实是在重写。可以避免诸如方法名写错(编译器会认为这是子类的新方法，而不是在重写父类的旧方法)，或者想要重写但不小心写成了重载</p>
</li>
<li><p>如果子类重写了父类的某个方法, 但是又想使用父类的这个方法，那么我们可以用super关键字去call父类的方法。下面这个例子的输出是： Fake Miao</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fake&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.call();</span><br><span class="line">		System.out.println(<span class="string">&quot;Miao&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Animal animal = <span class="keyword">new</span> Cat();</span><br><span class="line">		animal.call();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>子类在初始化的时候，会先自动调用父类的default构造器(constructor)去初始化父类的属性。<strong>如果父类没有默认constructor， 那么子类必须使用父类其他的constructor去初始化属性，即我们需要在子类中使用super关键词去call父类的constructor，并且super关键词必须在子类constructor的第一句。</strong> 如果父类既没有默认构造器，我们又不在子类调用某个父类的构造器，那么编译器会报错: There is no default constructor avaliable</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="string">&quot;Fake&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.call();</span><br><span class="line">		System.out.println(<span class="string">&quot;Miao&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Animal animal = <span class="keyword">new</span> Cat();</span><br><span class="line">		animal.call();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>关于第六条，我们可以理解为初始化子类对象的时候，会同时在其中创建一个父类的subobject，本质上的理解：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/51920553">https://www.zhihu.com/question/51920553</a></p>
</li>
<li><p>继承类的初始化顺序：父类static initialization-&gt;子类static initialization-&gt;父类fields被设置成默认值-&gt;子类fields被设置成默认值-&gt;父类constructor-&gt;子类constructor</p>
</li>
</ol>
<h2 id="The-Final-keyword"><a href="#The-Final-keyword" class="headerlink" title="The Final keyword"></a>The Final keyword</h2><p>Final keyword means ‘This can not be changed’ in general. You might want to prevent cahges for two reasons: design or effciency.</p>
<h3 id="Final-data"><a href="#Final-data" class="headerlink" title="Final data"></a>Final data</h3><p>Final data分为两种，一种是final primitives，一种是final object reference。Final primitives代表着这个field的value就是不可变的，final object reference代表这个field的reference不可以再变了，但是它的value是可以变的<br>定义为final的fields是可以没有被初始化的，但是在使用这个field之前一定要完成初始化</p>
<h3 id="Final-arguments"><a href="#Final-arguments" class="headerlink" title="Final arguments"></a>Final arguments</h3><p>Final arguments means that inside the method you cannot change what the argument reference points</p>
<h3 id="Final-methods"><a href="#Final-methods" class="headerlink" title="Final methods"></a>Final methods</h3><p>Final methods的作用是防止子类override</p>
<h3 id="Final-and-Private"><a href="#Final-and-Private" class="headerlink" title="Final and Private"></a>Final and Private</h3><p>private method in a class are implicitly final. 因为private method只有自己的类中能看到，即使是子类也看到父类的private method，更不能够override它</p>
<h3 id="Final-classes"><a href="#Final-classes" class="headerlink" title="Final classes"></a>Final classes</h3><p>Final class不能被继承，并且final class里的methods自动是final的(因为不能继承，也就谈不上override了)</p>
<h1 id="Polymorphism-dynamic-binding-late-binding-run-time-binding"><a href="#Polymorphism-dynamic-binding-late-binding-run-time-binding" class="headerlink" title="Polymorphism(dynamic binding/late binding/run-time binding)"></a>Polymorphism(dynamic binding/late binding/run-time binding)</h1><p>Upcast: 从子类转成父类，总是安全的； downcase：从父类转成子类，需要加括号并确认要转的确实是这个子类</p>
<h2 id="Method-call-binding"><a href="#Method-call-binding" class="headerlink" title="Method-call binding"></a>Method-call binding</h2><p>Early-binding: 在compile time，编译器只会根据某个对象的表面上写的是什么class从而判断他能不能call某个方法，如果不能的话会报compile-error<br>Late-binding：在run time，编译器会真的决定这个对象到底是什么class(而不是根据他表面上是什么class)，并使用它真正的class里的那个method去call<br>比如<code>Shape s = new Circle(); s.draw();</code>，compile time，编译器只会检查Shape类有没有draw这个方法，没有的话报错，run time，当我们想要使用s对象的draw method的时候，编译期才会真正去查看s对象真是的类，虽然他被定义为Shape类，但真实的类是Circle，所以最终会调用Circle类里的draw方法<br>总结来说，compile time看等号左边，run time看等号右边</p>
<h2 id="几个不支持多态-dynamic-binding-的例子"><a href="#几个不支持多态-dynamic-binding-的例子" class="headerlink" title="几个不支持多态(dynamic binding)的例子"></a>几个不支持多态(dynamic binding)的例子</h2><ol>
<li>overriding private method</li>
<li>fields：fields不存在override也就没有多态，不会使用dynamic binding，会使用等号左边的class里的field。子类和父类是可以有相同名字的field的，子类默认使用本身类的field，如果想使用父类的field，需要加上super</li>
<li>static methods： static method是和class绑定的，不会使用dynamic binding，会使用等号左边的class里的static method</li>
</ol>
<h1 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h1><h2 id="Abstract-classes-and-methods"><a href="#Abstract-classes-and-methods" class="headerlink" title="Abstract classes and methods"></a>Abstract classes and methods</h2><ol>
<li>抽象方法指的是一个方法没有具体的实现，比如<code>abstract void f()</code>。 一个类中如果有一个或多个抽象方法，那么这个类我们必须声明成抽象类<code>abstract class test()&#123;&#125;</code></li>
<li>抽象类不可以声明相应的对象，抽象类是为了继承使用的。当我们继承一个抽象类的时候，子类可以override抽象类中的抽象方法，也可以继续不实现这个抽象方法，而是继续声明成抽象方法，留给这个子类的子类去实现</li>
<li>抽象类可以一个抽象方法都没有，即都是实现好的方法，这个时候使用抽象类的目的就是不让这个类可以声明对象</li>
</ol>
<h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><ol>
<li>The interface keyword produces a completely abstract class, ont that provides no implementation at all. it allows the creator to determine method names, argument lists and return types, but no method bodies</li>
<li>We can define fileds in interface, but these are implicitly static and final</li>
<li>Interface里定义的methods即使我们不定义为public，也都自动都是public</li>
<li>java中一个类只可以有一个父类，但是可以有多个interface，这就使得多态的用法更加的灵活。一个类可以继承多个interface(An x is an a and a b and a c)，当他需要变成哪个interface类型的时候，他就可以成为那个interface类型</li>
</ol>
<h1 id="Inner-class"><a href="#Inner-class" class="headerlink" title="Inner class"></a>Inner class</h1><ol>
<li>If you want to make an object of inner class anywhere except from whin a non-static method of the outer class, you must specify the type of that object as <em>OuterClassName.InnerClassName</em></li>
<li>Inner class在声明对象时，ourter class的对象必须已经存在，我们不可以用<code>OuterClassName.InnerClassName test = new OuterClassName.InnerClassName()</code>来单独声明Inner class的对象，inner class’寄生于’outer class中，只有outer class有了对象，inner class才能有对象</li>
<li>当我们想要在inner class使用outer class对象的reference的时候，我们可以使用<code>OuterClassName.this</code>来指代</li>
<li>当我们已经有了outer class的对象，想要声明inner class的对象的时候，我们可以用<code>OuterClassName outerClass = new OuterClassName(); OuterClassName.InnerClassName innerClass = outerClass.new InnerClassName();</code>来声明</li>
</ol>
<h2 id="Inner-class-and-upcasting"><a href="#Inner-class-and-upcasting" class="headerlink" title="Inner class and upcasting"></a>Inner class and upcasting</h2><p>使用inner class和upcasting，可以起到很好的封装效果，下面的例子对于Cat类，我们想要有一个比较器并且这个比较器只存在于Cat类中并且不能被别人修改，这种情况下我们可以定义一个private inner class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CatComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cat cat1, Cat cat2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cat1.age - cat2.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparator <span class="title">getCatComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CatComparator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat cat1 = <span class="keyword">new</span> Cat(<span class="number">10</span>);</span><br><span class="line">        Cat cat2 = <span class="keyword">new</span> Cat(<span class="number">12</span>);</span><br><span class="line">        Comparator comparator = cat1.getCatComparator();</span><br><span class="line">        <span class="keyword">int</span> res = comparator.compare(cat1, cat2);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，这里的我定义的inner class CatComparator是private，但是在implement comparator后，它override了一个public的方法，所以出现了在private类里面存在一个public方法：这是合情合理的，类的visibility和方法的visibility没有任何关系，两者是完全独立的。这里我们不想让别人修改我们的CatComparator类的定义，所以定义为private，同时我们也需要使用compare方法去比较猫的年龄，所以compare方法定义为public也是合理的</p>
<h2 id="Anonymous-Inner-class"><a href="#Anonymous-Inner-class" class="headerlink" title="Anonymous Inner class"></a>Anonymous Inner class</h2><p>匿名内部类就是在类中创建匿名的内部类，语法是当我们new一个对象的时候，我们说等等，我想要继承这个对象的类，并且new这个新生成的匿名内部继承类。这样做的好处是这个匿名内部类只被我们使用一次，不会被client engineer误用。所以上面的例子我们可以用匿名内部类简化成下面这样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparator <span class="title">getCatComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Comparator&lt;Cat&gt; () &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cat cat1, Cat cat2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cat1.age - cat2.age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">上面我们创建匿名内部类用的是默认的构造器，如果我们想要继承的父类没有默认构造器，只有含参构造器该怎么办呢？我们可以使用下面这个离子的办法：</span><br><span class="line">```JAVA</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;i=x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Base constructor call:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.value() * <span class="number">47</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们不只是想单单call父类的构造器，我们还想要写子类自己新的构造器，这个时候我们可以使用instance initialization：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;i=x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Base constructor call:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x) &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            &#123;</span><br><span class="line">                cost = x * <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        System.out.println(test.wrapping(<span class="number">10</span>).value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java8以前没有effective final概念之前，如果我们要在匿名类里面用到外面的参数，那个参数必须声明为final： <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21395848">https://www.zhihu.com/question/21395848</a><br>但是在java8以后就不需要了，所以我们上面例子里不用定义成<code>final int x</code>，编译器也不会报错</p>
<h2 id="Nested-Class"><a href="#Nested-Class" class="headerlink" title="Nested Class"></a>Nested Class</h2><p>Nested Class是一种特殊的inner class，即我们把inner class声明为static。之前在inner class部分我们提到过，要声明inner class，我们必须先声明它的outer class对象(即inner class是寄生于outer class的)。但是对于Nested Class(Static Inner Class)，就没有这样的要求，我们可以直接声明inner class的对象。<br>A nested class means： 1. You don’t need an outer-class object in order to create an object of a nested class<br>2.You can’t access a non-static outer-class object from an object of a nested class.</p>
<h2 id="Classes-inside-interface"><a href="#Classes-inside-interface" class="headerlink" title="Classes inside interface"></a>Classes inside interface</h2><p>正常来说，我们不能在interface里面放一个class(因为interface本来就是用来做抽象的)，但是我们可以把nested class放到interface里去。对于interface来说，它内部的东西默认必须是static final的，而我们的nested class是满足这个条件的。<br><em>It’s convenient to nest a class inside an interface when you want to create some common doe to be used with all different implmentations of that interface</em></p>
<h2 id="Why-inner-classes"><a href="#Why-inner-classes" class="headerlink" title="Why inner classes?"></a>Why inner classes?</h2><p>The most compelling reason for inner classes is :<br>Each inner class can independently inherit from an implementation. Thus, the inner class is not limited by whether the outer class is already inheriting from an implementation.<br>所以inner class给予了我们继承多个class的能力,同时还能方便的使用outer class的fields和methods</p>
<h1 id="Holding-your-object"><a href="#Holding-your-object" class="headerlink" title="Holding your object"></a>Holding your object</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ol>
<li><code>Arrays.asList</code>生成的List可以改变其中的元素，但不能向里面增加元素，因为本质上它是由Array生成的。如果又想使用这个方法又想增加新的元素，那么需要声明一个新的List<code>List&lt;Integer&gt; test = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5))</code></li>
<li>Collection包括List, Set, Queue, Stack, PriorityQueue</li>
</ol>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><ol>
<li>所有的Collection都有一个iterator() method，生成一个Iterator对象，这个对象有hasNext(), next(), remove()三个方法，我们可以使用这三个方法对Collection进行遍历。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Integer&gt; c = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Iterator it = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Interger i = it.next();</span><br><span class="line">    System.out.print(i);</span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Collection有iterator() method是因为所有Collection都实现了Iteratable接口</li>
<li>实现了Iteratable接口的类就可以使用foreach循环了，所以本质上foreach循环的底层是调用Iteratable.iterator()。这也解释了为什么Map不能用foreach，因为Map不是Collection，没有实现Iteratable，我们必须用<code>for(Map.Entry&lt;Integer, integer&gt; entry:map.entrySet())</code> 拿到entry set以后才可以进行遍历。</li>
</ol>
<h1 id="Error-Handling-with-Exceptions"><a href="#Error-Handling-with-Exceptions" class="headerlink" title="Error Handling with Exceptions"></a>Error Handling with Exceptions</h1><h2 id="Basic-exceptions"><a href="#Basic-exceptions" class="headerlink" title="Basic exceptions"></a>Basic exceptions</h2><ol>
<li>Exception对象的建立和普通java对象的建立完全一样：使用new，并且建立在堆(heap)上。当我们想要在某个地方抛出异常的时候，我们使用<code>throw new Throwable();</code>这样的语法结构。</li>
<li>Throwable对象是所有可以抛出的异常的源头父类。Throwable本身除了默认构造器外还有4个构造器，这五个构造器中的两个是所有JDK定义的标准异常都有的构造器：默认构造器和接收String的构造器。比如NullPointerException就只有这两个构造器： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NullPointerException()</span><br><span class="line">//Constructs a NullPointerException with no detail message.</span><br><span class="line">NullPointerException(String s)</span><br><span class="line">//Constructs a NullPointerException with the specified detail message.</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Catch-an-exception"><a href="#Catch-an-exception" class="headerlink" title="Catch an exception"></a>Catch an exception</h2><ol>
<li>try-catch block<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//Code that might generate exceptions</span></span><br><span class="line">&#125; carch (Type1 id1) &#123;</span><br><span class="line">    <span class="comment">//handle exception of Type 1</span></span><br><span class="line">&#125; carch (Type2 id2) &#123;</span><br><span class="line">    <span class="comment">//handle exception of Type 2</span></span><br><span class="line">&#125; carch (Type3 id3) &#123;</span><br><span class="line">    <span class="comment">//handle exception of Type 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当异常发生的时候，程序会去寻找第一个符合抛出异常类型的handler，并进入到那个catch块进行异常处理。这一要说明try-catch和switch有很大区别，switch必须要有个break告诉程序退出执行，否则switch会把每一个选择块都执行一遍。</li>
</ol>
<h2 id="Creating-your-own-exceptions"><a href="#Creating-your-own-exceptions" class="headerlink" title="Creating your own exceptions"></a>Creating your own exceptions</h2><ol>
<li>如果在程序中的exception我们没有使用try-catch进行处理，或者我们自己在程序中抛出了某些异常，我们有义务告诉client programmer我们抛出了哪些异常，这样方便他们在使用我们的程序的时候去检查这些异常。所以Java引入了异常说明(Exception Specification)，也就是我们需要在方法外说明我们在这个方法里抛出了哪些异常：<code>void f() throws TooBig, TooSmall, DivZero &#123;&#125;</code></li>
<li>Throwable由两个子类继承： Error类和Exception类。Error类是一些程序运行中本身遇到的错误，比如线程死掉了；Exception类是我们需要处理的，它又分为Checked Exception和Unchecked Exception。 Checked Exception是那些我们写代码的时候必须处理的异常，我们必须<strong>使用try-catch处理这个异常或者使用异常说明告诉程序继续抛出这个异常</strong>，否则编译器会报错。<br>Unchecked Exception是那些在Runtime可能发生的异常，属于我们不用主动处理的异常，Unchecked Exception是那些继承自RuntimeException(包括)的异常。</li>
</ol>
<h2 id="Catching-any-exception"><a href="#Catching-any-exception" class="headerlink" title="Catching any exception"></a>Catching any exception</h2><ol>
<li><p>Throwable类本身有一些很有用的方法：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Gets the detailed exception message</span><br><span class="line">String getMessage()</span><br><span class="line">string getLocalizedMessage()</span><br><span class="line"></span><br><span class="line">//Returns a short description of Throwable, including the detail message if there is one</span><br><span class="line">String tostring()</span><br><span class="line"></span><br><span class="line">//Prints the Throwable and the Throwalbe&#x27;s call stack trace</span><br><span class="line">void printStackTrace()</span><br></pre></td></tr></table></figure>
<p> getMessage()是tostring()的子集；tostring()是printStackTrace()的子集</p>
</li>
<li><p>处理异常一个非常常见的方式就是rethrow：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">RootException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">CausedException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Main main = <span class="keyword">new</span> Main();</span><br><span class="line">		main.h();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">		g();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			f();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CausedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> CausedException</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RootException();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (RootException e) &#123;</span><br><span class="line">			CausedException causedException = <span class="keyword">new</span> CausedException();</span><br><span class="line">			<span class="keyword">throw</span> causedException;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 最后打印出来的异常是： </p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Main$CausedException</span><br><span class="line">	at Main.f(Main.java:30)</span><br><span class="line">	at Main.g(Main.java:19)</span><br><span class="line">	at Main.h(Main.java:14)</span><br><span class="line">	at Main.main(Main.java:10)</span><br></pre></td></tr></table></figure></li>
<li><p>Exception chaining: 当我们rethrow一个新的一场的时候，我们往往想要保留原异常的信息。比如上个例子中的CauseException是由RootException引起的，但是最后打印出来的异常信息中，我们完全找不到RootException了。这个时候我们就需要使用异常串。异常串的原理就是我们在抛出一个新的异常的同时，告诉它造成这个新异常的cause，这样程序就会知道是谁造成的这个新的异常。Throwable本身是有一个接受cause参数的构造器的<code>Throwable(Throwable cause)</code>。但是这个构造器只被Error，Exception和RuntimeException继承了，比如NullPointerException就没有这个构造器，那么如果我们想要NullPointerException知道它的cause，我们就需要使用<code>initCause()</code>这个方法。如果是我们自己定义的异常，我们可以选择重写Exception的带cause参数的构造器，那么样我们就可以直接使用了。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">RootException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">CausedException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">CausedException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">CausedException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Main main = <span class="keyword">new</span> Main();</span><br><span class="line">		main.h();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">		g();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			f();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CausedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> CausedException</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RootException();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (RootException e) &#123;</span><br><span class="line">			CausedException causedException = <span class="keyword">new</span> CausedException(e);</span><br><span class="line">			<span class="keyword">throw</span> causedException;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 打印出来的结果是：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main$CausedException: Main$RootException</span><br><span class="line">	at Main.f(Main.java:35)</span><br><span class="line">	at Main.g(Main.java:24)</span><br><span class="line">	at Main.h(Main.java:19)</span><br><span class="line">	at Main.main(Main.java:15)</span><br><span class="line">Caused by: Main$RootException</span><br><span class="line">	at Main.f(Main.java:33)</span><br><span class="line">	... 3 more</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Performing-cleanup-with-finally"><a href="#Performing-cleanup-with-finally" class="headerlink" title="Performing cleanup with finally"></a>Performing cleanup with finally</h3><ol>
<li>finally块里的语句总是会执行，即使try块里有break，continue或者return</li>
<li>finally总是执行的机制会导致一个坏处：lost exception。比如下面这个例子： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	throw new ImportantException();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">	throw new NotImportantException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 或者 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	throw new ImportantException();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 上面两个例子都是导致我们丢失ImportantException</li>
</ol>
<h2 id="Exception-restrictions"><a href="#Exception-restrictions" class="headerlink" title="Exception restrictions"></a>Exception restrictions</h2><ol>
<li><strong>当子类重写父类的方法时，子类重写的方法只能抛出父类方法已有的异常或已有异常的子异常。</strong> 这个是很好理解的，如果子类方法抛出了父类方法所没有的异常，那么如果我们使用多态(upcast)的时候，编译器认为父类方法没有抛出新增加的异常，但其实在runtime，子类抛出了该异常，这样程序就无法处理了。所以Java严格要求子类重写的方法只能抛出父类方法已有的异常或已有异常的子异常。</li>
<li>总结上面一条就是： 异常的继承只能变得更窄，而不能变得更宽。这正好和类的继承相反，类的继承只能变得更宽，因为父类的变量和方法子类默认已经继承，我们只能重写父类已有的方法或者增加新的方法。</li>
<li>所以子类重写的方法是可以不抛出异常的，即使父类抛出了某些异常(变窄了)</li>
<li>子类中新定义(非重写)的方法没有以上限制</li>
<li>构造器不用遵循上述的限制，即可以随便抛出不同于父类构造器的异常，但是子类<strong>所使用的父类构造器</strong>的异常一定要继承(这里强调所使用的父类构造器的原因是子类可以不调用默认构造器，但是无论如何子类必须调用一个父类的构造器，否则编译器会报错)。构造器不用遵循上述规则的原因也很简单，构造器不像方法有多态，构造器总是出现在等号的右边。</li>
</ol>
<h3 id="Exception-matching"><a href="#Exception-matching" class="headerlink" title="Exception matching"></a>Exception matching</h3><ol>
<li>Catch异常的时候不一定是完美符合，即子异常也会被父异常的catch语句抓到。所以我们总是在try-catchd的最后补上<code>catch(Exception e)</code>，而不能在最开始写。 </li>
</ol>
<h1 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h1><h2 id="Immutable-Strings"><a href="#Immutable-Strings" class="headerlink" title="Immutable Strings"></a>Immutable Strings</h2><ol>
<li>String object都是不可更改的(immutable)，所有对于String的操作都是生成一个新的String，而非更改旧的</li>
</ol>
<h2 id="Overloading-‘-’-vs-StringBuilder"><a href="#Overloading-‘-’-vs-StringBuilder" class="headerlink" title="Overloading ‘+’ vs. StringBuilder"></a>Overloading ‘+’ vs. StringBuilder</h2><ol>
<li>Java编译器在处理String的加操作时，底层其实也是在使用StringBuilder的。但是在遇到循环的时候，编译器会生成多个StringBuilder在每一次循环的时候。</li>
<li>所以对于String和StringBuilder的使用：简单的加操作直接用String，涉及到循环的时候一定要用StringBuilder</li>
<li>StringBuilder是java1.5引入的，之前使用的是StringBuffer，原理与StringBuilder基本相同，但是StringBuffer是线程安全的，而stringBuilder是线程不安全的，所以这就导致StringBuffer比StringBuilder效率要低</li>
</ol>
<h2 id="Formatting-output"><a href="#Formatting-output" class="headerlink" title="Formatting output"></a>Formatting output</h2><ol>
<li>Java中的format相关实现都是由<code>java.util.formatter</code>来完成的。常用的<code>String.format()</code>的内部实现也使用的formatter</li>
<li>Formatter的使用见： <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html">https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html</a></li>
</ol>
<h2 id="Regular-expressions"><a href="#Regular-expressions" class="headerlink" title="Regular expressions"></a>Regular expressions</h2><ol>
<li>在其他语言中，<code>\\</code> 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。在 Java 中，<code>\\</code> 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。所以，在其他的语言中（如 Perl），一个反斜杠 <code>\</code> 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 <code>\\</code> 代表其他语言中的一个 <code>\</code>，这也就是为什么表示一位数字的正则表达式是 <code>\\d</code>，而表示一个普通的反斜杠是 <code>\\</code>。</li>
<li>其他关于正则表达式的表达可以参考： <a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017639890281664">https://www.liaoxuefeng.com/wiki/1016959663602400/1017639890281664</a></li>
<li>Java中关于正则表达式的内部实现都是由Pattern类和Matcher类完成的，这里有时间可以好好看一下</li>
</ol>
<h1 id="Type-Information"><a href="#Type-Information" class="headerlink" title="Type Information"></a>Type Information</h1><p>Run time information(RTTI)分为两部分。传统的RTTI假定我们在编译时已经知道了所有的类型信息；另一种反射机制允许我们在运行时发现和使用类型信息。</p>
<h2 id="The-Class-object"><a href="#The-Class-object" class="headerlink" title="The Class object"></a>The Class object</h2><ol>
<li>平时我们生成Java对象的时候都是直接用new，但new的背后其实隐藏了一些步骤。当我们写好一个新的类并进行编译时，JVM都会为这个新的类创建一个对应的Class对象，并将其存在.class的字节码中，这个Class对象会用来生成这个类的对象。</li>
<li>JVM一开始运行的时候，并不是所有的类都被直接装载进来，而是动态的逐渐的装载进来。JVM使用Java Class Loader来进行类的装载：每当程序第一次使用某个类的静态成员static member(包括静态常量，静态变量和静态方法)的时候，JVM就会将这个类加载进来(<strong>类的构造器默认是静态的，这也是为什么我们使用new就会装载这个类的原因</strong>)</li>
<li>当我们想要使用某个类的静态成员的时候，Java Class Loader会先检查这个类是否已经被加载了，如果没有的话就去寻找这个类的.class字节码并进行加载，这样这个类的Class对象也就同时被加载到了内存中，后面我们就可以使用这个Class对象来创建这个类的对象</li>
<li>如果我们想要得到Class对象的引用，我们可以使用<code>Class test = Class.forName(FULL_QUALIFIED_NAME)</code>。FULL_QUALIFIED_NAME的意思是要包括包名。这个时候有个疑问：有没有可能想要得到的Class对象还没有被加载进JVM呢？这个问题很好，答案是这个方法的一个“副作用”就是如果这个类还没有被加载，那么加载它。另一个方法去得到Class对象的引用是如果你已经有一个类的对象，可以使用<code>getClass()</code>方法。</li>
<li>之前说过Class对象是用来生成这个类的对象，这也就说明了Class对象存储了这个类几乎所有的信息。其中有一些常用的方法：<br>getName()：返回类的全名(包括包名)<br>getSimpleName()：返回类名<br>getInterfaces()：返回一个数组，里面包括这个类的所有接口的Class对象的引用<br>getSuperClass()：返回这个类的父类的Class对象的引用<br>newInstance()：使用默认构造器创建这个类的一个对象。后面在反射部分会介绍怎么使用别的构造器创建对象</li>
</ol>
<h3 id="Class-literals"><a href="#Class-literals" class="headerlink" title="Class literals"></a>Class literals</h3><ol>
<li>第三种得到Class对象引用的方式是：<code>Test.class</code>。这种方式不仅效率更高，而且避免了<code>forName()</code>方法可能抛出的异常。</li>
<li>基本类也都有Class literals。比如<code>int.class</code>就和<code>Integer.TYPE</code>完全一样。</li>
<li>前面我们提到把字节码加载到JVM中，但这其实只是准备使用一个类的的第一步：<ul>
<li>加载 加载是由Java Class Loader完成的，它的作用是把.class字节码加载到JVM中(Class对象也就被创建了，因为Class对象存在.class字节码中)</li>
<li>链接 链接会验证字节码；为静态域static field(静态变量+静态常量)分配存储空间；如果有必要的话，解析这个类创建的对其他类的引用</li>
<li>初始化 初始化父类；执行静态变量的初始化和静态代码块<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal = <span class="number">47</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal2 =</span><br><span class="line">	ClassInitialization.rand.nextInt(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Initializing Initable&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable2</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> staticNonFinal = <span class="number">147</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Initializing Initable2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable3</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> staticNonFinal = <span class="number">74</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Initializing Initable3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitialization</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Class initable = Initable.class;</span><br><span class="line">	System.out.println(<span class="string">&quot;After creating Initable ref&quot;</span>);</span><br><span class="line">	<span class="comment">// Does not trigger initialization:</span></span><br><span class="line">	System.out.println(Initable.staticFinal);</span><br><span class="line">	<span class="comment">// Does trigger initialization:</span></span><br><span class="line">	System.out.println(Initable.staticFinal2);</span><br><span class="line">	<span class="comment">// Does trigger initialization:</span></span><br><span class="line">	System.out.println(Initable2.staticNonFinal);</span><br><span class="line">	Class initable3 = Class.forName(<span class="string">&quot;Initable3&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;After creating Initable3 ref&quot;</span>);</span><br><span class="line">	System.out.println(Initable3.staticNonFinal);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">After creating Initable ref</span></span><br><span class="line"><span class="comment">47</span></span><br><span class="line"><span class="comment">Initializing Initable</span></span><br><span class="line"><span class="comment">258</span></span><br><span class="line"><span class="comment">Initializing Initable2</span></span><br><span class="line"><span class="comment">147</span></span><br><span class="line"><span class="comment">Initializing Initable3</span></span><br><span class="line"><span class="comment">After creating Initable3 ref</span></span><br><span class="line"><span class="comment">74</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
由于类的初始化阶段会执行静态块，所以我们可以通过判断静态块是否执行来判断类是否初始化了。从这个例子中可以看出来：<ol>
<li><code>.class</code>只触发了类的加载，并不会触发类的初始化，但是<code>Class.forName()</code>会触发类的加载</li>
<li>类似Initable.staticFinal这样的final静态常量，并不会触发初始化。这很合理，因为这种静态变量在编译阶段就已经写死了，并不需要进行初始化</li>
<li>类似Initable.staticFinal2这样的final静态变量，会触发初始化</li>
<li>如果一个静态域field不是final的，那么获取他总是需要链接和初始化的步骤的</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="Generic-class-references"><a href="#Generic-class-references" class="headerlink" title="Generic class references"></a>Generic class references</h3><ol>
<li>我们可以使用泛型来使Class类对象更具体，这样的话编译器就会在编译阶段检查Class类对象所代表的类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassReferences</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class intClass = <span class="keyword">int</span>.class;</span><br><span class="line">    Class&lt;Integer&gt; genericIntClass = <span class="keyword">int</span>.class;</span><br><span class="line">    genericIntClass = Integer.class; <span class="comment">// Same thing</span></span><br><span class="line">    intClass = <span class="keyword">double</span>.class;</span><br><span class="line">    <span class="comment">// genericIntClass = double.class; // Illegal</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure></li>
<li>那么如果我们要放松泛型的限制该怎么做呢，可能有人会想到<code>Class&lt;Number&gt; genericNumberClass = int.class;</code>，但是这样是不对的，因为<strong>虽然Number类是Integer类的父类，但是Number Class不是Integer Class的父类。</strong>这个后面在泛型会深入讲解</li>
<li>真正可以放松限制的是使用泛型通配符<code>?</code>，它代表着任何类型。我们使用的时候应该使用<code>Class&lt;?&gt;</code>而不是<code>Class</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardClassReferences</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; intClass = <span class="keyword">int</span>.class;</span><br><span class="line">    intClass = <span class="keyword">double</span>.class;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure></li>
<li>使用泛型的一个好处就是由于Class类对象的类型是确定的，当我们使用<code>newInstance()</code>的时候，返回的不会只是一个Object的对象，而是一个确定的类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericNewInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;Test&gt; testClass = Test.class;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Test test = testClass.newInstance();</span><br><span class="line">            System.out.println(test);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Checking-before-a-cast"><a href="#Checking-before-a-cast" class="headerlink" title="Checking before a cast"></a>Checking before a cast</h2><ol>
<li><code>x instanceof Y</code>可以用来进行类型检查，在进行类型转换的时候很有用，否则类型转换可能抛出<code>ClassCastException</code></li>
</ol>
<h2 id="Rgistered-factories"><a href="#Rgistered-factories" class="headerlink" title="Rgistered factories"></a>Rgistered factories</h2><ol>
<li>注册工厂是一种设计模式，需要进行一下学习</li>
</ol>
<h2 id="instanceof-vs-Class-equicalence"><a href="#instanceof-vs-Class-equicalence" class="headerlink" title="instanceof vs. Class equicalence"></a>instanceof vs. Class equicalence</h2><ol>
<li><code>x instanceof Y</code>的意思是判断x对象是不是Y类型的实例，所以x既可以是Y类型的对象，也可以Y类型子类的对象。所以<code>derivedClassObject instanceof BaseClass</code>返回true</li>
<li>当我们比较Class类对象的时候，子类与父类的Class对象是不同的，所以<code>DrivedClass.class != BaseClass.class</code></li>
</ol>
<h2 id="Reflection-runtime-class-information"><a href="#Reflection-runtime-class-information" class="headerlink" title="Reflection: runtime class information"></a>Reflection: runtime class information</h2><ol>
<li>反射是指我们在编译阶段不知道类的具体信息，相关信息只有在runtime才会被得到，这个时候我们使用反射。反射与普通的RTTI没什么区别，只是一个是在编译阶段知道Class类对象的信息(.class字节码编译阶段就已存在)，另一个是在runtime阶段才能够知道</li>
<li><code>java.lang.reflect</code>包提供了Field，Method和Constructor类。我们可以使用Custructor类去创建新的对象；使用get()和set()去读或者改变一个Field对象；使用invoke()去call一个Method对象</li>
</ol>
<h2 id="Dynamic-proxies"><a href="#Dynamic-proxies" class="headerlink" title="Dynamic proxies"></a>Dynamic proxies</h2><ol>
<li>动态代理是反射一个很好的应用例子： <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20794107">https://www.zhihu.com/question/20794107</a></li>
</ol>
<h1 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuqinglong/p/9456193.html">https://www.cnblogs.com/wuqinglong/p/9456193.html</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020497160">https://segmentfault.com/a/1190000020497160</a></p>
<h2 id="Simple-Generics-Generic-Types"><a href="#Simple-Generics-Generic-Types" class="headerlink" title="Simple Generics(Generic Types)"></a>Simple Generics(Generic Types)</h2><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/types.html">https://docs.oracle.com/javase/tutorial/java/generics/types.html</a></p>
<h3 id="Raw-Type"><a href="#Raw-Type" class="headerlink" title="Raw Type"></a>Raw Type</h3><p>A raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    public void set(T t) &#123; /* ... */ &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To create a parameterized type of Box<T>, you supply an actual type argument for the formal type parameter T:<br><code>Box&lt;Integer&gt; intBox = new Box&lt;&gt;();</code></p>
<p>If the actual type argument is omitted, you create a raw type of Box<T>:<br><code>Box rawBox = new Box();</code><br>Therefore, Box is the raw type of the generic type Box<T>. However, a non-generic class or interface type is not a raw type.</p>
<p>Raw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior — a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">Box rawBox = stringBox;               <span class="comment">// OK</span></span><br><span class="line">But <span class="keyword">if</span> you assign a raw type to a parameterized type, you get a warning:</span><br><span class="line"></span><br><span class="line">Box rawBox = <span class="keyword">new</span> Box();           <span class="comment">// rawBox is a raw type of Box&lt;T&gt;</span></span><br><span class="line">Box&lt;Integer&gt; intBox = rawBox;     <span class="comment">// warning: unchecked conversion</span></span><br><span class="line">You also get a warning <span class="keyword">if</span> you use a raw type to invoke generic methods defined in the corresponding generic type:</span><br><span class="line"></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">Box rawBox = stringBox;</span><br><span class="line">rawBox.set(<span class="number">8</span>);  <span class="comment">// warning: unchecked invocation to set(T)</span></span><br></pre></td></tr></table></figure>
<p>The warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.</p>
<p>The Type Erasure section has more information on how the Java compiler uses raw types.</p>
<p><strong>Raw Type的引用可以hold泛型对象，并且不会警告，这是为了兼容性；泛型的引用反之也可以hold Raw Type对象，但会报警告</strong></p>
<p><strong>由于有Raw Type的存在，泛型间的引用传递很危险，比如：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList&lt;String&gt;();//no warning</span><br><span class="line">List&lt;Integer&gt; = list;//warning, but very bad result!</span><br></pre></td></tr></table></figure>
<p>上面的例子只会报一个警告，但是是很危险的，因为我们把一个存有String的List对象被赋值给了一个List<Integer>的引用</p>
<h3 id="Unchecked-Error-Messages"><a href="#Unchecked-Error-Messages" class="headerlink" title="Unchecked Error Messages"></a>Unchecked Error Messages</h3><p>As mentioned previously, when mixing legacy code with generic code, you may encounter warning messages similar to the following:</p>
<p>Note: Example.java uses unchecked or unsafe operations.<br>Note: Recompile with -Xlint:unchecked for details.<br>This can happen when using an older API that operates on raw types, as shown in the following example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class WarningDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Box&lt;Integer&gt; bi;</span><br><span class="line">        bi = createBox();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static Box createBox()&#123;</span><br><span class="line">        return new Box();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The term “unchecked” means that the compiler does not have enough type information to perform all type checks necessary to ensure type safety. The “unchecked” warning is disabled, by default, though the compiler gives a hint. To see all “unchecked” warnings, recompile with -Xlint:unchecked.</p>
<p>Recompiling the previous example with -Xlint:unchecked reveals the following additional information:</p>
<p>WarningDemo.java:4: warning: [unchecked] unchecked conversion<br>found   : Box<br>required: Box&lt;java.lang.Integer&gt;<br>        bi = createBox();<br>                      ^<br>1 warning<br>To completely disable unchecked warnings, use the -Xlint:-unchecked flag. The @SuppressWarnings(“unchecked”) annotation suppresses unchecked warnings. If you are unfamiliar with the @SuppressWarnings syntax, see Annotations.</p>
<h2 id="Generic-methods"><a href="#Generic-methods" class="headerlink" title="Generic methods"></a>Generic methods</h2><p>前面我们已经展示了在类(或者接口，接口与类是类似的)上使用泛型的例子，我们也可以直接在方法上使用泛型，语法是：在返回值之前加上一个泛型参数列表(用<code>&lt;</code>和<code>&gt;</code>括起来)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getKey().equals(p2.getKey()) &amp;&amp;</span><br><span class="line">               p1.getValue().equals(p2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type Inference"></a>Type Inference</h3><p>当我们使用声明好的泛型方法的时候，我们并不需要像泛型类那样显式的声明我们所要使用的类，而是可以借助Java自带的类型推断来知道我们需要使用的类。<strong>类型推断可以根据我们传入泛型方法的参数的并集来判断我们使用的类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">pick</span><span class="params">(T a1, T a2)</span> </span>&#123; <span class="keyword">return</span> a2; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Serializable serializable = pick(<span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，我们两个泛型参数T分别被一个String和一个ArrayList表示，那么最终Java系统判断结果是String和ArrayList的并集也就是Serializable</p>
<h3 id="Explicit-type-specification"><a href="#Explicit-type-specification" class="headerlink" title="Explicit type specification"></a>Explicit type specification</h3><ol>
<li>虽然Java系统可以自动帮我们判断泛型参数最后会使用什么类，我们也可以显式的声明它，语法是在使用函数的<code>.</code>的后面加上想使用的类型：<br>`Serializable s = Test.<Serializable>pick(“d”, new ArrayList<String>());</li>
</ol>
<h2 id="Generics-Inheritance-and-Subtypes"><a href="#Generics-Inheritance-and-Subtypes" class="headerlink" title="Generics, Inheritance, and Subtypes"></a>Generics, Inheritance, and Subtypes</h2><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html">https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html</a><br>a-&gt;b的意思是a是b的子类<br><strong><code>Integer-&gt;Number</code>，但是<code>List&lt;Number&gt;</code>不是<code>List&lt;Integer&gt;</code>的父类，两者没有任何关系！</strong><br><code>List&lt;Number&gt;</code><br><code>List&lt;Integer&gt;</code> -&gt; <code>Object</code><br><code>ArrayList&lt;Integer&gt;</code> -&gt; <code>List&lt;Integer&gt;</code> -&gt; <code>Collection&lt;Integer&gt;</code></p>
<h2 id="The-mystery-of-erasure"><a href="#The-mystery-of-erasure" class="headerlink" title="The mystery of erasure"></a>The mystery of erasure</h2><ol>
<li><p>Java的泛型并不是在最开始就有的，而是在Java1.5才被加入的，所以Java泛型是由擦除实现的，也就是说关于泛型的信息在runtime是看不到的，所以<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>本质上在runtime是一种类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">    Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">    System.out.println(c1 == c2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></li>
<li><p>擦除的作用效果是擦除到一个泛型的边界，如果一个泛型没有定义边界，那么它就会被擦除成<code>Object</code>类；如果一个泛型定义了边界<code>&lt;T extends Integer&gt;</code>，那么就会擦除到它的边界也就是这里的Integer。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HasF</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;HasF.f()&quot;</span>); &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T obj;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manipulator</span><span class="params">(T x)</span> </span>&#123; obj = x; &#125;</span><br><span class="line"><span class="comment">// Error: cannot find symbol: method f():</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 这里由于T没有定义边界，被擦除成了Object，那么它不认为自己有<code>f()</code>方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manipulator2</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">HasF</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T obj;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manipulator2</span><span class="params">(T x)</span> </span>&#123; obj = x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manipulate</span><span class="params">()</span> </span>&#123; obj.f(); &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>
<p> 这里由于T定义了边界，被擦除成了HasF，那么它知道自己有<code>f()</code>方法</p>
</li>
</ol>
<h3 id="先检查，再编译"><a href="#先检查，再编译" class="headerlink" title="先检查，再编译"></a>先检查，再编译</h3><p>Q: 既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？</p>
<p>A: Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);  </span><br><span class="line">    list.add(<span class="number">123</span>);<span class="comment">//编译错误  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的程序中，使用add方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为Object，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p>
<p>那么，这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。<br>以 ArrayList举例子，以前的写法:<br><code>ArrayList list = new ArrayList();  </code><br>现在的写法:<br><code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code><br>如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：<br>ArrayList<String> list1 = new ArrayList(); //第一种 情况, 这样是没有错误的，不过会有个编译时警告。<br>ArrayList list2 = new ArrayList<String>(); //第二种 情况<br>不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。</p>
<p><strong>因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正设计类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行</strong>。</p>
<p>举例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList();  </span><br><span class="line">        list1.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        list1.add(<span class="number">1</span>); <span class="comment">//编译错误  </span></span><br><span class="line">        String str1 = list1.get(<span class="number">0</span>); <span class="comment">//返回类型就是String  </span></span><br><span class="line"></span><br><span class="line">        ArrayList list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line">        list2.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        list2.add(<span class="number">1</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        Object object = list2.get(<span class="number">0</span>); <span class="comment">//返回类型就是Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;String&gt;().add(<span class="string">&quot;11&quot;</span>); <span class="comment">//编译通过  </span></span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;String&gt;().add(<span class="number">22</span>); <span class="comment">//编译错误  </span></span><br><span class="line"></span><br><span class="line">        String str2 = <span class="keyword">new</span> ArrayList&lt;String&gt;().get(<span class="number">0</span>); <span class="comment">//返回类型就是String  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</strong></p>
<h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。</p>
<p>既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p>
<p>看下ArrayList.get()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">    RangeCheck(index);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在return之前，会根据泛型变量进行强转。假设泛型类型变量为Date，虽然泛型信息会被擦除掉，但是会将(E) elementData[index]，编译为(Date)elementData[index]。所以我们不用自己进行强转。当存取一个泛型域时也会自动插入强制类型转换。假设Pair类的value域是public的，那么表达式：<br><code>Date date = pair.value;</code><br>也会自动地在结果字节码中插入强制类型转换</p>
<p><strong>从以上两个小节我们得出结论：Java泛型的擦除使得代码在runtime是没有泛型信息的，泛型只作用于编译期间。编译期间，程序根据泛型信息检查输入是否符合标准，不符合会报出错误；同时根据泛型信息将输出自动进行类型转换</strong></p>
<h2 id="Compensating-for-erasure"><a href="#Compensating-for-erasure" class="headerlink" title="Compensating for erasure"></a>Compensating for erasure</h2><ol>
<li>由于擦除存在的原因，任何与runtime类型的操作泛型都不可以使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erased</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg <span class="keyword">instanceof</span> T) &#123;&#125;          <span class="comment">// Error</span></span><br><span class="line">    T <span class="keyword">var</span> = <span class="keyword">new</span> T();                 <span class="comment">// Error</span></span><br><span class="line">    T[] array = <span class="keyword">new</span> T[SIZE];         <span class="comment">// Error</span></span><br><span class="line">    T[] array = (T)<span class="keyword">new</span> Object[SIZE]; <span class="comment">// Unchecked warning</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Creating-instances-of-types"><a href="#Creating-instances-of-types" class="headerlink" title="Creating instances of types"></a>Creating instances of types</h3><ol>
<li>既然我们不能进行<code>new T()</code>的操作，解决的办法之一是使用反射： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAsFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">T x;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassAsFactory</span><span class="params">(Class&lt;T&gt; kind)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	x = kind.newInstance();</span><br><span class="line">	&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiateGenericType</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	ClassAsFactory&lt;Employee&gt; fe =</span><br><span class="line">	<span class="keyword">new</span> ClassAsFactory&lt;Employee&gt;(Employee.class);</span><br><span class="line">	print(<span class="string">&quot;ClassAsFactory&lt;Employee&gt; succeeded&quot;</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	ClassAsFactory&lt;Integer&gt; fi =</span><br><span class="line">		<span class="keyword">new</span> ClassAsFactory&lt;Integer&gt;(Integer.class);</span><br><span class="line">	&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">	print(<span class="string">&quot;ClassAsFactory&lt;Integer&gt; failed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">ClassAsFactory&lt;Employee&gt; succeeded</span></span><br><span class="line"><span class="comment">ClassAsFactory&lt;Integer&gt; failed</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
 从上面的例子可以看出来，确实是可以使用反射来创建泛型类的实例，但是Integer的实例创建失败了，原因是Integer类没有默认的构造器</li>
<li>还可以使用工厂设计模式(Factory Pattern)或者模板设计模式(Template Method)</li>
</ol>
<h2 id="Wildcards"><a href="#Wildcards" class="headerlink" title="Wildcards"></a>Wildcards</h2><h3 id="Upper-Bounded-Wildcards"><a href="#Upper-Bounded-Wildcards" class="headerlink" title="Upper Bounded Wildcards"></a>Upper Bounded Wildcards</h3><ol>
<li><p><code>List&lt;? extends Number&gt;</code>的意思是List可以包含<strong>任何</strong>Number或者Number的子类，所以以下几种表达都是合理的<br> <code>List&lt;? extends Number&gt; list= new LinkedList&lt;Number&gt;</code><br> <code>List&lt;? extends Number&gt; list= new LinkedList&lt;Integer&gt;</code><br> <code>List&lt;? extends Number&gt; list= new LinkedList&lt;Double&gt;</code><br> 所以这就导致了<code>List&lt;? extends Number&gt;</code>是不可写的(不能使用add)，因为如果写了一个Integer，但实际存储的是<code>new LinkedList&lt;Double&gt;</code>，就会出现错误</p>
<p> 但是<code>List&lt;? extends Number&gt;</code>是可读的(可以使用get)，因为我们知道读出来的一定是Number或者Number的子类</p>
</li>
</ol>
<h3 id="Lower-Bounded-Wildcards"><a href="#Lower-Bounded-Wildcards" class="headerlink" title="Lower Bounded Wildcards"></a>Lower Bounded Wildcards</h3><ol>
<li><p><code>List&lt;? super Integer&gt;</code>的意思是List可以包含<strong>任何</strong>Integer或者Integer的父类，所以以下几种表达都是合理的<br> <code>List&lt;? super Integer&gt; list= new LinkedList&lt;Integer&gt;</code><br> <code>List&lt;? super Integer&gt; list= new LinkedList&lt;Number&gt;</code><br> <code>List&lt;? super Integer&gt; list= new LinkedList&lt;Object&gt;</code></p>
<p> 所以这就导致了<code>List&lt;? super Integer&gt;</code>只能读出Object类型<br> <code>List&lt;? super Integer&gt;</code>是可写的，但是只可以写Integer或者Integer的子类</p>
<p> <strong>所以总结来说，判断能否写是根据所有的可能性取一个交集，如果交集不存在就不能写；判断能否读是根据所有的可能性取一个并集，最差也能是Object，以为Object是所有类的父类</strong></p>
</li>
</ol>
<h3 id="Unbounded-Wildcards"><a href="#Unbounded-Wildcards" class="headerlink" title="Unbounded Wildcards"></a>Unbounded Wildcards</h3><ol>
<li>根据上面的总结，<code>List&lt;?&gt;</code>不可写，只能读出Object</li>
<li>There are two scenarios where an unbounded wildcard is a useful approach:<br>If you are writing a method that can be implemented using functionality provided in the Object class. 对应第一条<br>When the code is using methods in the generic class that don’t depend on the type parameter. For example, List.size or List.clear. In fact, Class&lt;?&gt; is so often used because most of the methods in Class<T> do not depend on T. 因为第一条的限制，所以只能做与泛型读写无关的操作</li>
</ol>
<h3 id="Wildcards-and-Subtyping"><a href="#Wildcards-and-Subtyping" class="headerlink" title="Wildcards and Subtyping"></a>Wildcards and Subtyping</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/generics/subtyping.html">https://docs.oracle.com/javase/tutorial/java/generics/subtyping.html</a><br><code>List&lt;Integer&gt;</code> -&gt; <code>List&lt;?&gt;</code><br><code>List&lt;String&gt;</code> -&gt; <code>List&lt;?&gt;</code>，但是<code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code>之间没有继承关系<br><code>List&lt;Integer&gt;</code> -&gt; <code>List&lt;? extends Integer&gt;</code> -&gt; <code>List&lt;? extends Number&gt;</code> -&gt; <code>List&lt;?&gt;</code><br><code>List&lt;Number&gt;</code> -&gt; <code>List&lt;? super Number&gt;</code> -&gt; <code>List&lt;? super Integer&gt;</code> -&gt; <code>List&lt;?&gt;</code></p>
<p>如何判断泛型之间的继承关系？<br>通过比较泛型所能代表的类，如果一个泛型所能代表的类是另一个所能代表的类的子集，那他就是另一个类的子类<br>比如<code>? extends Integer</code>可以代表的类有Integer以及所有继承Integer的类；<code>? extends Number</code>可以代表的类有Number以及所有继承Number的类，明显后面是前面的父集<br>同理，<code>? super Intege</code>所能代表的类是<code>? super Number</code>的父集，所以<code>List&lt;? super Integer&gt;</code>是<code>List&lt;? super Number&gt;</code>的父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list1 = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">List&lt;? extends String&gt; list2 = list1;<span class="comment">//会报错，因为 ? extends String 不是 ？的父类，? extends String只能代表String及其子类，但 ？ 能代表所有类</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> String&gt; list3 = list1;<span class="comment">//会报错，因为 ? super String 不是 ？的父类</span></span><br><span class="line">List&lt;? extends Object&gt; list4 = list1;<span class="comment">//不会报错，因为 ? extends Object 其实就是所有类的意思，与 ? 是一样的</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> Object&gt; list5 = list1;<span class="comment">//会报错，因为 ? super Object 不是 ？的父类</span></span><br></pre></td></tr></table></figure>

<h3 id="Java泛型通配符-与-T-的区别"><a href="#Java泛型通配符-与-T-的区别" class="headerlink" title="Java泛型通配符 ? 与 T 的区别"></a>Java泛型通配符 ? 与 T 的区别</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020497160">https://segmentfault.com/a/1190000020497160</a><br>这里解释的最好的一句就是?是一个实参，而T只是一个形参(占位符)，也就是说T只能存在于泛型的编写过程中，最终在使用的时候都会被一个实参替换掉，这个实参甚至有可能是？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">test</span><span class="params">(List&lt;T&gt; input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        List&lt;?&gt; list2 = list1;<span class="comment">//list2不能写只能读，所以这里先用list1写入一个数据</span></span><br><span class="line">        Object a = test(list2);<span class="comment">//由于实参是？，根据type inference，任何类型的并集只能是object，所以我们返回的引用只能是Object，</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>? extends String</code>作为实参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">test</span><span class="params">(List&lt;T&gt; input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        List&lt;? extends String&gt; list2 = list1;<span class="comment">//list2不能写只能读，所以这里先用list1写入一个数据</span></span><br><span class="line">        String a = test(list2);<span class="comment">//由于实参是? extends String，我们知道其必是String或者String的子类，根据type inference，我们返回的引用就可以是String了</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Self-bounded-types"><a href="#Self-bounded-types" class="headerlink" title="Self-bounded types"></a>Self-bounded types</h2><h3 id="泛型类的自限定"><a href="#泛型类的自限定" class="headerlink" title="泛型类的自限定"></a>泛型类的自限定</h3><ol>
<li>自限定的意思是一个类的对象只能与另一个这个类的对象进行作用。</li>
<li>泛型类的自限定是非常常见的，比如Integer类的声明<code>public final class Integer implements Comparable&lt;Integer&gt;</code>。它的含义是：Integer类实现了一个’使用Integer类的Comparable接口’。这样的好处是什么呢？Integer对象在使用Comparable的compareTo方法的时候只能和另一个Integer对象作用，也就不可能出现<code>5.compareTo(&quot;6&quot;)</code>的情况出现。这就是自限定的作用：强制Integer在使用compareTo的方法时使用另一个Integer</li>
</ol>
<h3 id="泛型声明的完全自限定"><a href="#泛型声明的完全自限定" class="headerlink" title="泛型声明的完全自限定"></a>泛型声明的完全自限定</h3><ol>
<li><p>在上面Comparable的例子中，Comparable类本身的定义是没有任何限制的，就是<code>public interface Comparable&lt;T&gt;</code>，我们使用<code>Comparable&lt;Integer&gt;</code>的原因就是为了达到自限定，限定compareTo方法只能使用Integer。但是如果我们假设编写Java的人不小心把Integer类定义为<code>public final class Integer implements Comparable&lt;String&gt;</code>，那么这个时候我们compareTo方法只能使用String了，compareTo方法变得毫无意义，当然这个时候compareTo方法也就不叫自限定了。那么能不能把限制进一步，使得我们只要使用Comparable，就必须做到自限定，而不会出现<code>public final class Integer implements Comparable&lt;String&gt;</code>这种错误了呢？</p>
</li>
<li><p>如果我们把Comparable定义成下面的形式，就做到了凡是实现Comparable的类，必须是自限定的，上面<code>public final class Integer implements Comparable&lt;String&gt;</code>的情况就会报错了。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comparable</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p> 那么问题来了：为什么Java编写人员不把Comparable定义成上面这样的完全自限定呢？原因很简单，为了给予开发人员更多的灵活性。<br> 那么有没有哪个Java类使用了上面这种完全自限定的定义呢？Enum就是一个很好的例子<code>public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; &#125;</code>。对于所有我们定义的Enum类，我们肯定都希望只能与相同的Enum类进行作用，肯定不希望月与年可以进行比较。</p>
</li>
</ol>
<h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><h2 id="The-File-class"><a href="#The-File-class" class="headerlink" title="The File class"></a>The File class</h2><ol>
<li><p>File类的名字虽然是File，但其实传入的参数是文件路径。所以它可以表示一个真正的文件，也可能只是表示一个目录</p>
</li>
<li><p>File对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。<br>例如，调用<code>isFile()</code>，判断该File对象是否是一个已存在的文件，调用<code>isDirectory()</code>，判断该File对象是否是一个已存在的目录：</p>
</li>
<li><p>如果我们确认一个File对象时目录，那么我们可以使用<code>list()</code>方法来列出这个目录下所有的File对象；也可以使用<code>list(FileNameFilter)</code>来筛选想要返回的File对象。FileNameFilter是一个接口，所以我们很自然的可以想到用匿名类来构造实现。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: io/DirList3.java</span></span><br><span class="line"><span class="comment">// Building the anonymous inner class &quot;in-place.&quot;</span></span><br><span class="line"><span class="comment">// &#123;Args: &quot;D.*\.java&quot;&#125;</span></span><br><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">	File path = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">	String[] list;</span><br><span class="line">	<span class="keyword">if</span>(args.length == <span class="number">0</span>)</span><br><span class="line">	list = path.list();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	list = path.list(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">		<span class="keyword">private</span> Pattern pattern = Pattern.compile(args[<span class="number">0</span>]);</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	Arrays.sort(list, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">	<span class="keyword">for</span>(String dirItem : list)</span><br><span class="line">	System.out.println(dirItem);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">DirectoryDemo.java</span></span><br><span class="line"><span class="comment">DirList.java</span></span><br><span class="line"><span class="comment">DirList2.java</span></span><br><span class="line"><span class="comment">DirList3.java</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
<p> 注意到这里我们使用了内部类外面的变量args，所以需要把它定义成final。</p>
</li>
<li><p>File类不止可以判断是否是文件还是目录，我们还可以使用它创建或者删除文件，查看文件的属性等。</p>
</li>
</ol>
<h2 id="InputStream-OutputStream"><a href="#InputStream-OutputStream" class="headerlink" title="InputStream/OutputStream"></a>InputStream/OutputStream</h2><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><ol>
<li><p>InputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。</p>
</li>
<li><p>要特别注意的一点是，InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()，签名如下：<br><code>public abstract int read() throws IOException;</code>。这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。</p>
</li>
<li><p>FileInputStream是InputStream的一个子类。顾名思义，FileInputStream就是从文件流中读取数据。下面的代码演示了如何完整地读取一个FileInputStream的所有字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个FileInputStream对象:</span></span><br><span class="line">    InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = input.read(); <span class="comment">// 反复调用read()方法，直到返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n); <span class="comment">// 打印byte的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    input.close(); <span class="comment">// 关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。InputStream提供了两个重载方法来支持读取多个字节：<br> int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数<br> int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数</p>
<p> 利用上述方法一次读取多个字节时，需要先定义一个byte[]数组作为缓冲区，read()方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。read()方法的返回值不再是字节的int值，而是返回实际读取了多少个字节。如果返回-1，表示没有更多的数据了。</p>
<p> 利用缓冲区一次读取多个字节的代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">		<span class="comment">// 定义1000个字节大小的缓冲区:</span></span><br><span class="line">		<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) &#123; <span class="comment">// 读取到缓冲区</span></span><br><span class="line">			System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="FilterInputStream"><a href="#FilterInputStream" class="headerlink" title="FilterInputStream"></a>FilterInputStream</h3><ol>
<li><p>Java的IO标准库提供的InputStream根据来源可以包括：<br> FileInputStream：从文件读取数据，是最终数据源；<br> ServletInputStream：从HTTP请求读取数据，是最终数据源；<br> Socket.getInputStream()：从TCP连接读取数据，是最终数据源；<br> 等等</p>
<p> 如果我们要给FileInputStream添加缓冲功能，则可以从FileInputStream派生一个类：<br> <code>BufferedFileInputStream extends FileInputStream</code></p>
<p> 如果要给FileInputStream添加计算签名的功能，类似的，也可以从FileInputStream派生一个类：<br> <code>DigestFileInputStream extends FileInputStream</code></p>
<p> 如果要给FileInputStream添加加密/解密功能，还是可以从FileInputStream派生一个类：<br> <code>CipherFileInputStream extends FileInputStream</code></p>
<p> 如果要给FileInputStream添加缓冲和签名的功能，那么我们还需要派生<code>BufferedDigestFileInputStream</code>。如果要给FileInputStream添加缓冲和加解密的功能，则需要派生<code>BufferedCipherFileInputStream</code>。</p>
<p> 我们发现，给FileInputStream添加3种功能，至少需要3个子类。这3种功能的组合，又需要更多的子类。</p>
</li>
<li><p>为了解决这种问题，Java采用装饰器(decorator)模式设计输入输出流。比如输入流可以分为两大类：<br> 一类是直接提供数据的基础InputStream，例如：<br> FileInputStream<br> ByteArrayInputStream<br> ServletInputStream<br> 等等</p>
<p> 一类是提供额外附加功能的InputStream，他们都继承自抽象类FilterInputStream。例如：<br> BufferedInputStream<br> DigestInputStream<br> CipherInputStream<br> 等等</p>
<p> 当我们想要真正使用输入流的时候，需要先定义直接提供数据的基础的InputStream，再在外面套上各种FilterInputStream，但无论如何，最终得出的都是一个InputStream，他都有<code>int read()</code>方法:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream file = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.gz&quot;</span>);</span><br><span class="line">InputStream buffered = <span class="keyword">new</span> BufferedInputStream(file);</span><br><span class="line">InputStream gzip = <span class="keyword">new</span> GZIPInputStream(buffered);</span><br></pre></td></tr></table></figure></li>
<li><p>我们可以边写自己需要的FilterInputStream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="string">&quot;hello, world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (CountInputStream input = <span class="keyword">new</span> CountInputStream(<span class="keyword">new</span> ByteArrayInputStream(data))) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Total read &quot;</span> + input.getBytesRead() + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CountInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBytesRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read();</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read(b, off, len);</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Reader-Writer"><a href="#Reader-Writer" class="headerlink" title="Reader/Writer"></a>Reader/Writer</h2><ol>
<li><p>上一节我们提到的InputStream和OutputStream，读入和写出的都是字节流，如果我们读取或者写入的是文本文件，那么我们还需要在进行编解码。为了解决这一痛点，Java引入了新的Reader和Writer类。本质上Reader/Writer与InputStream/OutputStream没有区别，只是Reader/Writer会根据操作系统默认的编解码配置进行编解码，所以操作的是字符流.</p>
</li>
<li><p>Java内部将char存成BMP unicode，但是由于char只有两个字节，所以对于两个字节以外的NON-BMP unicode，是无法用char表示的。如果我们不想要使用系统自带的编解码，比如有的时候中文使用默认编解码就会乱码，可以如下定义：<code>Reader reader = new FileReader(&quot;src/readme.txt&quot;, StandardCharsets.UTF_8);</code>。关于Unicode和UTF-8(<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a>)</p>
</li>
<li><p>Reader和InputStream有什么关系？<br> 除了特殊的CharArrayReader和StringReader，普通的Reader实际上是基于InputStream构造的，因为Reader需要从InputStream中读入字节流（byte），然后，根据编码设置，再转换为char就可以实现字符流。如果我们查看FileReader的源码，它在内部实际上持有一个FileInputStream。</p>
<p> 既然Reader本质上是一个基于InputStream的byte到char的转换器，那么，如果我们已经有一个InputStream，想把它转换为Reader，是完全可行的。InputStreamReader就是这样一个转换器，它可以把任何InputStream转换为Reader。示例代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 持有InputStream:</span></span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 变换为Reader:</span></span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(input, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Standard-I-O"><a href="#Standard-I-O" class="headerlink" title="Standard I/O"></a>Standard I/O</h2><ol>
<li><p>PrintStream是一种FilterInputStream，在OutputStream的接口上，额外提供了一些写入各种数据类型的方法：<br> 写入int：print(int)<br> 写入boolean：print(boolean)<br> 写入String：print(String)<br> 写入Object：print(Object)，实际上相当于print(object.toString())</p>
<p> System.out是系统自带的一个PrintStream，用于标准输出</p>
</li>
<li><p>与System.out不同，System.in只是一个InputStream，所以如果要使用标准输入读入，我们还需要对System.in进行包装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader stdin = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">      <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">while</span>((s = stdin.readLine()) != <span class="keyword">null</span> &amp;&amp; s.length()!= <span class="number">0</span>)</span><br><span class="line">      System.out.println(s);</span><br><span class="line">    <span class="comment">// An empty line or Ctrl-Z terminates the program</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="New-I-O"><a href="#New-I-O" class="headerlink" title="New I/O"></a>New I/O</h2><p>JDK1.4介绍了<code>java.nio</code>包，它的目的是更快速的进行I/O读写。具体细节这里不赘述</p>
<h2 id="Object-Serialization"><a href="#Object-Serialization" class="headerlink" title="Object Serialization"></a>Object Serialization</h2><ol>
<li>序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。<br>为什么要把Java对象序列化呢？因为序列化后可以把<code>byte[]</code>保存到文件中，或者把<code>byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。<br>有序列化，就有反序列化，即把一个二进制内容(也就是<code>byte[]</code>数组)变回Java对象。有了反序列化，保存到文件中的<code>byte[]</code>数组又可以“变回”Java对象，或者从网络上读取<code>byte[]</code>并把它“变回”Java对象。</li>
<li>实现了Serilizable接口的类都可以进行Java序列化与反序列化，类似Serializable这样的空接口被称为”标记接口”(Marker Interface)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>序列化的本质就是将Java code转成字节码，反序列化的时候再转译回来，所以<strong>反序列化得到的对象不会调用构造函数</strong></li>
<li>由transient关键字声明的field不会被序列化，比如我们有一个password的field，我们并不想将其序列化并保存，这个时候可以将其声明为<code>private transient String password;</code></li>
<li>如果我们想要控制序列化与反序列化，比如调用构造函数，那么可以实现<code>Externalizable</code>接口</li>
<li><strong>Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON</strong></li>
</ol>
<h1 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h1><h2 id="Basic-enum-features"><a href="#Basic-enum-features" class="headerlink" title="Basic enum features"></a>Basic enum features</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shrubbery</span> </span>&#123; GROUND, CRAWLING, HANGING &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Shrubbery s : Shrubbery.values()) &#123;</span><br><span class="line">      print(s + <span class="string">&quot; ordinal: &quot;</span> + s.ordinal());</span><br><span class="line">      printnb(s.compareTo(Shrubbery.CRAWLING) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      printnb(s.equals(Shrubbery.CRAWLING) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      print(s == Shrubbery.CRAWLING);</span><br><span class="line">      print(s.getDeclaringClass());</span><br><span class="line">      print(s.name());</span><br><span class="line">      print(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Produce an enum value from a string name:</span></span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="string">&quot;HANGING CRAWLING GROUND&quot;</span>.split(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">      Shrubbery shrub = Enum.valueOf(Shrubbery.class, s);</span><br><span class="line">      print(shrub);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">GROUND ordinal: 0</span></span><br><span class="line"><span class="comment">-1 false false</span></span><br><span class="line"><span class="comment">class Shrubbery</span></span><br><span class="line"><span class="comment">GROUND</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"><span class="comment">CRAWLING ordinal: 1</span></span><br><span class="line"><span class="comment">0 true true</span></span><br><span class="line"><span class="comment">class Shrubbery</span></span><br><span class="line"><span class="comment">CRAWLING</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"><span class="comment">HANGING ordinal: 2</span></span><br><span class="line"><span class="comment">1 false false</span></span><br><span class="line"><span class="comment">class Shrubbery</span></span><br><span class="line"><span class="comment">HANGING</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"><span class="comment">HANGING</span></span><br><span class="line"><span class="comment">CRAWLING</span></span><br><span class="line"><span class="comment">GROUND</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>EnumClass.values()</code>返回一个枚举变量的数据，顺序为声明枚举的顺序</li>
<li><code>ordinal()</code>按照枚举的顺序从0开始返回int</li>
<li><code>name()</code>返回枚举的名字</li>
</ol>
<h2 id="Adding-methods-to-an-enum"><a href="#Adding-methods-to-an-enum" class="headerlink" title="Adding methods to an enum"></a>Adding methods to an enum</h2><ol>
<li>除了无法继承一个enum之外(因为enum被编译后会变成<code>Class Example extends Enum&lt;Example&gt;</code>，已经继承过，不能再继承了)，我们可以将enum当成普通的Java类</li>
<li>如果我们要为enum添加fields或者methods，那么enum的instances必须在类的开头声明，且最后需要加上<code>;</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">OzWitch</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Instances must be defined first, before methods:</span></span><br><span class="line">  WEST(<span class="string">&quot;Miss Gulch, aka the Wicked Witch of the West&quot;</span>),</span><br><span class="line">  NORTH(<span class="string">&quot;Glinda, the Good Witch of the North&quot;</span>),</span><br><span class="line">  EAST(<span class="string">&quot;Wicked Witch of the East, wearer of the Ruby &quot;</span> +</span><br><span class="line">    <span class="string">&quot;Slippers, crushed by Dorothy&#x27;s house&quot;</span>),</span><br><span class="line">  SOUTH(<span class="string">&quot;Good by inference, but missing&quot;</span>);</span><br><span class="line">  <span class="keyword">private</span> String description;</span><br><span class="line">  <span class="comment">// Constructor must be package or private access:</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">OzWitch</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.description = description;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> description; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(OzWitch witch : OzWitch.values())</span><br><span class="line">      print(witch + <span class="string">&quot;: &quot;</span> + witch.getDescription());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">WEST: Miss Gulch, aka the Wicked Witch of the West</span></span><br><span class="line"><span class="comment">NORTH: Glinda, the Good Witch of the North</span></span><br><span class="line"><span class="comment">EAST: Wicked Witch of the East, wearer of the Ruby Slippers, crushed by Dorothy&#x27;s house</span></span><br><span class="line"><span class="comment">SOUTH: Good by inference, but missing</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></li>
<li>Enum的方法也很普通类的方法一样可以override</li>
</ol>
<h2 id="The-mystery-of-values"><a href="#The-mystery-of-values" class="headerlink" title="The mystery of values()"></a>The mystery of values()</h2><ol>
<li>如果我们查看Enum的Java文档，会发现并没有values()这个方法，原因是<code>values()</code>是一个由编译器在编译期间加入的静态方法。编译器还会加入一个<code>valueOf()</code>方法(这个valueOf和Enum类自带的不一样，一个只有一个参数，一个有两个参数)</li>
<li>由于<code>values()</code>是在编译期间加入的，所以说如果我们直接使用Enum类，是无法使用<code>values()</code>的，这个时候可以使用反射<code>Enum en = OzWitch.WEST.getClass().getEnumConstants()</code></li>
</ol>
<h2 id="Implements-not-inherits"><a href="#Implements-not-inherits" class="headerlink" title="Implements, not inherits"></a>Implements, not inherits</h2><ol>
<li>Enum虽然不能继承父类，但是却可以实现接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> net.mindview.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CartoonCharacter</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">CartoonCharacter</span>&gt; </span>&#123;</span><br><span class="line">  SLAPPY, SPANKY, PUNCHY, SILLY, BOUNCY, NUTTY, BOB;</span><br><span class="line">  <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CartoonCharacter <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> values()[rand.nextInt(values().length)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumImplementation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printNext</span><span class="params">(Generator&lt;T&gt; rg)</span> </span>&#123;</span><br><span class="line">    System.out.print(rg.next() + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Choose any instance:</span></span><br><span class="line">    CartoonCharacter cc = CartoonCharacter.BOB;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      printNext(cc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">BOB, PUNCHY, BOB, SPANKY, NUTTY, PUNCHY, SLAPPY, NUTTY, NUTTY, SLAPPY,</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="EnumSet-and-EnumMap"><a href="#EnumSet-and-EnumMap" class="headerlink" title="EnumSet and EnumMap"></a>EnumSet and EnumMap</h2><p>使用Enum实现的Set和Map</p>
<h2 id="Constant-specfic-methods"><a href="#Constant-specfic-methods" class="headerlink" title="Constant-specfic methods"></a>Constant-specfic methods</h2><ol>
<li>Enum有一个特殊的功能，可以创建一个abstract method并且为每个Enum Instance进行不一样的实现 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ConstantSpecificMethod</span> </span>&#123;</span><br><span class="line">DATE_TIME &#123;</span><br><span class="line">	<span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">		DateFormat.getDateInstance().format(<span class="keyword">new</span> Date());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">CLASSPATH &#123;</span><br><span class="line">	<span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> System.getenv(<span class="string">&quot;CLASSPATH&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">VERSION &#123;</span><br><span class="line">	<span class="function">String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(ConstantSpecificMethod csm : values())</span><br><span class="line">	System.out.println(csm.getInfo());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这让每个Enum Instance看起来像是一个独立的类，但要记住：这只是一种特殊的用法，他们并不能被当成独立的类使用，ConstantSpecificMethod才是一个类</li>
</ol>
<h1 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h1><h2 id="Basic-syntax"><a href="#Basic-syntax" class="headerlink" title="Basic syntax"></a>Basic syntax</h2><h3 id="Defining-annotations"><a href="#Defining-annotations" class="headerlink" title="Defining annotations"></a>Defining annotations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> &quot;no description&quot;</span>;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>
<ol>
<li>注解的定义用@interface，我们使用元注解(例子中的@Target和@Retention)来声明注解的使用方法。@Target代表了我们的注解应该用在method还是field上；@Retention代表了注解存在于RUNTIME，SOURCE还是CLASS中。</li>
<li>注解中可以声明元素(elements，注解里我们不叫fields)，用来表明注解中拥有的值。这些元素在处理注解的时候会被用到。注解的元素和类的方法很相似，区别是元素没有大括号以及元素可以有默认值。</li>
</ol>
<h3 id="Meta-annotations"><a href="#Meta-annotations" class="headerlink" title="Meta-annotations"></a>Meta-annotations</h3><ol>
<li>@Target 注解能被用在什么地方：CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE(Class, interface or enum)</li>
<li>@Retention 注解信息会保存多久：SOURCE(Annotations are discarded by the compiler), CLASS(Annotations are available in the class file by the compiler but can be discarded by the JVM), RUNTIME(Annotations are retained by hte JVM at run time, os they may be read reflectively)</li>
<li>@Documented 把注解保存到javadocs</li>
</ol>
<h2 id="Writing-annotation-processors"><a href="#Writing-annotation-processors" class="headerlink" title="Writing annotation processors"></a>Writing annotation processors</h2><ol>
<li><strong>没有注解处理器，定义好的注解没有任何意义，编译器不会对其进行任何操作</strong></li>
<li>我们可以使用反射来处理注解： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseTracker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackUseCases</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Method m : cl.getDeclaredMethods()) &#123;</span><br><span class="line">      UseCase uc = m.getAnnotation(UseCase.class);</span><br><span class="line">      <span class="keyword">if</span>(uc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Found Use Case:&quot;</span> + uc.id() +</span><br><span class="line">          <span class="string">&quot; &quot;</span> + uc.description());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Annotation-elements"><a href="#Annotation-elements" class="headerlink" title="Annotation elements"></a>Annotation elements</h3><ol>
<li>注解元素允许的类型： All primitives, String, Class, Enums, Annotations, Arrays of any of the above。因此我们知道，注解元素不能使用封装类，但是可以使用nested annotation</li>
</ol>
<h3 id="Default-value-constrainsts"><a href="#Default-value-constrainsts" class="headerlink" title="Default value constrainsts"></a>Default value constrainsts</h3><ol>
<li>注解元素的默认值必须是确定的，所以对于空的String我们不能使用null，而应该使用<code>&quot;&quot;</code></li>
</ol>
<h3 id="Nested-annotation"><a href="#Nested-annotation" class="headerlink" title="Nested annotation"></a>Nested annotation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Constraints &#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">primaryKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">allowNull</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLString &#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">  <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果注解中定义了value元素，那么使用的时候可以不用写key-value pair，比如可以直接使用<code>@SQLString(30)</code>，那么编译器默认这里的30是赋给value元素的，其他元素的使用默认值</p>
</li>
<li><p>SQLString中的nested annotaion Constraints的默认值与@Constraints相同，我们也可以改变它的默认值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Uniqueness &#123;</span><br><span class="line">  <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @<span class="title">Constraints</span><span class="params">(unique=<span class="keyword">true</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如何使用nested annotation： <code>@SQLString(value = 30, constraints = @Constraints(primaryKey = true))</code></p>
</li>
<li><p>如何处理nested annotation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLStringTracker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackSQLString</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Field f : cl.getDeclaredFields()) &#123;</span><br><span class="line">      SQLString sqlString = f.getAnnotation(SQLString.class);</span><br><span class="line">      <span class="keyword">if</span>(sqlString != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Constraints con = sqlString.constraints();</span><br><span class="line">        System.out.println(<span class="string">&quot;Found sql string:&quot;</span> + sqlString.value() +</span><br><span class="line">          <span class="string">&quot; &quot;</span> + con.primaryKey());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Using-apt-to-process-annotations"><a href="#Using-apt-to-process-annotations" class="headerlink" title="Using apt to process annotations"></a>Using apt to process annotations</h2><p>除了使用反射(RUNTIME)处理annotations， 还有别的方式处理annotation，比如在SOURCE CODE<br>或者CLASS阶段进行处理</p>
<h1 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h1></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/28/Basics/Git%20Cherry%20Pick/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Git Cherry Pick</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/03/30/Backend/Spring/"><span class="level-item">Spring</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/Shiyu.jpg" alt="Shiyu Liu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Shiyu Liu</p><p class="is-size-6 is-block">Software Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Nashville</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">48</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">11</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ShiyuLiuColumbia" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ShiyuLiuColumbia"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Linkedin" href="https://www.linkedin.com/in/shiyu-liu-6623a3158/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:sl4401@columbia.edu"><i class="fas fa-envelope-open"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Initialization-amp-Clean-up"><span class="level-left"><span class="level-item">1</span><span class="level-item">Initialization &amp; Clean up</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Static-data-initialization"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Static data initialization</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Access-control"><span class="level-left"><span class="level-item">2</span><span class="level-item">Access control</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#public"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">public</span></span></a></li><li><a class="level is-mobile" href="#protected"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">protected</span></span></a></li><li><a class="level is-mobile" href="#package-default"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">package(default)</span></span></a></li><li><a class="level is-mobile" href="#private"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">private</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Reusing-Classes"><span class="level-left"><span class="level-item">3</span><span class="level-item">Reusing Classes</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Composition"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Composition</span></span></a></li><li><a class="level is-mobile" href="#Inheritance"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Inheritance</span></span></a></li><li><a class="level is-mobile" href="#The-Final-keyword"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">The Final keyword</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Final-data"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">Final data</span></span></a></li><li><a class="level is-mobile" href="#Final-arguments"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">Final arguments</span></span></a></li><li><a class="level is-mobile" href="#Final-methods"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">Final methods</span></span></a></li><li><a class="level is-mobile" href="#Final-and-Private"><span class="level-left"><span class="level-item">3.3.4</span><span class="level-item">Final and Private</span></span></a></li><li><a class="level is-mobile" href="#Final-classes"><span class="level-left"><span class="level-item">3.3.5</span><span class="level-item">Final classes</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Polymorphism-dynamic-binding-late-binding-run-time-binding"><span class="level-left"><span class="level-item">4</span><span class="level-item">Polymorphism(dynamic binding/late binding/run-time binding)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Method-call-binding"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">Method-call binding</span></span></a></li><li><a class="level is-mobile" href="#几个不支持多态-dynamic-binding-的例子"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">几个不支持多态(dynamic binding)的例子</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Interface"><span class="level-left"><span class="level-item">5</span><span class="level-item">Interface</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Abstract-classes-and-methods"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">Abstract classes and methods</span></span></a></li><li><a class="level is-mobile" href="#Interfaces"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">Interfaces</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Inner-class"><span class="level-left"><span class="level-item">6</span><span class="level-item">Inner class</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Inner-class-and-upcasting"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Inner class and upcasting</span></span></a></li><li><a class="level is-mobile" href="#Anonymous-Inner-class"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Anonymous Inner class</span></span></a></li><li><a class="level is-mobile" href="#Nested-Class"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">Nested Class</span></span></a></li><li><a class="level is-mobile" href="#Classes-inside-interface"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">Classes inside interface</span></span></a></li><li><a class="level is-mobile" href="#Why-inner-classes"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">Why inner classes?</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Holding-your-object"><span class="level-left"><span class="level-item">7</span><span class="level-item">Holding your object</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Collection"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">Collection</span></span></a></li><li><a class="level is-mobile" href="#Iterator"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">Iterator</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Error-Handling-with-Exceptions"><span class="level-left"><span class="level-item">8</span><span class="level-item">Error Handling with Exceptions</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Basic-exceptions"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">Basic exceptions</span></span></a></li><li><a class="level is-mobile" href="#Catch-an-exception"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">Catch an exception</span></span></a></li><li><a class="level is-mobile" href="#Creating-your-own-exceptions"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">Creating your own exceptions</span></span></a></li><li><a class="level is-mobile" href="#Catching-any-exception"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">Catching any exception</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Performing-cleanup-with-finally"><span class="level-left"><span class="level-item">8.4.1</span><span class="level-item">Performing cleanup with finally</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Exception-restrictions"><span class="level-left"><span class="level-item">8.5</span><span class="level-item">Exception restrictions</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Exception-matching"><span class="level-left"><span class="level-item">8.5.1</span><span class="level-item">Exception matching</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Strings"><span class="level-left"><span class="level-item">9</span><span class="level-item">Strings</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Immutable-Strings"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">Immutable Strings</span></span></a></li><li><a class="level is-mobile" href="#Overloading-‘-’-vs-StringBuilder"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">Overloading ‘+’ vs. StringBuilder</span></span></a></li><li><a class="level is-mobile" href="#Formatting-output"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">Formatting output</span></span></a></li><li><a class="level is-mobile" href="#Regular-expressions"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">Regular expressions</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Type-Information"><span class="level-left"><span class="level-item">10</span><span class="level-item">Type Information</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#The-Class-object"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">The Class object</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Class-literals"><span class="level-left"><span class="level-item">10.1.1</span><span class="level-item">Class literals</span></span></a></li><li><a class="level is-mobile" href="#Generic-class-references"><span class="level-left"><span class="level-item">10.1.2</span><span class="level-item">Generic class references</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Checking-before-a-cast"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">Checking before a cast</span></span></a></li><li><a class="level is-mobile" href="#Rgistered-factories"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">Rgistered factories</span></span></a></li><li><a class="level is-mobile" href="#instanceof-vs-Class-equicalence"><span class="level-left"><span class="level-item">10.4</span><span class="level-item">instanceof vs. Class equicalence</span></span></a></li><li><a class="level is-mobile" href="#Reflection-runtime-class-information"><span class="level-left"><span class="level-item">10.5</span><span class="level-item">Reflection: runtime class information</span></span></a></li><li><a class="level is-mobile" href="#Dynamic-proxies"><span class="level-left"><span class="level-item">10.6</span><span class="level-item">Dynamic proxies</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Generics"><span class="level-left"><span class="level-item">11</span><span class="level-item">Generics</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Simple-Generics-Generic-Types"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">Simple Generics(Generic Types)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Raw-Type"><span class="level-left"><span class="level-item">11.1.1</span><span class="level-item">Raw Type</span></span></a></li><li><a class="level is-mobile" href="#Unchecked-Error-Messages"><span class="level-left"><span class="level-item">11.1.2</span><span class="level-item">Unchecked Error Messages</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Generic-methods"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">Generic methods</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Type-Inference"><span class="level-left"><span class="level-item">11.2.1</span><span class="level-item">Type Inference</span></span></a></li><li><a class="level is-mobile" href="#Explicit-type-specification"><span class="level-left"><span class="level-item">11.2.2</span><span class="level-item">Explicit type specification</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Generics-Inheritance-and-Subtypes"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">Generics, Inheritance, and Subtypes</span></span></a></li><li><a class="level is-mobile" href="#The-mystery-of-erasure"><span class="level-left"><span class="level-item">11.4</span><span class="level-item">The mystery of erasure</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#先检查，再编译"><span class="level-left"><span class="level-item">11.4.1</span><span class="level-item">先检查，再编译</span></span></a></li><li><a class="level is-mobile" href="#自动类型转换"><span class="level-left"><span class="level-item">11.4.2</span><span class="level-item">自动类型转换</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Compensating-for-erasure"><span class="level-left"><span class="level-item">11.5</span><span class="level-item">Compensating for erasure</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Creating-instances-of-types"><span class="level-left"><span class="level-item">11.5.1</span><span class="level-item">Creating instances of types</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Wildcards"><span class="level-left"><span class="level-item">11.6</span><span class="level-item">Wildcards</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Upper-Bounded-Wildcards"><span class="level-left"><span class="level-item">11.6.1</span><span class="level-item">Upper Bounded Wildcards</span></span></a></li><li><a class="level is-mobile" href="#Lower-Bounded-Wildcards"><span class="level-left"><span class="level-item">11.6.2</span><span class="level-item">Lower Bounded Wildcards</span></span></a></li><li><a class="level is-mobile" href="#Unbounded-Wildcards"><span class="level-left"><span class="level-item">11.6.3</span><span class="level-item">Unbounded Wildcards</span></span></a></li><li><a class="level is-mobile" href="#Wildcards-and-Subtyping"><span class="level-left"><span class="level-item">11.6.4</span><span class="level-item">Wildcards and Subtyping</span></span></a></li><li><a class="level is-mobile" href="#Java泛型通配符-与-T-的区别"><span class="level-left"><span class="level-item">11.6.5</span><span class="level-item">Java泛型通配符 ? 与 T 的区别</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Self-bounded-types"><span class="level-left"><span class="level-item">11.7</span><span class="level-item">Self-bounded types</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#泛型类的自限定"><span class="level-left"><span class="level-item">11.7.1</span><span class="level-item">泛型类的自限定</span></span></a></li><li><a class="level is-mobile" href="#泛型声明的完全自限定"><span class="level-left"><span class="level-item">11.7.2</span><span class="level-item">泛型声明的完全自限定</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#I-O"><span class="level-left"><span class="level-item">12</span><span class="level-item">I/O</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#The-File-class"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">The File class</span></span></a></li><li><a class="level is-mobile" href="#InputStream-OutputStream"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">InputStream/OutputStream</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#InputStream"><span class="level-left"><span class="level-item">12.2.1</span><span class="level-item">InputStream</span></span></a></li><li><a class="level is-mobile" href="#FilterInputStream"><span class="level-left"><span class="level-item">12.2.2</span><span class="level-item">FilterInputStream</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Reader-Writer"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">Reader/Writer</span></span></a></li><li><a class="level is-mobile" href="#Standard-I-O"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">Standard I/O</span></span></a></li><li><a class="level is-mobile" href="#New-I-O"><span class="level-left"><span class="level-item">12.5</span><span class="level-item">New I/O</span></span></a></li><li><a class="level is-mobile" href="#Object-Serialization"><span class="level-left"><span class="level-item">12.6</span><span class="level-item">Object Serialization</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Enum"><span class="level-left"><span class="level-item">13</span><span class="level-item">Enum</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Basic-enum-features"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">Basic enum features</span></span></a></li><li><a class="level is-mobile" href="#Adding-methods-to-an-enum"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">Adding methods to an enum</span></span></a></li><li><a class="level is-mobile" href="#The-mystery-of-values"><span class="level-left"><span class="level-item">13.3</span><span class="level-item">The mystery of values()</span></span></a></li><li><a class="level is-mobile" href="#Implements-not-inherits"><span class="level-left"><span class="level-item">13.4</span><span class="level-item">Implements, not inherits</span></span></a></li><li><a class="level is-mobile" href="#EnumSet-and-EnumMap"><span class="level-left"><span class="level-item">13.5</span><span class="level-item">EnumSet and EnumMap</span></span></a></li><li><a class="level is-mobile" href="#Constant-specfic-methods"><span class="level-left"><span class="level-item">13.6</span><span class="level-item">Constant-specfic methods</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Annotation"><span class="level-left"><span class="level-item">14</span><span class="level-item">Annotation</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Basic-syntax"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">Basic syntax</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Defining-annotations"><span class="level-left"><span class="level-item">14.1.1</span><span class="level-item">Defining annotations</span></span></a></li><li><a class="level is-mobile" href="#Meta-annotations"><span class="level-left"><span class="level-item">14.1.2</span><span class="level-item">Meta-annotations</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Writing-annotation-processors"><span class="level-left"><span class="level-item">14.2</span><span class="level-item">Writing annotation processors</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Annotation-elements"><span class="level-left"><span class="level-item">14.2.1</span><span class="level-item">Annotation elements</span></span></a></li><li><a class="level is-mobile" href="#Default-value-constrainsts"><span class="level-left"><span class="level-item">14.2.2</span><span class="level-item">Default value constrainsts</span></span></a></li><li><a class="level is-mobile" href="#Nested-annotation"><span class="level-left"><span class="level-item">14.2.3</span><span class="level-item">Nested annotation</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Using-apt-to-process-annotations"><span class="level-left"><span class="level-item">14.3</span><span class="level-item">Using apt to process annotations</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Concurrency"><span class="level-left"><span class="level-item">15</span><span class="level-item">Concurrency</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Shiyu - Blog</a><p class="is-size-7"><span>&copy; 2021 Shiyu Liu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>