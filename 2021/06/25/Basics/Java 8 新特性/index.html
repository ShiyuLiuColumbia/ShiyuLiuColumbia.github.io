<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java 8 新特性 - Shiyu - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Shiyu - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Shiyu - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Lambda expressionsDefault Methods for Interfaces Java 8允许我们在接口中定义non-abstract method，这在Java 8之前是不被允许的。定义的方法是使用default关键词： 1234567interface Formula &amp;amp;#123;    double calculate(int a);    default double"><meta property="og:type" content="blog"><meta property="og:title" content="Java 8 新特性"><meta property="og:url" content="https://shiyuliucolumbia.github.io/2021/06/25/Basics/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"><meta property="og:site_name" content="Shiyu - Blog"><meta property="og:description" content="Lambda expressionsDefault Methods for Interfaces Java 8允许我们在接口中定义non-abstract method，这在Java 8之前是不被允许的。定义的方法是使用default关键词： 1234567interface Formula &amp;amp;#123;    double calculate(int a);    default double"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://shiyuliucolumbia.github.io/img/og_image.png"><meta property="article:published_time" content="2021-06-25T17:40:19.000Z"><meta property="article:modified_time" content="2021-11-12T15:14:27.487Z"><meta property="article:author" content="Shiyu Liu"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://shiyuliucolumbia.github.io/2021/06/25/Basics/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"},"headline":"Java 8 新特性","image":["https://shiyuliucolumbia.github.io/img/og_image.png"],"datePublished":"2021-06-25T17:40:19.000Z","dateModified":"2021-11-12T15:14:27.487Z","author":{"@type":"Person","name":"Shiyu Liu"},"publisher":{"@type":"Organization","name":"Shiyu - Blog","logo":{"@type":"ImageObject","url":{"text":"Shiyu - Blog"}}},"description":"Lambda expressionsDefault Methods for Interfaces Java 8允许我们在接口中定义non-abstract method，这在Java 8之前是不被允许的。定义的方法是使用default关键词： 1234567interface Formula &amp;#123;    double calculate(int a);    default double"}</script><link rel="canonical" href="https://shiyuliucolumbia.github.io/2021/06/25/Basics/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Shiyu - Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-06-25T17:40:19.000Z" title="6/25/2021, 12:40:19 PM">2021-06-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-12T15:14:27.487Z" title="11/12/2021, 9:14:27 AM">2021-11-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">31 minutes read (About 4652 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">Java 8 新特性</h1><div class="content"><h1 id="Lambda-expressions"><a href="#Lambda-expressions" class="headerlink" title="Lambda expressions"></a>Lambda expressions</h1><h2 id="Default-Methods-for-Interfaces"><a href="#Default-Methods-for-Interfaces" class="headerlink" title="Default Methods for Interfaces"></a>Default Methods for Interfaces</h2><ol>
<li><p>Java 8允许我们在接口中定义non-abstract method，这在Java 8之前是不被允许的。定义的方法是使用default关键词：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>我们可以使用deault关键词定义的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里我们使用了匿名内部类。匿名内部类的一个很大的好处就是：接口是不能实例化的，如果要实例化，我们需要先定义实现这个接口的类。但很多时候，我们其实是不关心实现接口的类是怎样的，而只关心接口的方法是如何重写(override)的。匿名内部类就可以帮助我们达到目的。</p>
<span id="more"></span>

<h2 id="Lambda-expressions-1"><a href="#Lambda-expressions-1" class="headerlink" title="Lambda expressions"></a>Lambda expressions</h2><ol>
<li>匿名内部类已经简化了我们对于接口的使用，但是大家还是觉得麻烦，我们其实只是想使用一下接口里的某个方法，为什么要定义这么多东西，于是Lambda表达式诞生了。对于一个复杂的匿名内部类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;peter&quot;</span>, <span class="string">&quot;anna&quot;</span>, <span class="string">&quot;mike&quot;</span>, <span class="string">&quot;xenia&quot;</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
我们使用Lambda表达式可以简化成如下，即我们省略了类名以及重写对的方法名。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
如果Lambda表达式重写的方法只有一行，我们可以省略<code>&#123;&#125;</code>和<code>return</code>；同时函数参数的类型也可以由编译器自行判断。所以最终简化为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Functional-Interfaces"><a href="#Functional-Interfaces" class="headerlink" title="Functional Interfaces"></a>Functional Interfaces</h2><ol>
<li>从上面的例子我们可以看出lambda表达式的巨大作用，但这个时候我们有一个疑问：接口中可能有多个方法，Java编译器是怎么知道我们重写的是哪个方法呢？ 答案是Java编译器并没有那么聪明，我们只能在函数式接口上使用Lambda表达式。</li>
<li>函数式接口：接口的定义中有且只有一个抽象方法，我们把这样的接口叫做函数式接口。这里我们就可以理解为什么Java 8中要为接口引入default方法，原因就是default方法不算抽象方法，函数式接口中可以有多个default方法。这个时候我们可能还有疑问：Comparator接口有两个抽象方法：<code>int compare(T o1, T o2);</code>和<code>boolean equals(Object obj);</code>，为什么还是函数式接口呢？原因是<code>boolean equals(Object obj);</code>是Object自带的方法，并不算抽象方法(FunctionalInterface的定义中提到：If an interface declares an abstract method overriding one of the public methods of java.lang.Object, that also does not count toward the interface’s abstract method count since any implementation of the interface will have an implementation from java.lang.Object or elsewhere)。<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/23721759/functionalinterface-comparator-has-2-abstract-methods">https://stackoverflow.com/questions/23721759/functionalinterface-comparator-has-2-abstract-methods</a>. </li>
<li>所有的函数式接口可以使用Lambda表达式，因为它只有一个抽象方法，所以编译器可以知道要重写的就是这个方法。</li>
<li>Java提供一个<code>@FunctionalInterface</code>的注解，当我们想要定义一个函数式接口的时候，我们可以加上这个注解，那么编译器会帮助我们判断哦我们写的接口符不符合只有一个抽象方法的标准，不符合的话会报错。所以<code>@FunctionalInterface</code>注解和<code>Override</code>注解有着类似的作用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Method-and-Constructor-References"><a href="#Method-and-Constructor-References" class="headerlink" title="Method and Constructor References"></a>Method and Constructor References</h2><ol>
<li>Java 8还新引入了方法引用，使用方法引用，我们可以进一步简化Lambda表达式。方法引用的原理就是引用的方法的参数与返回值与所需要方法的参数与返回值完全相同。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(converted);   <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
这个例子中需要的override的方法是<code>Integer convert(String from)</code>，这与<code>Integer valueOf(String input)</code>是完全一致的，所以这里我们可以使用方法引用</li>
<li>四种方法引用<br>Kind                                                    Syntax                                            Examples<br>Reference to a static method                            ContainingClass::staticMethodName                Person::compareByAge; MethodReferencesExamples::appendStrings<br>Reference to an instance method of a particular object    containingObject::instanceMethodName            myComparisonProvider::compareByName;myApp::appendStrings2<br>Reference to an instance method of an arbitrary object of a particular type    ContainingType::methodName    String::compareToIgnoreCase;<br>String::concat<br>Reference to a constructor                                                    ClassName::new                HashSet::new</li>
</ol>
<p>方法引用的三条规则：<br>成员方法的方法签名，前面会追加 this 的类型。<br>静态方法的方法签名，因为没有 this, 不会追加任何东西。<br>当 :: 前是一个实例时，这个实例会作为第一个参数给绑定到目标方法签名上。</p>
<p>第二条规则很好理解，<code>Integer.valueOf()</code>就是一个很好的例子，下面分别解释第一条与第三条规则。</p>
<p>第一条规则：一个类中的方法正常来说我们是不能直接使用的，除非它是一个静态方法，但是对于lambda方法引用来说，它是可以使用的。同时会在方法的参数列表最前面增加一个this的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String[] s = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">    Arrays.sort(s, String::compareTo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>Arrays.sort</code>的第二个参数应该是一个实现了<code>int compare(String a, String b)</code>的comparator，我们查看String的compareTo方法<code>int    compareTo(String anotherString)</code>发现参数并不相符。这里可以使用方法引用的原因就符合第一条规则，这里String的compareTo方法的签名其实是<code>int    compareTo(String this, String anotherString)</code>。我们发现与compare方法是相符的。</p>
<p>第三条规则：对于第三条规则，我们可以按照第一条规则继续理解。String的compareTo方法的签名其实是<code>int compareTo(String this, String anotherString)</code>，但由于这里我们<code>::</code>前面是一个对象，而不是类名，所以<code>String this</code>会被这个对象所代替，这个时候<code>String this</code>就不能算做方法的参数了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; test = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        test.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        test.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        test.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        String fake = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        test.stream().map(fake::compareTo).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map的参数是一个实现了<code>R    apply(T t)</code>的Function，明显不符合<code>int compareTo(String this, String anotherString)</code>的参数。但是由于我们这里的fake变量是一个对象，所以方法签名其实是<code>int compareTo(fake, String anotherString)</code>，本质上只有一个参数，符合<code>R    apply(T t)</code>的参数，所以可以使用。</p>
<p>因此，我们也就理解了为什么<code>System.out::println</code>可以用在<code>void forEach(Consumer&lt;? super T&gt; action)</code>，但是<code>PrintStream::println</code>不可以：<br>Consumer需要override的方法是<code>void accept(T t)</code>，而<code>PrintStream::println</code>的方法参数是<code>void println(printStream this, int t)</code>，明显不符合。而<code>System.out</code>是PrintStream的一个静态对象，符合第三条规则，所以可以被forEach使用</p>
<ol start="3">
<li>构造器的方法引用例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>
Java编译器自动根据<code>PersonFactory.create</code>的参数类型选择合适的构造器</li>
</ol>
<h2 id="Lambda-Scopes"><a href="#Lambda-Scopes" class="headerlink" title="Lambda Scopes"></a>Lambda Scopes</h2><p><a target="_blank" rel="noopener" href="https://github.com/winterbe/java8-tutorial#lambda-scopes">https://github.com/winterbe/java8-tutorial#lambda-scopes</a></p>
<h2 id="Built-in-Functional-Interfaces"><a href="#Built-in-Functional-Interfaces" class="headerlink" title="Built-in Functional Interfaces"></a>Built-in Functional Interfaces</h2><p>Java 8有很多定义好的函数式接口，在后面的Stream介绍中，他们会被广泛的使用。</p>
<h3 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a>Predicates</h3><p>Predicates are boolean-valued functions of one argument. The interface contains various default methods for composing predicates to complex logical terms (and, or, negate)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">&quot;foo&quot;</span>);              <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">&quot;foo&quot;</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Functions accept one argument and produce a result. Default methods can be used to chain multiple functions together (compose, andThen).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line"></span><br><span class="line">backToString.apply(<span class="string">&quot;123&quot;</span>);     <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="Suppliers"><a href="#Suppliers" class="headerlink" title="Suppliers"></a>Suppliers</h3><p>Suppliers produce a result of a given generic type. Unlike Functions, Suppliers don’t accept arguments.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure>
<h3 id="Consumers"><a href="#Consumers" class="headerlink" title="Consumers"></a>Consumers</h3><p>Consumers represent operations to be performed on a single input argument.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">&quot;Hello, &quot;</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">&quot;Luke&quot;</span>, <span class="string">&quot;Skywalker&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="Comparators"><a href="#Comparators" class="headerlink" title="Comparators"></a>Comparators</h3><p>Comparators are well known from older versions of Java. Java 8 adds various default methods to the interface.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Wonderland&quot;</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure>


<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h2 id="stream解析"><a href="#stream解析" class="headerlink" title="stream解析"></a>stream解析</h2><p>举map为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stream</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseStream</span>&lt;<span class="title">T</span>, <span class="title">Stream</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到map的参数是一个函数式接口<code>Function</code>，有意思的是这个函数式接口的泛型分别是<code>? super T</code>和<code>? extends R</code>，那么它们代表了什么呢？<br>首先我们需要明白的一点是：这个例子中的<code>T</code>与<code>R</code>是泛型的形参；<code>?</code>是泛型的实参。<code>T</code>和<code>R</code>在使用stream的时候会被实例化，比如我们<code>T</code>被<code>String</code>实例化, <code>R</code>被<code>Integer</code>实例化，这个时候我们就能清晰的理解了：map的输入是一个<code>Function</code>，<code>Function</code>的第一个泛型参数是String或String的父类(到底是什么在定义的时候还不知道，所以用?代替)，Function的第二个泛型参数是Integer或Integer的子类(到底是什么在定义的时候还不知道，所以用?代替)。<strong>我们要搞清楚，这里我么是在使用Function而不是定义Function，所以使用的是实参<code>?</code>，不能因为看到T和R就混淆，这里的T和R是Stream类的形参。</strong><br>再根据PECS原则：Producer Extends Consumer Super，进一步深入理解：<code>Function</code>的<code>V apply(P p)</code>方法会使用第一个泛型参数，并返回第二个泛型参数，所以第一个参数确实应该定义成producer，第二个确实应该定义成consumer。</p>
<h2 id="加强版类型推断-Target-Type"><a href="#加强版类型推断-Target-Type" class="headerlink" title="加强版类型推断(Target Type)"></a>加强版类型推断(Target Type)</h2><p>在泛型部分我们介绍了类型推断，也就是方法泛型不需要声明泛型的类别，Java会自动根据方法的参数判断，但是在stream中，只根据方法的参数判断是不够的，加强版类型推断还可以根据返回值判断泛型的类别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; test = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        test.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        test.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        test.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        String fake = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        test.stream().map(fake::compareTo).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中map需要一个实现了<code>R apply(T t)</code>的Function，T我们根据stream可以推断出是类型是String，但是R并不能由参数推断出来，而是由返回值推断出来是Integer</p>
<p>下面的内容来自官方教程： <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a></p>
<h3 id="Target-Typing"><a href="#Target-Typing" class="headerlink" title="Target Typing"></a>Target Typing</h3><p>How do you determine the type of a lambda expression? Recall the lambda expression that selected members who are male and between the ages 18 and 25 years:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">    &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">    &amp;&amp; p.getAge() &lt;= <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>This lambda expression was used in the following two methods:</p>
<p><code>public static void printPersons(List&lt;Person&gt; roster, CheckPerson tester)</code> in Approach 3: Specify Search Criteria Code in a Local Class</p>
<p><code>public void printPersonsWithPredicate(List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester)</code> in Approach 6: Use Standard Functional Interfaces with Lambda Expressions</p>
<p>When the Java runtime invokes the method printPersons, it’s expecting a data type of CheckPerson, so the lambda expression is of this type. However, when the Java runtime invokes the method printPersonsWithPredicate, it’s expecting a data type of Predicate<Person>, so the lambda expression is of this type. The data type that these methods expect is called the target type. To determine the type of a lambda expression, the Java compiler uses the target type of the context or situation in which the lambda expression was found. It follows that you can only use lambda expressions in situations in which the Java compiler can determine a target type:</p>
<p>Variable declarations<br>Assignments<br>Return statements<br>Array initializers<br>Method or constructor arguments<br>Lambda expression bodies<br>Conditional expressions, ?:<br>Cast expressions</p>
<h4 id="Target-Types-and-Method-Arguments"><a href="#Target-Types-and-Method-Arguments" class="headerlink" title="Target Types and Method Arguments"></a>Target Types and Method Arguments</h4><p>For method arguments, the Java compiler determines the target type with two other language features: overload resolution and type argument inference.</p>
<p>Consider the following two functional interfaces ( java.lang.Runnable and java.util.concurrent.Callable<V>):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The method Runnable.run does not return a value, whereas Callable<V>.call does.</p>
<p>Suppose that you have overloaded the method invoke as follows (see Defining Methods for more information about overloading methods):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">invoke</span><span class="params">(Callable&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Which method will be invoked in the following statement?</p>
<p><code>String s = invoke(() -&gt; &quot;done&quot;);</code><br>The method invoke(Callable<T>) will be invoked because that method returns a value; the method invoke(Runnable) does not. In this case, the type of the lambda expression <code>() -&gt; &quot;done&quot;</code> is Callable<T>.</p>
<h2 id="stream-functions"><a href="#stream-functions" class="headerlink" title="stream functions"></a>stream functions</h2><p>stream的函数定义查看Java官方文档</p>
<h2 id="How-streams-work"><a href="#How-streams-work" class="headerlink" title="How streams work"></a>How streams work</h2><ol>
<li><p>A stream represents a sequence of elements and supports different kind of operations to perform computations upon those elements:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; myList =</span><br><span class="line">    Arrays.asList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;c2&quot;</span>, <span class="string">&quot;c1&quot;</span>);</span><br><span class="line">myList</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">&quot;c&quot;</span>))</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// C1</span></span><br><span class="line"><span class="comment">// C2</span></span><br></pre></td></tr></table></figure>
<p>Stream operations are either intermediate or terminal. Intermediate operations return a stream so we can chain multiple intermediate operations without using semicolons. Terminal operations are either void or return a non-stream result. In the above example filter, map and sorted are intermediate operations whereas forEach is a terminal operation.</p>
</li>
<li><p>Most stream operations accept some kind of lambda expression parameter, a functional interface specifying the exact behavior of the operation. Most of those operations must be both non-interfering and stateless. What does that mean?</p>
</li>
</ol>
<p>A function is non-interfering when it does not modify the underlying data source of the stream, e.g. in the above example no lambda expression does modify myList by adding or removing elements from the collection.</p>
<p>A function is stateless when the execution of the operation is deterministic, e.g. in the above example no lambda expression depends on any mutable variables or states from the outer scope which might change during execution.</p>
<h2 id="Different-kind-of-streams"><a href="#Different-kind-of-streams" class="headerlink" title="Different kind of streams"></a>Different kind of streams</h2><ol>
<li><p>Streams can be created from various data sources, especially collections. Lists and Sets support new methods <code>stream()</code> and <code>parallelStream()</code> to either create a sequential or a parallel stream. Parallel streams are capable of operating on multiple threads and will be covered in a later section of this tutorial. We focus on sequential streams for now:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// a1</span></span><br></pre></td></tr></table></figure></li>
<li><p>Calling the method stream() on a list of objects returns a regular object stream. But we don’t have to create collections in order to work with streams as we see in the next code sample:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>)</span><br><span class="line">    .findFirst()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// a1</span></span><br></pre></td></tr></table></figure>
<p>Just use Stream.of() to create a stream from a bunch of object references.</p>
</li>
<li><p>Besides regular object streams Java 8 ships with special kinds of streams for working with the primitive data types int, long and double. As you might have guessed it’s IntStream, LongStream and DoubleStream.<br>IntStreams can replace the regular for-loop utilizing IntStream.range():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>All those primitive streams work just like regular object streams with the following differences: Primitive streams use specialized lambda expressions, e.g. IntFunction instead of Function or IntPredicate instead of Predicate. And primitive streams support the additional terminal aggregate operations sum() and average():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">    .map(n -&gt; <span class="number">2</span> * n + <span class="number">1</span>)</span><br><span class="line">    .average()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// 5.0</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Sometimes it’s useful to transform a regular object stream to a primitive stream or vice versa.</strong> For that purpose object streams support the special mapping operations mapToInt(), mapToLong() and mapToDouble:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>)</span><br><span class="line">    .map(s -&gt; s.substring(<span class="number">1</span>))</span><br><span class="line">    .mapToInt(Integer::parseInt)</span><br><span class="line">    .max()</span><br><span class="line">    .ifPresent(System.out::println);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>Primitive streams can be transformed to object streams via mapToObj():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">    .mapToObj(i -&gt; <span class="string">&quot;a&quot;</span> + i)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a1</span></span><br><span class="line"><span class="comment">// a2</span></span><br><span class="line"><span class="comment">// a3</span></span><br></pre></td></tr></table></figure>
<p>Here’s a combined example: the stream of doubles is first mapped to an int stream and than mapped to an object stream of strings:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">    .mapToInt(Double::intValue)</span><br><span class="line">    .mapToObj(i -&gt; <span class="string">&quot;a&quot;</span> + i)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a1</span></span><br><span class="line"><span class="comment">// a2</span></span><br><span class="line"><span class="comment">// a3</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Processing-Order"><a href="#Processing-Order" class="headerlink" title="Processing Order"></a>Processing Order</h2><ol>
<li>Now that we’ve learned how to create and work with different kinds of streams, let’s dive deeper into how stream operations are processed under the hood.</li>
</ol>
<p><strong>An important characteristic of intermediate operations is laziness</strong>. Look at this sample where a terminal operation is missing:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>When executing this code snippet, nothing is printed to the console. <strong>That is because intermediate operations will only be executed when a terminal operation is present.</strong></p>
<p>Let’s extend the above example by the terminal operation forEach:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;filter: &quot; + s);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));</span><br></pre></td></tr></table></figure>
<p>Executing this code snippet results in the desired output on the console:<br>filter:  d2<br>forEach: d2<br>filter:  a2<br>forEach: a2<br>filter:  b1<br>forEach: b1<br>filter:  b3<br>forEach: b3<br>filter:  c<br>forEach: c</p>
<p>The order of the result might be surprising. A naive approach would be to execute the operations horizontally one after another on all elements of the stream. But instead each element moves along the chain vertically. The first string “d2” passes filter then forEach, only then the second string “a2” is processed.</p>
<p>This behavior can reduce the actual number of operations performed on each element, as we see in the next example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .anyMatch(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;anyMatch: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>// map:      d2<br>// anyMatch: D2<br>// map:      a2<br>// anyMatch: A2</p>
<p>The operation anyMatch returns true as soon as the predicate applies to the given input element. This is true for the second element passed “A2”. Due to the vertical execution of the stream chain, map has only to be executed twice in this case. So instead of mapping all elements of the stream, map will be called as few as possible.</p>
<h3 id="Why-order-matters"><a href="#Why-order-matters" class="headerlink" title="Why order matters"></a>Why order matters</h3><p>The next example consists of two intermediate operations map and filter and the terminal operation forEach. Let’s once again inspect how those operations are being executed:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// map:     d2</span></span><br><span class="line"><span class="comment">// filter:  D2</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// filter:  A2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br><span class="line"><span class="comment">// map:     b1</span></span><br><span class="line"><span class="comment">// filter:  B1</span></span><br><span class="line"><span class="comment">// map:     b3</span></span><br><span class="line"><span class="comment">// filter:  B3</span></span><br><span class="line"><span class="comment">// map:     c</span></span><br><span class="line"><span class="comment">// filter:  C</span></span><br></pre></td></tr></table></figure>
<p>As you might have guessed both map and filter are called five times for every string in the underlying collection whereas forEach is only called once.</p>
<p>We can greatly reduce the actual number of executions if we change the order of the operations, moving filter to the beginning of the chain:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter:  d2</span></span><br><span class="line"><span class="comment">// filter:  a2</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br><span class="line"><span class="comment">// filter:  b1</span></span><br><span class="line"><span class="comment">// filter:  b3</span></span><br><span class="line"><span class="comment">// filter:  c</span></span><br></pre></td></tr></table></figure>
<p>Now, map is only called once so the operation pipeline performs much faster for larger numbers of input elements. Keep that in mind when composing complex method chains.</p>
<p>Let’s extend the above example by an additional operation, sorted:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;sort: %s; %s\n&quot;</span>, s1, s2);</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br></pre></td></tr></table></figure>
<p>Sorting is a special kind of intermediate operation. It’s a so called stateful operation since in order to sort a collection of elements you have to maintain state during ordering.</p>
<p>Executing this example results in the following console output:<br>sort:    a2; d2<br>sort:    b1; a2<br>sort:    b1; d2<br>sort:    b1; a2<br>sort:    b3; b1<br>sort:    b3; d2<br>sort:    c; b3<br>sort:    c; d2<br>filter:  a2<br>map:     a2<br>forEach: A2<br>filter:  b1<br>filter:  b3<br>filter:  c<br>filter:  d2<br>First, the sort operation is executed on the entire input collection. In other words sorted is executed horizontally. So in this case sorted is called eight times for multiple combinations on every element in the input collection.</p>
<p>Once again we can optimize the performance by reordering the chain:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .sorted((s1, s2) -&gt; &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;sort: %s; %s\n&quot;</span>, s1, s2);</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter:  d2</span></span><br><span class="line"><span class="comment">// filter:  a2</span></span><br><span class="line"><span class="comment">// filter:  b1</span></span><br><span class="line"><span class="comment">// filter:  b3</span></span><br><span class="line"><span class="comment">// filter:  c</span></span><br><span class="line"><span class="comment">// map:     a2</span></span><br><span class="line"><span class="comment">// forEach: A2</span></span><br></pre></td></tr></table></figure>
<p>In this example sorted is never been called because filter reduces the input collection to just one element. So the performance is greatly increased for larger input collections.</p>
<h2 id="Reusing-Streams"><a href="#Reusing-Streams" class="headerlink" title="Reusing Streams"></a>Reusing Streams</h2><p>Java 8 streams cannot be reused. As soon as you call any terminal operation the stream is closed:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream =</span><br><span class="line">    Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">        .filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">stream.anyMatch(s -&gt; <span class="keyword">true</span>);    <span class="comment">// ok</span></span><br><span class="line">stream.noneMatch(s -&gt; <span class="keyword">true</span>);   <span class="comment">// exception</span></span><br></pre></td></tr></table></figure>
<p>Calling noneMatch after anyMatch on the same stream results in the following exception:</p>
<p>java.lang.IllegalStateException: stream has already been operated upon or closed<br>    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)<br>    at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459)<br>    at com.winterbe.java8.Streams5.test7(Streams5.java:38)<br>    at com.winterbe.java8.Streams5.main(Streams5.java:28)<br>To overcome this limitation we have to to create a new stream chain for every terminal operation we want to execute, e.g. we could create a stream supplier to construct a new stream with all intermediate operations already set up:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier =</span><br><span class="line">    () -&gt; Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">            .filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">streamSupplier.get().anyMatch(s -&gt; <span class="keyword">true</span>);   <span class="comment">// ok</span></span><br><span class="line">streamSupplier.get().noneMatch(s -&gt; <span class="keyword">true</span>);  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>Each call to get() constructs a new stream on which we are save to call the desired terminal operation.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://github.com/winterbe/java8-tutorial">https://github.com/winterbe/java8-tutorial</a><br><a target="_blank" rel="noopener" href="https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/">https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/</a></p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/08/11/%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">周学习计划</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/05/30/Basics/Computer%20Networking%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><span class="level-item">Computer Networking阅读笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/Shiyu.jpg" alt="Shiyu Liu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Shiyu Liu</p><p class="is-size-6 is-block">Software Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Nashville</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">11</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ShiyuLiuColumbia" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ShiyuLiuColumbia"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Linkedin" href="https://www.linkedin.com/in/shiyu-liu-6623a3158/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:sl4401@columbia.edu"><i class="fas fa-envelope-open"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Lambda-expressions"><span class="level-left"><span class="level-item">1</span><span class="level-item">Lambda expressions</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Default-Methods-for-Interfaces"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Default Methods for Interfaces</span></span></a></li><li><a class="level is-mobile" href="#Lambda-expressions-1"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Lambda expressions</span></span></a></li><li><a class="level is-mobile" href="#Functional-Interfaces"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Functional Interfaces</span></span></a></li><li><a class="level is-mobile" href="#Method-and-Constructor-References"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">Method and Constructor References</span></span></a></li><li><a class="level is-mobile" href="#Lambda-Scopes"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">Lambda Scopes</span></span></a></li><li><a class="level is-mobile" href="#Built-in-Functional-Interfaces"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">Built-in Functional Interfaces</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Predicates"><span class="level-left"><span class="level-item">1.6.1</span><span class="level-item">Predicates</span></span></a></li><li><a class="level is-mobile" href="#Functions"><span class="level-left"><span class="level-item">1.6.2</span><span class="level-item">Functions</span></span></a></li><li><a class="level is-mobile" href="#Suppliers"><span class="level-left"><span class="level-item">1.6.3</span><span class="level-item">Suppliers</span></span></a></li><li><a class="level is-mobile" href="#Consumers"><span class="level-left"><span class="level-item">1.6.4</span><span class="level-item">Consumers</span></span></a></li><li><a class="level is-mobile" href="#Comparators"><span class="level-left"><span class="level-item">1.6.5</span><span class="level-item">Comparators</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Stream"><span class="level-left"><span class="level-item">2</span><span class="level-item">Stream</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#stream解析"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">stream解析</span></span></a></li><li><a class="level is-mobile" href="#加强版类型推断-Target-Type"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">加强版类型推断(Target Type)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Target-Typing"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">Target Typing</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Target-Types-and-Method-Arguments"><span class="level-left"><span class="level-item">2.2.1.1</span><span class="level-item">Target Types and Method Arguments</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#stream-functions"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">stream functions</span></span></a></li><li><a class="level is-mobile" href="#How-streams-work"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">How streams work</span></span></a></li><li><a class="level is-mobile" href="#Different-kind-of-streams"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">Different kind of streams</span></span></a></li><li><a class="level is-mobile" href="#Processing-Order"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">Processing Order</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Why-order-matters"><span class="level-left"><span class="level-item">2.6.1</span><span class="level-item">Why order matters</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Reusing-Streams"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">Reusing Streams</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Reference"><span class="level-left"><span class="level-item">3</span><span class="level-item">Reference</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Shiyu - Blog</a><p class="is-size-7"><span>&copy; 2021 Shiyu Liu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>