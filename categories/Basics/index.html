<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: Basics - Shiyu - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Shiyu - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Shiyu - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Shiyu - Blog"><meta property="og:url" content="https://shiyuliucolumbia.github.io/"><meta property="og:site_name" content="Shiyu - Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://shiyuliucolumbia.github.io/img/og_image.png"><meta property="article:author" content="Shiyu Liu"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://shiyuliucolumbia.github.io"},"headline":"Shiyu - Blog","image":["https://shiyuliucolumbia.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Shiyu Liu"},"publisher":{"@type":"Organization","name":"Shiyu - Blog","logo":{"@type":"ImageObject","url":{"text":"Shiyu - Blog"}}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Shiyu - Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Basics</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-12-05T15:47:04.000Z" title="12/5/2023, 11:47:04 PM">2023-12-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-02-22T13:27:38.834Z" title="2/22/2024, 9:27:38 PM">2024-02-22</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">2 hours read (About 20359 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/12/05/Basics/Java%20Concurrency%20in%20Practice%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Java Concurrency in Practice阅读笔记</a></h1><div class="content"><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="A-very-brief-history-of-concurrency"><a href="#A-very-brief-history-of-concurrency" class="headerlink" title="A (very) brief history of concurrency"></a>A (very) brief history of concurrency</h2><ol>
<li>最早的计算机都是串行的，一个指令接着一个指令的执行下去，但是为了提高效率，进程和线程出现了</li>
<li>同一个进程里面的线程共享同样的内存和堆栈，由于它们都能访问相同的变量，如果没有做好同步的话，就会出现一些不可预计的结果。</li>
</ol>
<h2 id="Benefits-of-threads"><a href="#Benefits-of-threads" class="headerlink" title="Benefits of threads"></a>Benefits of threads</h2><ol>
<li>更好的利用多核处理器</li>
<li>更好的专注于线程要执行的单个简单的任务：比如常见的servlet和RPC架构，框架负责处理请求，创建线程，负责均衡，分发请求等，程序员只需要考虑servlet.service()方法里面的逻辑处理部分即可，仿佛这就是一个单线程的同步请求</li>
</ol>
<h2 id="Risks-of-threads"><a href="#Risks-of-threads" class="headerlink" title="Risks of threads"></a>Risks of threads</h2><h3 id="Safety-hazards"><a href="#Safety-hazards" class="headerlink" title="Safety hazards"></a>Safety hazards</h3><ol>
<li>多线程程序如果没有很好的同步机制，就会导致一些不可预测的结果，俗称线程安全问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">/** Returns a unique value. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上的程序在单线程中执行没有问题，但是如果在多线程中执行就会出现问题，因为这里的value++看似是一个操作，其实是三个操作：读取value当前的值，加1，把新的值赋给value。由于两个线程在执行程序的时候可能会被交错执行。<strong>需要指明的是，这里说的多线程执行指的是实例化一个UnsafeSequence，然后用两个线程去执行这一个实例的getNext()方法，由于线程是共享内存的，所以只存在一个被共享的UnsafeSequence实例。如果在两个线程里面分别实例化两个UnsafeSequence，那么并不会有线程安全问题，因为每个线程操作的是各自的实例</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T1: 取值9 -&gt; T2: 取值9 -&gt; T1: 加1 -&gt; T2: 加1 -&gt; T1: 赋给value，结果为10 -&gt; T2: 赋给value，结果还是为10</span><br></pre></td></tr></table></figure></li>
<li>像UnsafeSequence这种线程不安全的例子我们也称作race condition，这是由于线程共享内存空间，可以对同一个变量进行修改造成的，改进的办法是把这个方法变成同步的：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Liveness-hazards"><a href="#Liveness-hazards" class="headerlink" title="Liveness hazards"></a>Liveness hazards</h3><ol>
<li>活性问题不止出现在多线程程序中，单线程程序中最常见的活性问题是死循环，这会导致程序不能最终到达一个好的状态。多线程种常见的活性问题有死锁(Deadlock)，饥饿(Starvation)，活锁(LiveLock)</li>
</ol>
<h3 id="Performance-hazards"><a href="#Performance-hazards" class="headerlink" title="Performance hazards"></a>Performance hazards</h3><ol>
<li>由于锁的存在以及上下文切换的存在，多线程程序会存在性能问题</li>
</ol>
<h1 id="Thread-Safety"><a href="#Thread-Safety" class="headerlink" title="Thread Safety"></a>Thread Safety</h1><ol>
<li><strong>Writing thread-safe code is, at its core, about managing access to state, and in particular to shared, mutable state.</strong> By shared, we mean that a variable could be accessed by multiple threads; by mutable, we mean that its value could change during its lifetime.</li>
<li>每当多于一个线程访问给定的状态变量(state variable)，并且其中一个可能对其进行写操作时，它们都必须使用同步机制协调对其的访问。</li>
<li>修复线程不安全的三种办法：</li>
</ol>
<ul>
<li>不要在多线程共享状态变量</li>
<li>让状态变量变为不可改变的</li>
<li>在访问状态变量的时候使用同步机制</li>
</ul>
<ol start="4">
<li><strong>如果一个程序只由线程安全的类组成，那么我们可以说这个程序就是线程安全的吗？不可以！假设我们有两个线程安全的类Increase和Decrease，它们都对一个number的变量进行操作，当这两个类分别单独使用的时候，它们都是线程安全的，但是在一起使用的时候，就可能出现线程不安全。所以我们常说的一个类是线程安全的，只针对一个类完全封装了它的状态变量的时候才有意义</strong></li>
</ol>
<h2 id="What-is-thread-safety"><a href="#What-is-thread-safety" class="headerlink" title="What is thread safety?"></a>What is thread safety?</h2><ol>
<li>线程安全类指的是一个类被多个线程访问时表现正确，无论运行时环境如何安排或交错执行这些线程，并且在调用代码方面没有额外的同步或其他协调</li>
</ol>
<h3 id="Example-a-stateless-servlet"><a href="#Example-a-stateless-servlet" class="headerlink" title="Example: a stateless servlet"></a>Example: a stateless servlet</h3><ol>
<li>前面我们提到线程不安全的前提是存在状态变量，如果一个类根本不存在状态变量，也就是类内部没有变量也不引用变量，那么这个类就是无状态的，也就不存在线程安全的问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123; </span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h2><ol>
<li>如果我们向上面线程安全的类里面加入一个状态变量，那么这个类就变得不是线程安全了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCountingFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp&#123;             </span></span></span><br><span class="line"><span class="params"><span class="function">        BigInteger i = extractFromRequest(req)</span></span>;</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        ++count;</span><br><span class="line">        encodeIntoResponse(resp, factors); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Race-conditions"><a href="#Race-conditions" class="headerlink" title="Race conditions"></a>Race conditions</h3><ol>
<li>Race conditions通常发生在计算的正确性取决于多个线程的相对时间或交错执行的情况，换句话说，得到正确答案依赖于幸运的时序。最常见的race conditions类型是check-then-act，check的时候由于时序的原因，可能观察到过时的状态变量，因此进行了错误的act</li>
</ol>
<h3 id="Example-race-conditions-in-lazy-initialization"><a href="#Example-race-conditions-in-lazy-initialization" class="headerlink" title="Example: race conditions in lazy initialization"></a>Example: race conditions in lazy initialization</h3><ol>
<li>一个check-then-act的线程不安全例子：懒加载<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitRace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ExpensiveObject instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExpensiveObject <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> ExpensiveObject();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>另一种常见race condition的例子就是read-modify-write，比如前面见到的<code>counter++</code></li>
</ol>
<h3 id="Compound-actions"><a href="#Compound-actions" class="headerlink" title="Compound actions"></a>Compound actions</h3><ol>
<li>原子操作：操作A和B相对于彼此是原子的，如果从执行A的线程的角度来看，当另一个线程执行B时，要么B的所有部分都已执行，要么全部没有执行</li>
<li>LazyInitRace(check-then-act)和UnsafeCountingFactorizer(read-modify-write)都包含了一些复合操作，这些操作并不具备原子性，所以都会出现线程安全问题</li>
<li>如果我们在和UnsafeCountingFactorizer类中使用java.util.concurrent.atomic自带的原子变量，那么就不会出现线程安全问题了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong count = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> count.get(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;             </span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = factor(i);</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        encodeIntoResponse(resp, factors); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h2><ol>
<li>前面我们介绍的是在CountingFactorizer类中加入一个状态变量，只要保证这个变量是线程安全的即可保证整个类是线程安全的，但是当我们的类中有多个状态变量的时候，问题可能变得复杂。比如我们想要对servlet的请求结果做一个cache：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCachingFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger&gt; lastNumber = <span class="keyword">new</span> AtomicReference&lt;BigInteger&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;BigInteger[]&gt; lastFactors = <span class="keyword">new</span> AtomicReference&lt;BigInteger[]&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;             </span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        <span class="keyword">if</span> (i.equals(lastNumber.get()))</span><br><span class="line">            encodeIntoResponse(resp, lastFactors.get()); </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            BigInteger[] factors = factor(i); </span><br><span class="line">            lastNumber.set(i); </span><br><span class="line">            lastFactors.set(factors); </span><br><span class="line">            encodeIntoResponse(resp, factors);   </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>虽然上面的两个变量都使用了atomic类，它们各自的操作都是原子的，但是由于lastNumber的值会影响lastFactors的取值，所以还是会出现race condition。<strong>线程安全的定义要求无论多线程中操作的时间或交错如何，都必须保持不变量。在UnsafeCachingFactorizer中的一个不变量是，缓存在lastFactors中的因数的乘积应该等于在lastNumber中缓存的值；我们的servlet只有在这个不变量始终保持的情况下才是正确的。</strong></li>
<li>可能的race condition：初始状态时lastNumber=0, response=10；A线程的i=5进来了，i不等于lastNumber，所以lastNumber被设置成了5；此时B线程的i=5进来了，由于i==lastNumber，直接返回了当前的response=10；此时A线程继续执行，根据factors的计算结果返回一个response=20。可以看到同样的输入i=5，由于race condition导致了不同的结果。</li>
<li><strong>To preserve state consistency, update related state variables in a single atomic operation.</strong></li>
</ol>
<h3 id="Intrinsic-locks"><a href="#Intrinsic-locks" class="headerlink" title="Intrinsic locks"></a>Intrinsic locks</h3><ol>
<li>Java提供了一种内置锁来保证操作的原子性：the <code>synchronized</code> block。<code>synchronized</code>有两种使用方法</li>
</ol>
<ul>
<li><code>synchronized</code>代码块：通过一个对象作为锁来保护一段代码块  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"><span class="comment">// Access or modify shared state guarded by lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>synchronized</code>方法：是一种简写版的<code>synchronized</code>代码块，调用这个方法的对象会被用作锁</li>
</ul>
<ol start="2">
<li>每个Java对象都可以充当<code>synchronized</code>块的锁，这些java内置的锁被称为内部锁或监视器锁。在进入<code>synchronized</code>块之前，执行线程会自动获取该锁，并在离开同步块时（通过正常路径或通过在块内抛出异常）自动释放锁。获取内部锁的唯一方法是进入由该锁保护的<code>synchronized</code>块或<code>synchronized</code>方法。</li>
<li>Java中的内部锁是一种互斥锁(mutexes, mutual exclusion locks)，这意味着最多只能有一个线程拥有该锁。当线程A尝试获取由线程B持有的锁时，A必须等待，或者阻塞，直到B释放它。如果B永远不释放锁，A将永远等待。</li>
<li>通过内置锁，我们就可以改写上面的UnsafeCachingFactorizer使它变为线程安全的，这里使用的是<code>synchronized</code>方法。<strong>但是需要注意的是，虽然这种方式保证了线程安全，但是会引起性能问题，因为此时servlet在同一时间只能处理一个请求。</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> BigInteger lastNumber; </span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> BigInteger[] lastFactors;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req); </span><br><span class="line">        <span class="keyword">if</span> (i.equals(lastNumber))</span><br><span class="line">            encodeIntoResponse(resp, lastFactors); </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            BigInteger[] factors = factor(i); </span><br><span class="line">            lastNumber = i;</span><br><span class="line">            lastFactors = factors; </span><br><span class="line">            encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Reentrancy"><a href="#Reentrancy" class="headerlink" title="Reentrancy"></a>Reentrancy</h3></li>
<li>内部锁具备可重入性，也就是说如果一个线程尝试获取一个它已经持有的锁，该请求会成功。可重入性代表着内部锁是基于线程的，而不是基于调用的。</li>
<li>Reentrancy is implemented by associating with each lock an acquisition count and an owning thread. When the count is zero, the lock is considered unheld. When a thread acquires a previously unheld lock, the JVM records the owner and sets the acquisition count to one. If that same thread acquires the lock again, the count is incremented, and when the owning thread exits the synchronized block, the count is decremented. When the count reaches zero, the lock is released</li>
<li>可重入性简化了面向对象的开发，比如下面的例子，当我们使用继承的时候，由于可重入性的存在，<code>super.doSometing()</code>并不会阻塞导致死锁。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> `<span class="keyword">synchronized</span>` <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(toString() + <span class="string">&quot;: calling doSomething&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.doSomething();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Guarding-state-with-locks"><a href="#Guarding-state-with-locks" class="headerlink" title="Guarding state with locks"></a>Guarding state with locks</h2></li>
<li>当一个可变的状态变量被多于一个线程访问（读或者写），如果所有的访问都被同一个锁持有，那么我们说这个状态变量由这个锁保护。<strong>一个常见的错误是认为同步只需要被用在写操作，而不需要用在读操作上</strong></li>
<li>对于涉及多个变量的不变量，与该不变量相关的所有变量都必须由相同的锁保护(<br>For every invariant that involves more than one variable, all the variables involved in that invariant must be guarded by the same lock)。一个很好的例子是Java的vector集合，vector集合的所有操作都使用了<code>synchronized</code>代码块，但是对于复合操作，仍然会出现race condition。<strong>我们仍然说vector类是线程安全的，因为它的每个操作都是原子的，但是在使用多个操作的时候，我们仍然要考虑线程安全的问题</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!vector.contains(element)) </span><br><span class="line">    vector.add(element);</span><br></pre></td></tr></table></figure></li>
<li>上边的例子不止对vector是这样，对于所有的线程安全的map都是如此，比如ConcurrentHashMap也是一样的：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14947723/is-concurrenthashmap-totally-safe%E3%80%82%E5%9B%A0%E6%AD%A4ConcurrentHashMap%E6%8F%90%E4%BE%9B%E4%BA%86%60putIfAbsent()%60%E6%96%B9%E6%B3%95%EF%BC%8C%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E5%8E%9F%E5%AD%90%E5%8C%96%E7%9A%84%E4%B8%8A%E9%9D%A2%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81">https://stackoverflow.com/questions/14947723/is-concurrenthashmap-totally-safe。因此ConcurrentHashMap提供了`putIfAbsent()`方法，其实就是原子化的上面这段代码</a></li>
</ol>
<h2 id="Liveness-and-performance"><a href="#Liveness-and-performance" class="headerlink" title="Liveness and performance"></a>Liveness and performance</h2><ol>
<li>前面的SynchrizedFactorizer虽然没有线程安全问题，但是作为一个servlet，它同一时间只能处理一个请求，这无疑是低效的，解决的办法是减少我们<code>synchronized</code>代码块覆盖的范围，比如某些local variable并不需要加锁。<code>synchronized</code>代码块覆盖的长度是一个trade off问题，太长会导致性能问题，但也不能由于太短而导致线程安全问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> BigInteger lastNumber; </span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> BigInteger[] lastFactors; </span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">long</span> hits; </span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">long</span> cacheHits;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getHits</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hits; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">getCacheHitRatio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) cacheHits / (<span class="keyword">double</span>) hits; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;             </span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ++hits;</span><br><span class="line">            <span class="keyword">if</span> (i.equals(lastNumber)) &#123;</span><br><span class="line">                ++cacheHits;    </span><br><span class="line">                factors = lastFactors.clone(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i); </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                lastNumber = i;</span><br><span class="line">                lastFactors = factors.clone(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors); &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>避免在长时间的计算或可能无法迅速完成的操作（例如网络请求）期间持有锁</li>
</ol>
<h1 id="Sharing-Objects"><a href="#Sharing-Objects" class="headerlink" title="Sharing Objects"></a>Sharing Objects</h1><ol>
<li>上一章我们主要介绍了如果通过使用同步手段来避免多个线程对同一个变量的同时访问；这一章我们主要介绍如何通过一些手段来共享和发布对象，以让它们可以安全的被多个线程访问。</li>
<li>上一章我们已经看到了同步机制可以确保所包含的代码块是原子执行的，但是一个常见的误区是同步机制只是用来做这个的，<strong>同步机制另外一个很重要的方面是保证内存可见性。</strong> 我们不止希望保证当一个线程在使用一个变量的时候，别的线程不能修改它；也希望确保当一个线程修改了一个变量以后，别的线程可以知道这个变化。</li>
</ol>
<h2 id="Visibility"><a href="#Visibility" class="headerlink" title="Visibility"></a>Visibility</h2><ol>
<li>可见性是非常微妙的因为可见性是违背直觉的：当读和写发生在不同的线程，读线程不能保证可以看到写线程做出的改动，甚至完全看不到。为了保证内存的可见性，必须使用同步机制。</li>
<li>一个正面内存可见性的例子。例子里面在主线程里面把number设置成42，ready设置成true，但是在Reader线程里面number的打印结果可能是0，或者永远不会打印结果。永远不会打印结果的原因是可能ready的结果在Reader线程里面一直不可见，number打印是0的原因是ready是true已经在Reader线程可见，但是number=42的改动在Reader线程还不可见。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready)</span><br><span class="line">                Thread.yield();</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在缺乏同步的情况下，编译器、处理器和运行时环境可能以一些相当奇怪的方式影响操作执行的顺序。试图推断在没有同步的多线程程序中内存操作的执行顺序几乎肯定是不正确的</li>
</ol>
<h3 id="Stale-data"><a href="#Stale-data" class="headerlink" title="Stale data"></a>Stale data</h3><ol>
<li>如前面见到的，内存不可见的一大问题就是会导致读取过时的数据</li>
</ol>
<h3 id="Nonatomic-64-bit-operations"><a href="#Nonatomic-64-bit-operations" class="headerlink" title="Nonatomic 64-bit operations"></a>Nonatomic 64-bit operations</h3><ol>
<li>64位的长整型在JVM可能被当做两个32位的操作，内存不可见会导致这两个32位读取完全不同的值</li>
</ol>
<h3 id="Locking-and-visibility"><a href="#Locking-and-visibility" class="headerlink" title="Locking and visibility"></a>Locking and visibility</h3><ol>
<li>加锁不止可以保证互斥，也能保证内存一致性(Locking is not just about mutual exclusion; it is also about memory visi- bility. To ensure that all threads see the most up-to-date values of shared mutable variables, the reading and writing threads must synchronize on a common lock)</li>
</ol>
<h3 id="Volatile-variables"><a href="#Volatile-variables" class="headerlink" title="Volatile variables"></a>Volatile variables</h3><ol>
<li>Java提供了一种比锁弱一些的同步机制来保证内存一致性，Volatile关键词可以保证修饰的变量的改变可以被其他线程看到，不会被寄存器缓存</li>
<li>但是相比锁的同步机制，Volatile关键词只保证了内存一致性，并不能保证操作的原子性(<br>Locking can guarantee both visibility and atomicity; volatile variables can only guarantee visibility)</li>
</ol>
<h2 id="Publication-and-escape"><a href="#Publication-and-escape" class="headerlink" title="Publication and escape"></a>Publication and escape</h2><ol>
<li>发布(publish)一个对象意味着使其在其当前范围之外的代码可用，比如通过在其他代码可以找到的地方存储对它的引用，从非私有方法返回它，或将它传递给另一个类中的方法。如果一个对象发布在了本来不应该可见的地方，那么我们就说这个对象逃逸(escape)了。对象的逃逸会导致线程安全问题。</li>
<li>逃逸的例子：1. 即使states被声明为private，但是由于有getStates()这个public的方法可以访问他，所以本质上其他类可以访问他，所以这里出现了逃逸 2. 内部类存在一个隐含的对外部类实例的引用，所以内部类可以直接访问外部类的成员和方法，包括私有成员和方法，所以这里其实也造成了逃逸<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">&quot;AK&quot;</span>, <span class="string">&quot;AL&quot;</span> ...</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123; <span class="keyword">return</span> states; &#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line">    pirvate <span class="keyword">int</span> outClassValue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        source.registerListener ( </span><br><span class="line">            <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123; </span><br><span class="line">                    doSomething(e, outClassValue);</span><br><span class="line">                &#125;                   </span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Safe-construction-practices"><a href="#Safe-construction-practices" class="headerlink" title="Safe construction practices"></a>Safe construction practices</h3><ol>
<li>一种常见的逃逸错误就是在一个对象还没有完全构造完成之前，把this传递给了其他类，这会导致其他类看到的对象还没有完全构造完成，导致一些不可预测的错误<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do some initialization</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don&#x27;t do this - &quot;this&quot; reference escapes during construction</span></span><br><span class="line">        SomeExternalClass.registerInstance(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>另外一种常见的this引用逃逸的例子是在构造方法中启动一个线程，这个线程或显示的引用this，或隐式的引用this(比如Thread或者Runnable是这个对象的内部类)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do some initialization</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don&#x27;t do this - starting a thread from the constructor</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// The thread has a reference to the partially constructed object</span></span><br><span class="line">            <span class="comment">// This can lead to unexpected behavior</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Value from thread: &quot;</span> + value);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由于在这个Thread类是MyClass类的匿名内部类，所以可以直接引用MyClass类的成员变量。Thread内部类在MyClass类的构造方法里面创建并开启，<strong>这个时候MyClass类的对象还没有初始化完成，但是新开启的线程已经使用了MyClass类的对象里的value成员变量，这会导致严重的错误。因此，我们可以在构造方法里面新建Thread，但是最好不要在构造方法里开启Thread。</strong></li>
</ol>
<h2 id="Thread-confinement"><a href="#Thread-confinement" class="headerlink" title="Thread confinement"></a>Thread confinement</h2><ol>
<li>访问共享(shared)可变(mutable)的变量需要使用同步机制来保证线程安全，一个最简单的方法去避免线程安全问题就是不共享变量，这种技术称作Thread confinement(线程封闭)：一个对象被限制在只被一个线程使用，这样自然而然就没有线程安全的问题了</li>
<li>一个常见的例子是JDBC的connection对象，JDBC并不要求connection对象是线程安全的，所以一般的应用都是建立一个JDBC连接池，当servlet的请求到来的时候，去JDBC连接池中获取一个connection对象并使用，由于一个servlet请求都是在一个线程中工作，所以获取的connection对象在当前请求未完成前不会回到连接池，也就不会被多个线程共用。</li>
</ol>
<h3 id="Stack-confinement"><a href="#Stack-confinement" class="headerlink" title="Stack confinement"></a>Stack confinement</h3><ol>
<li>本地变量被限制在所执行的线程中，它们存在于所执行线程的栈(stack)中，其它线程不可访问。比如下面例子里面的numPairs变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span> </span>&#123; </span><br><span class="line">    SortedSet&lt;Animal&gt; animals;</span><br><span class="line">    <span class="keyword">int</span> numPairs = <span class="number">0</span>;</span><br><span class="line">    Animal candidate = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// animals confined to method, don’t let them escape!</span></span><br><span class="line">    animals = <span class="keyword">new</span> TreeSet&lt;Animal&gt;(<span class="keyword">new</span> SpeciesGenderComparator()); </span><br><span class="line">    animals.addAll(candidates);</span><br><span class="line">    <span class="keyword">for</span> (Animal a : animals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate == <span class="keyword">null</span> || !candidate.isPotentialMate(a)) </span><br><span class="line">        candidate = a;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ark.load(<span class="keyword">new</span> AnimalPair(candidate, a)); </span><br><span class="line">            ++numPairs;</span><br><span class="line">            candidate = <span class="keyword">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numPairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ol>
<li>更正式地实现线程封闭性的方法是使用<code>ThreadLocal</code>，<code>ThreadLocal</code>提供了<code>get</code>和<code>set</code>存取方法，这些方法为每个使用它的线程维护一个单独的值副本，因此<code>get</code>会返回当前执行线程从<code>set</code>中获取的最新值。</li>
<li>同样是JDBC的例子，这里使用<code>ThreadLocal</code>:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h2><ol>
<li>消除线程安全的另一个方向就是使用不可变(immutable)的变量</li>
<li>被声明成final的的变量不一定就是不可变的，因为final只代表这个变量的引用不能变了，但是引用的对象本身其实是可以改变的，比如声明一个<code>public final List&lt;String&gt; example = new LinkedList&lt;&gt;()</code>，example变量的引用不能改变了，但是它引用的这个list是可以增加删除元素的。</li>
<li>An object is immutable if:</li>
</ol>
<ul>
<li>Its state cannot be modified after construction;</li>
<li>All its fields are final;12 and</li>
<li>It is properly constructed (the this reference does not escape during<br>construction).</li>
</ul>
<h3 id="Example-Using-volatile-to-publish-immutable-objects"><a href="#Example-Using-volatile-to-publish-immutable-objects" class="headerlink" title="Example: Using volatile to publish immutable objects"></a>Example: Using volatile to publish immutable objects</h3><ol>
<li>通过immutable volatile的OneValueCache来保证线程安全，OneValueCache对象里面的lastNumber和lastFactors如果需要改变，会直接copy一个新的OneValueCache对象，以此保证lastNumber和lastFactors的同步更改。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i, BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;             </span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors); </span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Safe-publication"><a href="#Safe-publication" class="headerlink" title="Safe publication"></a>Safe publication</h2><ol>
<li>前面几个单元我们主要专注于保证对象不会发布和逃逸，但是在实际的代码中，我们肯定不能保证所有的对象都不逃逸，所以本单元主要介绍如果保证安全的发布</li>
</ol>
<h3 id="Improper-publication-when-good-objects-go-bad"><a href="#Improper-publication-when-good-objects-go-bad" class="headerlink" title="Improper publication: when good objects go bad"></a>Improper publication: when good objects go bad</h3><ol>
<li>不安全的发布会导致会严重的后果，比如下面的例子中，两个不同的线程调用Holder构造方法和assertSanity()，导致assertSanity()方法里面两次读到的n不一致，那么会出现AssertionError：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSanity</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (n != n)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;This statement is false.&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Immutable-objects-and-initialization-safety"><a href="#Immutable-objects-and-initialization-safety" class="headerlink" title="Immutable objects and initialization safety"></a>Immutable objects and initialization safety</h3><ol>
<li>如前所述，不可变对象可以被安全的发布</li>
</ol>
<h3 id="Safe-publication-idioms"><a href="#Safe-publication-idioms" class="headerlink" title="Safe publication idioms"></a>Safe publication idioms</h3><ol>
<li>To publish an object safely, both the reference to the object and the ob- ject’s state must be made visible to other threads at the same time. A properly constructed object can be safely published by:</li>
</ol>
<ul>
<li>Initializing an object reference from a static initializer;</li>
<li>Storing a reference to it into a volatile field or AtomicReference;</li>
<li>Storing a reference to it into a final field of a properly constructed<br>object; or</li>
<li>Storing a reference to it into a field that is properly guarded by a<br>lock.</li>
</ul>
<h3 id="Effectively-immutable-objects"><a href="#Effectively-immutable-objects" class="headerlink" title="Effectively immutable objects"></a>Effectively immutable objects</h3><ol>
<li>如果一个对象是可变的，但是其他线程都不会改变它，那么从逻辑上它就是一个不可变的对象，那么它在安全发布以后就可以被随意使用</li>
</ol>
<h3 id="Mutable-objects"><a href="#Mutable-objects" class="headerlink" title="Mutable objects"></a>Mutable objects</h3><ol>
<li>如果一个对象在发布以后还会被改变，那么安全发布只是保证了对象的可见性，还是需要使用同步机制保证线程安全</li>
</ol>
<h3 id="Sharing-objects-safely"><a href="#Sharing-objects-safely" class="headerlink" title="Sharing objects safely"></a>Sharing objects safely</h3><ol>
<li><strong>The most useful policies for using and sharing objects in a concurrent program are:</strong></li>
</ol>
<ul>
<li>线程封闭：A thread-confined object is owned exclusively by and confined to one thread, and can be modified by its owning thread.</li>
<li>共享对象，但是只读：A shared read-only object can be accessed concurrently by multiple threads without additional synchronization, but cannot be modified by any thread. Shared read-only objects include immutable and effectively immutable objects.</li>
<li>使用线程安全的共享对象，比如Java自带的线程安全集合：A thread-safe object performs synchronization internally, so multiple threads can freely access it through its public interface without further synchronization.</li>
<li>被锁保护的对象： A guarded object can be accessed only with a specific lock held. Guarded objects include those that are encapsulated within other thread-safe objects and published objects that are known to be guarded by a specific lock.</li>
</ul>
<h1 id="Composing-Objects"><a href="#Composing-Objects" class="headerlink" title="Composing Objects"></a>Composing Objects</h1><ol>
<li>前面我们已经介绍了线程安全和同步的基础，但是我们并不希望分析代码的每一部分去确认我们的程序是线程安全的，这一章我们会介绍一些组织Java类的模式来让它们保证线程安全</li>
</ol>
<h2 id="Designing-a-thread-safe-class"><a href="#Designing-a-thread-safe-class" class="headerlink" title="Designing a thread-safe class"></a>Designing a thread-safe class</h2><ol>
<li>线程安全类的设计模式：</li>
</ol>
<ul>
<li>Identify the variables that form the object’s state(找到形成一个对象所有的状态变量)</li>
<li>Identify the invariants that constrain the state variables(找到所有限制状态变量取值的不变量)</li>
<li>Establish a policy for managing concurrent access to the object’s<br>state(建立一个管理并行访问对象状态的策略)</li>
</ul>
<ol start="2">
<li>一个对象的状态变量就是由它的成员变量(fields)所决定的，如果所有的成员变量都是基本数据类型，那么这个类的线程安全只由这些基本数据类型共同决定。如果成员变量有对于其他类的引用，比如LinkedList，那么线程安全也需要包括所有LinkedList的节点的状态变量。</li>
<li>同步策略定义了一个对象是如何协调对其状态变量的访问来保证不违反不变量(invariants)或者后置条件(postconditions)，它定义了这个对象如何使用不变性(immutability)，线程封闭(thread confinement)以及锁(locking)的结合来确保线程安全的</li>
</ol>
<h3 id="Gathering-synchronization-requirements"><a href="#Gathering-synchronization-requirements" class="headerlink" title="Gathering synchronization requirements"></a>Gathering synchronization requirements</h3><ol>
<li>确保一个类是线程安全的意味着在并发访问下保持其不变量成立，这需要对其状态变量进行推理。状态变量都有自己的状态空间(state space)，表明状态变量合法的可以取得值的范围</li>
<li>大部分类都有一些不变量来说明状态变量是合法还是不合法的。比如一个counter变量是一个长整型，长整型的状态变量是<code>Long.MIN_VALUE</code>到<code>Long.MAX_VALUE</code>，但是我们限制counter只能是非负数，那么小于零就是不合法的。同样的，后置条件也会影响状态变量的取值，比如如果counter目前的值是17，那么它的下一个值就必须是18。但比如我们的变量存储的是当前的温度值，那么下一个温度值就不受前面的温度值影响。</li>
<li>一个类也会有不变量是由两个以上状态变量控制的，比如后边我们会介绍的NumberRange类，它声明了一个lower bound和一个upper bound，那么这就存在一个不变量：lower bound不能大于upper bound。如果我们的多线程程序没有考虑这一个不变量，就会导致出现lower bound大于upper bound的问题。</li>
<li><strong>综上，如果我们不理解一个类的不变量和后置条件，我们是不能确保线程安全的，因为我们也许需要通过创建一些原子操作或者进行类封装来限制产生不合法的状态</strong></li>
</ol>
<h3 id="State-dependent-operations"><a href="#State-dependent-operations" class="headerlink" title="State-dependent operations"></a>State-dependent operations</h3><ol>
<li>一些对象会有一些方法具有基于状态的前置条件，比如我们不能从一个空的queue里面移除元素</li>
<li>在一个单线程的程序中，如果一个前置条件没有被满足，那么程序只能选择fail；但是对于多线程程序，前置条件可能会达到通过其他线程的操作，所以多线程提供了等待达成前置条件并继续操作的可能。</li>
<li>Java内置的wait和notify方法就用来实现这种等待，它们和对象的内置锁紧密相关联，我们会在第14章具体介绍它们。或者我们可以使用一些Java内置的类，比如BlockingQueue, Semaphore来达到等待的效果</li>
</ol>
<h3 id="State-ownership"><a href="#State-ownership" class="headerlink" title="State ownership"></a>State ownership</h3><ol>
<li>以Servlet举例，它使用的ServletContext是线程安全的，我们可以使用它的setAttribute和getAttribute来设置属性，但是ServletContext存储的类的线程安全需要由我们作为使用者来确保。</li>
</ol>
<h2 id="Instance-confinement"><a href="#Instance-confinement" class="headerlink" title="Instance confinement"></a>Instance confinement</h2><ol>
<li>Java封装可以简单的使一个类线程安全，我们称这种方式叫做实例封闭(Instance confinement)。一个线程不安全的类，被封闭在另外一个类中，我们确保只有这个封装的类可以访问这个线程不安全的类，并且采用同步等手段保证其线程安全。</li>
<li>以下的例子展示了instance confinement。例子中的HashSet并不是线程安全的，但由于我们将其封装在PersonSet类中，并且使用内置锁保证了线程安全，因此这里我们可以说PersonSet就是一个线程安全的类。需要注意的是，这里我们没有关注Person类的线程安全，如果Person类不是线程安全的，那么我们也需要采取同步措施。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Person&gt; mySet = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person p)</span> </span>&#123; </span><br><span class="line">        mySet.add(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsPerson</span><span class="params">(Person p)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> mySet.contains(p);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Java自己也使用了instance confinement的方法，比如ArrayList和Hashmap都是线程不安全的，但是Java提供了一些wrapper factory method(Collections.synchronizedList等)。Wrapper实现一些同步的底层集合使用的方法，并且将请求传递给底层的集合</li>
</ol>
<h3 id="The-Java-monitor-pattern"><a href="#The-Java-monitor-pattern" class="headerlink" title="The Java monitor pattern"></a>The Java monitor pattern</h3><ol>
<li>按照前面的instance confinement设计的类就使用了Java的监视器模式。也就是通过把可变的变量封装在一个新的类中，并且使用同步机制保证线程安全的模式</li>
</ol>
<h3 id="Example-tracking-fleet-vehicles"><a href="#Example-tracking-fleet-vehicles" class="headerlink" title="Example: tracking fleet vehicles"></a>Example: tracking fleet vehicles</h3><ol>
<li>一个使用Java monitor pattern的例子，虽然MutablePoint类不是线程安全的，但是MonitorVehicleTracker通过使用同步机制使对它的使用是线程安全的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePoint</span><span class="params">()</span> </span>&#123; x = <span class="number">0</span>; y = <span class="number">0</span>; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePoint</span><span class="params">(MutablePoint p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = p.x;</span><br><span class="line">        <span class="keyword">this</span>.y = p.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorVehicleTracker</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, MutablePoint&gt; locations;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MonitorVehicleTracker</span><span class="params">(Map&lt;String, MutablePoint&gt; locations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.locations = deepCopy(locations); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Map&lt;String, MutablePoint&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> deepCopy(locations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> MutablePoint <span class="title">getLocation</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        MutablePoint loc = locations.get(id);</span><br><span class="line">        <span class="keyword">return</span> loc == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> MutablePoint(loc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;             </span><br><span class="line">        MutablePoint loc = locations.get(id);</span><br><span class="line">        <span class="keyword">if</span> (loc == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No such ID: &quot;</span> + id); </span><br><span class="line">        loc.x = x;</span><br><span class="line">        loc.y = y; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, MutablePoint&gt; <span class="title">deepCopy</span><span class="params">(Map&lt;String, MutablePoint&gt; m)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, MutablePoint&gt; result = </span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;String, MutablePoint&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String id : m.keySet())</span><br><span class="line">            result.put(id, <span class="keyword">new</span> MutablePoint(m.get(id)));</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(result); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Delegating-thread-safety"><a href="#Delegating-thread-safety" class="headerlink" title="Delegating thread safety"></a>Delegating thread safety</h2><ol>
<li>Java监视器模式对于从头创建一个类或者使用线程不安全的类很有帮助，但是如果已经存在的类已经是线程安全的，我们还需要使用监视器模式来创建一层吗？答案是有的时候可以，有的时候不行，下面我们会具体讨论</li>
<li>前面很早我们讨论的CountingFactorizer类使用了AtomicLong类，由于AtomicLong是唯一的状态变量，我们可以说由于AtomicLong类是线程安全的，所以CountingFactorizer类也是线程安全的，<strong>也就是说CountingFactorizer类的线程安全性由AtomicLong类代表了</strong>。</li>
</ol>
<h3 id="Example-vehicle-tracker-using-delegation"><a href="#Example-vehicle-tracker-using-delegation" class="headerlink" title="Example: vehicle tracker using delegation"></a>Example: vehicle tracker using delegation</h3><ol>
<li>以下的例子展示了通过delegation确保线程安全。由于使用的ConcurrentMap和Point类都是线程安全的，所以DelegatingVehicleTracker类也是线程安全的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingVehicleTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Point&gt; locations; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Point&gt; unmodifiableMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegatingVehicleTracker</span><span class="params">(Map&lt;String, Point&gt; points)</span> </span>&#123; </span><br><span class="line">        locations = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Point&gt;(points); unmodifiableMap = Collections.unmodifiableMap(locations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Point&gt; <span class="title">getLocations</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> unmodifiableMap;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getLocation</span><span class="params">(String id)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> locations.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (locations.replace(id, <span class="keyword">new</span> Point(x, y)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">&quot;invalid vehicle name: &quot;</span> + id);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Independent-state-variables"><a href="#Independent-state-variables" class="headerlink" title="Independent state variables"></a>Independent state variables</h3><ol>
<li>前面我们的delegation的例子都是针对一个线程安全的状态变量(比如AtomicLong和locations)。一个类也可以由多个状态变量进行delegation，但是需要各自是<strong>独立的</strong></li>
<li>以下是一个由两个独立的状态变量delegation的类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisualComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;KeyListener&gt; keyListeners = </span><br><span class="line">        <span class="keyword">new</span> CopyOnWriteArrayList&lt;KeyListener&gt;(); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MouseListener&gt; mouseListeners = </span><br><span class="line">        <span class="keyword">new</span> CopyOnWriteArrayList&lt;MouseListener&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addKeyListener</span><span class="params">(KeyListener listener)</span> </span>&#123; </span><br><span class="line">        keyListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMouseListener</span><span class="params">(MouseListener listener)</span> </span>&#123; </span><br><span class="line">        mouseListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKeyListener</span><span class="params">(KeyListener listener)</span> </span>&#123; </span><br><span class="line">        keyListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMouseListener</span><span class="params">(MouseListener listener)</span> </span>&#123;                   </span><br><span class="line">        mouseListeners .remove (listener);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="When-delegation-fails"><a href="#When-delegation-fails" class="headerlink" title="When delegation fails"></a>When delegation fails</h3></li>
<li>当一个类由多个非独立的状态变量组成的时候，并不能仅仅通过每个状态变量的线程安全就判断整个类的线程安全</li>
<li>以下是一个线程不安全的例子，假设一个类调用<code>setLower(5)</code>，另一个类调用<code>setUpper(4)</code>，就会出现打破lower&lt;=upper的不变量。执行顺序是：初始的lower是0，upper是10，第一个线程调用<code>setLower(5)</code>，判断i不大于upper，继续执行，此时第二个线程调用<code>setUpper(4)</code>，判断i不小于lower，继续执行，然后upper被设置成了4，然后第一个线程恢复执行，lower被设置成了5.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberRange</span> </span>&#123;</span><br><span class="line">    <span class="comment">// INVARIANT: lower &lt;= upper</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger lower = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger upper = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Warning -- unsafe check-then-act</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; upper.get())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">&quot;can’t set lower to &quot;</span> + i + <span class="string">&quot; &gt; upper&quot;</span>); </span><br><span class="line">        lower.set(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Warning -- unsafe check-then-act</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; lower.get())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">&quot;can’t set upper to &quot;</span> + i + <span class="string">&quot; &lt; lower&quot;</span>); </span><br><span class="line">        upper.set(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInRange</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &gt;= lower.get() &amp;&amp; i &lt;= upper.get());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Adding-functionality-to-existing-thread-safe-classes"><a href="#Adding-functionality-to-existing-thread-safe-classes" class="headerlink" title="Adding functionality to existing thread-safe classes"></a>Adding functionality to existing thread-safe classes</h2></li>
<li>本章介绍如何使用已经存在的线程安全的类来扩展我们想要的功能。比如如果一个List已经是线程安全的，并且已经有contains和add方法，而我们想要的是一个put-if-absent方法，我们可以修改List源代码(如果我们可以的话)或者继承已有的类</li>
<li>一个继承的例子<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterVector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">boolean</span> absent = !contains(x);</span><br><span class="line">        <span class="keyword">if</span> (absent)</span><br><span class="line">            add(x);</span><br><span class="line">        <span class="keyword">return</span> absent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Client-side-locking"><a href="#Client-side-locking" class="headerlink" title="Client-side locking"></a>Client-side locking</h3></li>
<li>除了直接修改源代码和继承，第三种方法是使用一个helper类，但是下面的一个例子由于没有正确的使用同步的锁，而线程不安全。因为list对象使用的是自己的内置锁进行同步，但是putIfAbsent方法使用的是ListHelper的内置锁，这就代表着putIfAbsent和list其他的方法并不用同一个锁，也就是线程不安全的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> absent = !list.contains(x); </span><br><span class="line">        <span class="keyword">if</span> (absent)</span><br><span class="line">            list.add(x);</span><br><span class="line">        <span class="keyword">return</span> absent;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为了修复这个问题，我们这里需要使用与list相同的锁，也就是client-side locking<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> absent = !list.contains(x); </span><br><span class="line">            <span class="keyword">if</span> (absent)</span><br><span class="line">                list.add(x);</span><br><span class="line">            <span class="keyword">return</span> absent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h3><ol>
<li>另外我们也可以使用组合来保证线程安全，下面的例子我们不关心list的具体实现，因为所有的方法我们都会用ImprovedList类的内置锁进行同步。这里其实我们也使用了Java监视器模式。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImprovedList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImprovedList</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123; <span class="keyword">this</span>.list = list; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(T x)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">boolean</span> contains = list.contains(x);</span><br><span class="line">        <span class="keyword">if</span> (contains)</span><br><span class="line">            list.add(x);</span><br><span class="line">        <span class="keyword">return</span> !contains;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; list.clear(); &#125;</span><br><span class="line">    <span class="comment">// ... similarly delegate other List methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Documenting-synchronization-policies"><a href="#Documenting-synchronization-policies" class="headerlink" title="Documenting synchronization policies"></a>Documenting synchronization policies</h2><ol>
<li>一个类的线程安全与否要记录下来以方便client，一个类的线程安全策略也应记录下来以方便维护者</li>
</ol>
<h1 id="Building-Blocks"><a href="#Building-Blocks" class="headerlink" title="Building Blocks"></a>Building Blocks</h1><ol>
<li>前面我们介绍了线程安全的概念以及如何使一个类保证线程安全，其中提到了代理的方法，在我们日常写代码的过程中，我们肯定不希望从头构建新的类，而是希望代理已有的类来保证线程安全，所以这一章将会介绍Java内置的一些同步类</li>
</ol>
<h2 id="Synchronized-collections"><a href="#Synchronized-collections" class="headerlink" title="Synchronized collections"></a>Synchronized collections</h2><ol>
<li>Java 1.2中引入了一些同步集合类，包括Vector和Hashtable，和一些由<code>Collections.synchronizedXxx</code>的工厂方法包装的同步类。</li>
</ol>
<h3 id="Problems-with-synchronized-collections"><a href="#Problems-with-synchronized-collections" class="headerlink" title="Problems with synchronized collections"></a>Problems with synchronized collections</h3><ol>
<li>同步类虽然本身是线程安全的，但是并不能很好的处理复合操作(compound actions)，比如我们前面提到的put-if-absent和迭代操作(iteration)</li>
<li>下面的例子展示了复合操作是如何导致线程安全问题的，如果两个不同的线程分别执行<code>getLast</code>和<code>deleteLast</code>方法，比如A线程执行<code>getLast</code>并且计算出lastIndex是9(假设vector开始有10个元素)，然后此时B线程执行<code>deleteLast</code>并且计算出lastIndex是9，然后执行<code>list.remove(lastIndex);</code>，最后回到A线程开始执行<code>return list.get(lastIndex);</code>。由于此时第十个元素已经被线程B删除了，所以A线程的<code>return list.get(lastIndex);</code>会报错ArrayIndexOutOfBoundsException<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>; </span><br><span class="line">    list.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>想要修复问题，我们需要使用client side locking<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(lastIndex); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">        list.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>上面同样的线程安全问题也会发生在迭代，因为迭代也是复合操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++)</span><br><span class="line">    doSomething(vector.get(i));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Iterators-and-ConcurrentModificationException"><a href="#Iterators-and-ConcurrentModificationException" class="headerlink" title="Iterators and ConcurrentModificationException"></a>Iterators and ConcurrentModificationException</h3><ol>
<li>我们使用Vector作为例子展示了迭代作为复合操作会导致的线程安全问题，但是我们现在常用的Java 5版本引入的Collection的Iterator也有同样的问题，而其采取的解决办法是如果检测到Iterator被使用在多线程中，就会抛出ConcurrentModificationException，具体的实现是内部维护一个modification count，如果在迭代的过程中这个值被修改，那么就会抛出异常。</li>
<li>所以如果想要线程安全的使用迭代，那么也需要使用同步机制</li>
<li>或者每次当我们要迭代集合的时候，我们就为当前线程复制一个新的集合，由于thread confineness，就可以保证线程安全，但是如果集合太大，必然导致性能开销</li>
</ol>
<h3 id="Hidden-iterators"><a href="#Hidden-iterators" class="headerlink" title="Hidden iterators"></a>Hidden iterators</h3><ol>
<li>某些代码里面没有明确使用Iterator，但是编译器在编译的时候会使用Iterator，比如这一句想要打印set集合的内容<code>System.out.println(&quot;DEBUG: added ten elements to &quot; + set);</code>，编译器会调用集合的<code>toString</code> 方法，而这个方法是迭代实现的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenIterator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer i)</span> </span>&#123; </span><br><span class="line">        set.add(i); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Integer i)</span> </span>&#123; </span><br><span class="line">        set.remove(i); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTenThings</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            add(r.nextInt());</span><br><span class="line">        System.out.println(<span class="string">&quot;DEBUG: added ten elements to &quot;</span> + set);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Concurrent-collections"><a href="#Concurrent-collections" class="headerlink" title="Concurrent collections"></a>Concurrent collections</h2><ol>
<li>Java 5使用并发集合提升了同步集合的缺点。使用ConcurrentHashMap代替了同步map，使用了CopyOnWriteArrayList代替了同步list。同时还引入了Queue和BlockingQueue</li>
</ol>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ol>
<li>不像同步集合有一个固定的锁限制了所有的操作，ConcurrentHashMap使用了一种叫做lock striping的方法来允许更大程度的共享访问：读线程可以无限制的并行访问；读线程也可以并行的和写线程同时操作，并且只有有限制数量的写线程可以修改map</li>
<li>ConcurrentHashMap的Ieratator也不会像前面提到的普通集合抛出ConcurrentModificationException，而是一种weakly consistent，也就是说Iterator返回的值是在其构建时候的值，如果有别的线程修改了map的值，Iterator并不保证能反映其最新的变动的值</li>
<li>ConcurrentHashMap为了达到最好的并发效率，也做了一些trade-offs，比如ConcurrentHashMap的size和isEmpty方法返回的都是大概值</li>
<li>ConcurrentHashMap增加了常用的复合操作，比如put-if-absent, remove-if-equal, replace-if-equal</li>
</ol>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ol>
<li>copy-on-write集合的实现线程安全的方式是每次集合被修改的时候，都会复制出来一个全新的集合并返回。CopyOnWriteArrayList也支持Iterator，Iterator返回的元素是其创建时候的元素，并不包括后续修改的元素</li>
<li>由于复制需要一些花销，copy-on-write集合更适用于那种迭代操作大于修改操作的程序</li>
</ol>
<h2 id="Blocking-queues-and-the-producer-consumer-pattern"><a href="#Blocking-queues-and-the-producer-consumer-pattern" class="headerlink" title="Blocking queues and the producer-consumer pattern"></a>Blocking queues and the producer-consumer pattern</h2><ol>
<li>Blocking Queue提供了阻塞的put和take方法，如果queue是满的，那么put方法会block直到queue不是满的；如果queue是空的，那么take方法会block直到queue不是空的</li>
<li>Blocking Queue支持producer-consumer设计模式。producer-consumer设计模式简化了开发，因为它移除了producer和consumer代码的依赖性。最常见的producer-consumer的设计就是一个线程池前面连接这一个block queue，Java的Executor task execution framework就是使用了这种模式</li>
<li>Blocking queue分为bounded和unbounded，unbounded blocking在producer的处理速度大于consumer的处理速度的情况下，queue里的元素会越来越多</li>
<li>Java提供一些实现好的Blocking queue，比如LinkedBlockingQueue和ArrayBlockingQueue都是FIFO queue，而PriorityBlockingQueue可以按照我们自己定义的顺序移出元素</li>
</ol>
<h3 id="Serial-thread-confinement"><a href="#Serial-thread-confinement" class="headerlink" title="Serial thread confinement"></a>Serial thread confinement</h3><ol>
<li>对于可变的对象，producer-consumer设计模式使用了serial thread confinement，也就是说可变对象同一时间只能在一个线程里，并保证除了正在使用它的线程别的线程不会改变它。比如一个可变对象正在consumer线程里面处理，那么producer线程不会修改它</li>
</ol>
<h3 id="Deques-and-work-stealing"><a href="#Deques-and-work-stealing" class="headerlink" title="Deques and work stealing"></a>Deques and work stealing</h3><ol>
<li>Java 6还增加了另外两种集合类型：Deque和BlockDequeue。Deque是一种两端队列，两端都可以取出元素，具体的实现有ArrayDeque和LinkedBlockingDeque</li>
<li>就好像BlockingQueue非常适合producer-consumer模式，Deque非常适合work stealing设计模式。producer-consumer设计对所有消费者使用一个共享的工作队列；在work stealing设计中，每个消费者都有自己的deque。如果一个消费者耗尽了自己的deque中的工作，它可以从其他消费者的deque尾部窃取工作</li>
</ol>
<h2 id="Blocking-and-interruptible-methods"><a href="#Blocking-and-interruptible-methods" class="headerlink" title="Blocking and interruptible methods"></a>Blocking and interruptible methods</h2><ol>
<li>BlockingQueue的put和take方法会抛出InterrupedException。如果一个线程抛出InterrupedException，首先代表着这个方法是一个阻塞的方法，另外代表着此刻这个方法被中断了。我们的程序要处理InterrupedException，绝对不能直接将它吞掉</li>
<li>一般面对InterrupedException的处理方法有两种</li>
</ol>
<ul>
<li>Propagate the InterruptedException：也就是把InterruptedException层层向上抛出</li>
<li>Restore the interrupt：有的时候，由于我们无法直接在线程里面抛出异常，比如在Runnable的run()方法是无法抛出异常的，这个时候我们可以让当前线程中断来恢复异常，例子如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line">    BlockingQueue&lt;Task&gt; queue;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            processTask(queue.take());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// restore interrupted status</span></span><br><span class="line">            Thread.currentThread().interrupt(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Synchronizers"><a href="#Synchronizers" class="headerlink" title="Synchronizers"></a>Synchronizers</h2><ol>
<li>同步器是一种用于控制多个线程之间协同工作和同步的机制。同步器可用于确保线程安全、避免竞态条件以及实现线程之间的协作，前面我们介绍的BlocikingQueue就可以用作同步器</li>
</ol>
<h3 id="Latches"><a href="#Latches" class="headerlink" title="Latches"></a>Latches</h3><ol>
<li>Latch同步器用于阻塞线程的运行，直到Latch到达它的termination状态</li>
<li>一个使用CountingDownLatch的例子<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123; </span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        startGate.await();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            task.run();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            endGate.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123; &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime(); </span><br><span class="line">        startGate.countDown(); </span><br><span class="line">        endGate.await();</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime(); </span><br><span class="line">        <span class="keyword">return</span> end-start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><ol>
<li>FutureTask实现了Futurn和Runnable类，常被用作进行异步计算任务，一个FutureTask有三种状态：completion, cancellation, exception，一旦进入completion状态就不可以改变了，所以一个FutureTask如果任务完成以后不能再次启动或取消</li>
<li>使用FutureTask预加载数据的例子<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Preloader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;ProductInfo&gt; future = <span class="keyword">new</span> FutureTask&lt;ProductInfo&gt;(<span class="keyword">new</span> Callable&lt;ProductInfo&gt;() &#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> DataLoadException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> loadProductInfo(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(future);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; thread.start(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> DataLoadException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        Throwable cause = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> DataLoadException)</span><br><span class="line">            <span class="keyword">throw</span> (DataLoadException) cause; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(cause);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** If the Throwable is an Error, throw it; </span></span><br><span class="line"><span class="comment">    if it is a RuntimeException return it, </span></span><br><span class="line"><span class="comment">    otherwise throw IllegalStateException */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RuntimeException <span class="title">launderThrowable</span><span class="params">(Throwable t)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException)</span><br><span class="line">            <span class="keyword">return</span> (RuntimeException) t; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error)</span><br><span class="line">            <span class="keyword">throw</span> (Error) t;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Not unchecked&quot;</span>, t);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Semaphores-信号量"><a href="#Semaphores-信号量" class="headerlink" title="Semaphores(信号量)"></a>Semaphores(信号量)</h3><ol>
<li>Counting semaphores是被用来控制可以同时访问同一资源或者进行某些动作的同步器。信号量在构造的时候会传入一个初始的允许值(permit)，使用的时候可以acquire或者release信号量(acquire会将permit减1，release会将permit加1)。当尝试去acquire信号量，但是没有permit的时候，acquire方法会阻塞</li>
<li>Binary semaphore(permit初始值是1)是一种不可重入的锁</li>
<li>信号量常被用于实现一些资源池，比如数据库连接池，当然我们可以很简单的实现一个固定大小的连接池，只要池子里没有多余的连接，我们就让请求失败，但是更好的实现方式是使用信号量，如果池子里没有多余的可用连接，就让请求阻塞，直到别的线程release连接</li>
<li>下面的例子使用信号量来bound collection(当然我们可以直接使用blocking queue，这里只是为了证明Semaphores)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;()); </span><br><span class="line">        sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">        sem.acquire();</span><br><span class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wasAdded = set.add(o);</span><br><span class="line">            <span class="keyword">return</span> wasAdded;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wasAdded)</span><br><span class="line">                sem.release();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">boolean</span> wasRemoved = set.remove(o); </span><br><span class="line">        <span class="keyword">if</span> (wasRemoved)</span><br><span class="line">            sem.release();</span><br><span class="line">        <span class="keyword">return</span> wasRemoved;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Barriers"><a href="#Barriers" class="headerlink" title="Barriers"></a>Barriers</h3><ol>
<li>Barrier允许一组线程互相等待，直到到达某个公共屏障点。一旦所有线程都到达这个点，屏障就会打破，所有线程可以继续执行。Latch和Barrier的区别点是Latch等待的是event，Barrier等待的是其他的线程ready</li>
<li>Barrier的例子，使用子线程计算subboard的值，都计算结束以后Barrier在计算总的结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CellularAutomata</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Board mainBoard; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Worker[] workers;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CellularAutomata</span><span class="params">(Board board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainBoard = board;</span><br><span class="line">        <span class="keyword">int</span> count = Runtime.getRuntime().availableProcessors(); </span><br><span class="line">        <span class="keyword">this</span>.barrier = <span class="keyword">new</span> CyclicBarrier(count,</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        mainBoard .commitNewValues (); &#125;&#125;);</span><br><span class="line">        <span class="keyword">this</span>.workers = <span class="keyword">new</span> Worker[count]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            workers[i] = <span class="keyword">new</span> Worker(mainBoard.getSubBoard(count, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Board board;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Board board)</span> </span>&#123; <span class="keyword">this</span>.board = board; &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!board.hasConverged()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; board.getMaxX(); x++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; board.getMaxY(); y++) </span><br><span class="line">                        board.setNewValue(x, y, computeValue(x, y));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; </span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException ex) &#123; </span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workers.length; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(workers[i]).start(); </span><br><span class="line">        mainBoard .waitForConvergence ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Building-an-efficient-scalable-result-cache"><a href="#Building-an-efficient-scalable-result-cache" class="headerlink" title="Building an efficient, scalable result cache"></a>Building an efficient, scalable result cache</h2><ol>
<li>这一节介绍了如何构建一个用于Servlet使用的in memory cache，同时需要保证cache的线程安全和性能</li>
<li>最简单的思路就是使用HashMap加上synchronized，但是这种cache的性能很低，因为同一时间只能有一个线程访问cache<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">String</span>, <span class="title">BigInteger</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigInteger <span class="title">compute</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// after deep thought...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(arg); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer1</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> HashMap&lt;A, V&gt;(); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer1</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个很简单的提升思路就是使用ConcurrentHashMap，由于ConcurrentHashMap是线程安全的，所以不需要synchronized，这样的话多个线程都可以访问cache。但是这种实现也有一个问题，如果一个线程已经开始计算缓存k1，这个时候另外一个线程也进来想要计算缓存k1，那么这两个线程都会进行计算，导致额外的资源浪费<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer2</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;A, V&gt;(); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer2</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123; <span class="keyword">this</span>.c = c; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = c.compute(arg);</span><br><span class="line">            cache.put(arg, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>进一步的提升是使用ConcurrentHashMap + Future，这样如果第二个线程进来想要计算同样的k1，就只会返回一个Future，当计算结束以后可以通过Future.get()获取结果。这种实现仍会有一点小瑕疵，就是极低的概率下，两个线程都进行if语句的判断，发现cache不存在，都构建了Future进行计算，造成的原因是这里是一个compute-if-present操作，但不是原子的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer3</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, Future&lt;V&gt;&gt; cache = </span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;A,Future&lt;V&gt;&gt;(); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A, V&gt; c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer3</span><span class="params">(Computable&lt;A, V&gt; c)</span> </span>&#123; <span class="keyword">this</span>.c = c; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(<span class="keyword">final</span> A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">        Future&lt;V&gt; f = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Callable&lt;V&gt; eval = <span class="keyword">new</span> Callable&lt;V&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> c.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;V&gt;(eval); </span><br><span class="line">            f = ft;</span><br><span class="line">            cache.put(arg, ft);</span><br><span class="line">            ft.run(); <span class="comment">// call to c.compute happens here</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                cache.remove(arg, f);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause()); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Task-Execution"><a href="#Task-Execution" class="headerlink" title="Task Execution"></a>Task Execution</h1><h2 id="Executing-tasks-in-threads"><a href="#Executing-tasks-in-threads" class="headerlink" title="Executing tasks in threads"></a>Executing tasks in threads</h2><ol>
<li>大多数的web server都把每个请求当成一个task，各个请求之间互不影响，通过明确task的边界，并且定义合理的task execution policy，我们可以让task更高效的执行</li>
</ol>
<h3 id="Executing-tasks-sequentially"><a href="#Executing-tasks-sequentially" class="headerlink" title="Executing tasks sequentially"></a>Executing tasks sequentially</h3><ol>
<li>最简单的方式就是串行的执行task，但是这种方式的效率太低</li>
</ol>
<h3 id="Explicitly-creating-threads-for-tasks"><a href="#Explicitly-creating-threads-for-tasks" class="headerlink" title="Explicitly creating threads for tasks"></a>Explicitly creating threads for tasks</h3><ol>
<li>稍微提升的办法是每来一个task，我们都建立一个新的线程来处理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept(); </span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Disadvantages-of-unbounded-thread-creation"><a href="#Disadvantages-of-unbounded-thread-creation" class="headerlink" title="Disadvantages of unbounded thread creation"></a>Disadvantages of unbounded thread creation</h3><ol>
<li>无限制的建立线程有以下缺点</li>
</ol>
<ul>
<li>Thread lifecycle overhead：线程创建与销毁会消耗资源</li>
<li>Resource consumption：线程数太多会造成大量资源浪费在上下文切换</li>
<li>Stability：线程数有上限，超过会out of memory</li>
</ul>
<h2 id="The-Executor-framework"><a href="#The-Executor-framework" class="headerlink" title="The Executor framework"></a>The Executor framework</h2><ol>
<li>类比于前面我们提到过的BlockQueue，使用线程池对于管理线程也是很有益的，Java提供的Executor可以让我们很方便的创建和使用线程池。Executor接口如下。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Executor基于producer-consumer设计模式，提交任务的是生产者，执行任务的是消费者，使用Executor是一种最简单的使用producer-consumer设计模式的方法</li>
</ol>
<h3 id="Example-web-server-using-Executor"><a href="#Example-web-server-using-Executor" class="headerlink" title="Example: web server using Executor"></a>Example: web server using Executor</h3><ol>
<li>以下是一个使用Java内置的标准Executor实现(一个100大小的固定线程池)的例子。由于使用了Executor，我们把一个Runnable任务的提交和执行解耦开来了。如果我们想要修改执行的方式，只需要修改Executor即可，这样的改动是很小的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutionWebServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exec = </span><br><span class="line">        Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;                 </span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept(); </span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(task);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>比如我们可以修改TaskExecutionWebServer的Executor，不使用前面的100大小标准线程池，而是每个请求创建一个新线程，这样就类似与我们前面的为每个请求创建新线程的例子。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当然，我们也可以修改Executor，让它只单线程的串行执行请求<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithinThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        r.run(); </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
所以上面两个例子证明了Executor模式下可以通过简单的修改Executor即可达到对任务的控制，不需要修改别的代码</li>
</ol>
<h3 id="Execution-policies"><a href="#Execution-policies" class="headerlink" title="Execution policies"></a>Execution policies</h3><ol>
<li><strong>把任务的提交和执行解耦的最大好处就是我们可以自由的控制执行策略</strong></li>
</ol>
<ul>
<li>In what thread will tasks be executed?</li>
<li>In what order should tasks be executed (FIFO, LIFO, priority order)?</li>
<li>How many tasks may execute concurrently?</li>
<li>How many tasks may be queued pending execution?</li>
<li>If a task has to be rejected because the system is overloaded, which task should be selected as the victim, and how should the application be noti- fied?</li>
<li>What actions should be taken before or after executing a task?</li>
</ul>
<h3 id="Thread-pools"><a href="#Thread-pools" class="headerlink" title="Thread pools"></a>Thread pools</h3><ol>
<li>线程池总是和一个工作队列绑定在一起，工作队列里面存储着等待执行的任务，线程池负责提供空闲的线程执行任务。线程池的优势在于不需要每次处理请求的时候都浪费资源去创建和销毁线程</li>
<li>Java内置的一些线程池</li>
</ol>
<ul>
<li>newFixedThreadPool. A fixed-size thread pool creates threads as tasks are sub- mitted, up to the maximum pool size, and then attempts to keep the pool size constant (adding new threads if a thread dies due to an unexpected Exception).</li>
<li>newCachedThreadPool. A cached thread pool has more flexibility to reap idle threads when the current size of the pool exceeds the demand for processing, and to add new threads when demand increases, but places no bounds on the size of the pool.</li>
<li>newSingleThreadExecutor. A single-threaded executor creates a single worker thread to process tasks, replacing it if it dies unexpectedly. Tasks are guaranteed to be processed sequentially according to the order imposed by the task queue (FIFO, LIFO, priority order).</li>
<li>newScheduledThreadPool. A fixed-size thread pool that supports delayed and periodic task execution, similar to Timer. (See Section 6.2.5.)</li>
</ul>
<h3 id="Executor-lifecycle"><a href="#Executor-lifecycle" class="headerlink" title="Executor lifecycle"></a>Executor lifecycle</h3><ol>
<li>前面我们介绍了如何使用建立Executor并执行任务，但是我们没有介绍如何关闭掉Executor。为了管理Executor的生命周期，Java在Executor类的基础上扩展了ExecutorService类，并提供了生命周期的管理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">// ... additional convenience methods for task submission</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ExecutorService 暗示的生命周期有三个状态：运行中、正在关闭和已终止。ExecutorService 最初是在运行状态创建的。shutdown 方法启动了一个优雅的关闭过程：不再接受新任务，但允许先前提交的任务完成，包括那些尚未开始执行的任务。shutdownNow 方法启动了一个突然的关闭过程：它尝试取消未完成的任务，并且不启动那些已排队但尚未开始执行的任务。</li>
<li>使用ExecutorService管理生命周期的例子<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleWebServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = ...;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>); </span><br><span class="line">        <span class="keyword">while</span> (!exec.isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Socket conn = socket.accept(); </span><br><span class="line">                exec.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; handleRequest(conn); &#125; </span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123; </span><br><span class="line">                <span class="keyword">if</span> (!exec.isShutdown())</span><br><span class="line">                    log(<span class="string">&quot;task submission rejected&quot;</span>, e);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123; exec.shutdown(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket connection)</span> </span>&#123; </span><br><span class="line">        Request req = readRequest(connection); </span><br><span class="line">        <span class="keyword">if</span> (isShutdownRequest(req))</span><br><span class="line">            stop(); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dispatchRequest (req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Delayed-and-periodic-tasks"><a href="#Delayed-and-periodic-tasks" class="headerlink" title="Delayed and periodic tasks"></a>Delayed and periodic tasks</h3><ol>
<li>对于延迟的或者周期性的任务，使用newScheduledThreadPool而不是timer</li>
</ol>
<h2 id="Finding-exploitable-parallelism"><a href="#Finding-exploitable-parallelism" class="headerlink" title="Finding exploitable parallelism"></a>Finding exploitable parallelism</h2><ol>
<li>本章通过一个页面加载html的例子来展示不同程度的并发度</li>
</ol>
<h3 id="Example-sequential-page-renderer"><a href="#Example-sequential-page-renderer" class="headerlink" title="Example: sequential page renderer"></a>Example: sequential page renderer</h3><ol>
<li>最简单的实现就是串行处理html文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadRenderer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        renderText(source);</span><br><span class="line">        List&lt;ImageData&gt; imageData = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (ImageInfo imageInfo : scanForImageInfo(source))</span><br><span class="line">            imageData .add(imageInfo .downloadImage ()); </span><br><span class="line">        <span class="keyword">for</span> (ImageData data : imageData)</span><br><span class="line">            renderImage(data);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Result-bearing-tasks-Callable-and-Future"><a href="#Result-bearing-tasks-Callable-and-Future" class="headerlink" title="Result-bearing tasks: Callable and Future"></a>Result-bearing tasks: Callable and Future</h3><ol>
<li>Runnable vs Callable: The Callable interface is similar to Runnable, in that both are designed for classes whose instances are potentially executed by another thread. <strong>A Runnable, however, does not return a result and cannot throw a checked exception.</strong> 说白了就是Java1.0以来一直有Runnable，但是Runnable不能有返回值，也不能抛出异常，但是对于有些并行任务是需要返回值和异常的，所以后面又提出了Callable(<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/141284/the-difference-between-the-runnable-and-callable-interfaces-in-java">https://stackoverflow.com/questions/141284/the-difference-between-the-runnable-and-callable-interfaces-in-java</a>)</li>
<li>Runnable和Callable都是用来描述可以计算的任务，而任务的生物周期是由Future接口来表现的。Future接口提供了方法查看一个任务是否完成或者取消<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, CancellationException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException,ExecutionException, CancellationException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>那么如何创建一个Future去描述一个任务呢？ExecutorService类的submit方法可以接收Callable或者Runnable，然后返回一个Future。或者我们可以显式的直接实现一个FutureTask，FutureTask为Future接口提供了基本实现，FutureTask有两个构造方法，分别接受Callable或者Runnable</li>
</ol>
<h3 id="Example-page-renderer-with-Future"><a href="#Example-page-renderer-with-Future" class="headerlink" title="Example: page renderer with Future"></a>Example: page renderer with Future</h3><ol>
<li>作为并发改造的第一步，我们把页面加载分为两部分，一个任务用来加载文字，一个任务用来下载图片<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureRenderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = ...;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source); Callable&lt;List&lt;ImageData&gt;&gt; task = <span class="keyword">new</span> Callable&lt;List&lt;ImageData&gt;&gt;() &#123;     </span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;ImageData&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                List&lt;ImageData&gt; result = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</span><br><span class="line">                <span class="keyword">for</span> (ImageInfo imageInfo : imageInfos) </span><br><span class="line">                result.add(imageInfo.downloadImage());</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(task); </span><br><span class="line">        renderText(source);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;ImageData&gt; imageData = future.get(); </span><br><span class="line">            <span class="keyword">for</span> (ImageData data : imageData)</span><br><span class="line">                renderImage(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// Re-assert the thread’s interrupted status</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="comment">// We don’t need the result, so cancel the task too</span></span><br><span class="line">            future.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause()); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Limitations-of-parallelizing-heterogeneous-tasks"><a href="#Limitations-of-parallelizing-heterogeneous-tasks" class="headerlink" title="Limitations of parallelizing heterogeneous tasks"></a>Limitations of parallelizing heterogeneous tasks</h3><ol>
<li>上面的改造看似进行了并行处理，但是只是对不同类型的任务做了并行(加载文字和下载图片)，但其实网页加载占据大部分时间的是图片下载，所以即使我们对不同类型的任务做了并行，也不一定会有很大的提升。想要进一步提升并行度，就需要对相同类型的任务做并行处理</li>
</ol>
<h3 id="CompletionService-Executor-meets-BlockingQueue"><a href="#CompletionService-Executor-meets-BlockingQueue" class="headerlink" title="CompletionService: Executor meets BlockingQueue"></a>CompletionService: Executor meets BlockingQueue</h3><ol>
<li>我们如果想要获取一系列提交到Executor的任务的结果，可以非常枯燥的去不停地使用Future.get()来尝试获取结果，但是Java提供了一个更简单的方法，使用CompletionService，它可以把完成的Future自动的放到一个存储结果的BlockingQueue里面</li>
<li>ExecutorService = incoming queue + worker threads<br>CompletionService = incoming queue + worker threads + output queue</li>
</ol>
<h3 id="Example-page-renderer-with-CompletionService"><a href="#Example-page-renderer-with-CompletionService" class="headerlink" title="Example: page renderer with CompletionService"></a>Example: page renderer with CompletionService</h3><ol>
<li>使用CompletionService来处理每一个图片的下载，也即把每一个图片下载都当成一个独立的任务<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line">    Renderer(ExecutorService executor) &#123; <span class="keyword">this</span>.executor = executor; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123; </span><br><span class="line">        List&lt;ImageInfo&gt; info = scanForImageInfo(source); CompletionService&lt;ImageData&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;ImageData&gt;(executor); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ImageInfo imageInfo : info)</span><br><span class="line">            completionService.submit(<span class="keyword">new</span> Callable&lt;ImageData&gt;() &#123; </span><br><span class="line">                <span class="function"><span class="keyword">public</span> ImageData <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> imageInfo.downloadImage(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        renderText(source);</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>, n = info.size(); t &lt; n; t++) &#123;</span><br><span class="line">                Future&lt;ImageData&gt; f = completionService.take(); </span><br><span class="line">                ImageData imageData = f.get(); </span><br><span class="line">                renderImage(imageData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123; </span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Placing-time-limits-on-tasks"><a href="#Placing-time-limits-on-tasks" class="headerlink" title="Placing time limits on tasks"></a>Placing time limits on tasks</h3><ol>
<li>有的时候我们不想无限制的等待一个任务的结束，比如一个页面加载广告的时候，如果超过两秒还没有收到广告服务器的回复，那么就加载默认的广告。Future接口提供了<code>get(long timeout, TimeUnit unit)</code>方法，如果超过设置的timeout时间仍然没有收到结果，就会抛出TimeoutException，我们的程序可以catch TimeoutException，然后取消任务的执行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page <span class="title">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">    <span class="keyword">long</span> endNanos = System.nanoTime() + TIME_BUDGET; </span><br><span class="line">    Future&lt;Ad&gt; f = exec.submit(<span class="keyword">new</span> FetchAdTask());</span><br><span class="line">    <span class="comment">// Render the page while waiting for the ad</span></span><br><span class="line">    Page page = renderPageBody(); </span><br><span class="line">    Ad ad;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Only wait for the remaining time budget</span></span><br><span class="line">        <span class="keyword">long</span> timeLeft = endNanos - System.nanoTime();</span><br><span class="line">        ad = f.get(timeLeft, NANOSECONDS); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        ad = DEFAULT_AD;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        ad = DEFAULT_AD;</span><br><span class="line">        f.cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    page.setAd(ad);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Example-a-travel-reservations-portal"><a href="#Example-a-travel-reservations-portal" class="headerlink" title="Example: a travel reservations portal"></a>Example: a travel reservations portal</h3><ol>
<li>前面的例子我们只针对一个任务设置了过期时间，我们也可以对invokeAll方法设置过期时间，invokeAll如果设置了过期时间，那么会在所有的任务已经完成，被中断或者超时的情况下返回，任何没完成的任务都会被取消掉<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QuoteTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">TravelQuote</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelCompany company;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelInfo travelInfo;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TravelQuote <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> company.solicitQuote(travelInfo);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TravelQuote&gt; <span class="title">getRankedTravelQuotes</span><span class="params">(TravelInfo travelInfo, Set&lt;TravelCompany&gt; companies, Comparator&lt;TravelQuote&gt; ranking, <span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    List&lt;QuoteTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;QuoteTask&gt;(); </span><br><span class="line">    <span class="keyword">for</span> (TravelCompany company : companies)</span><br><span class="line">        tasks.add(<span class="keyword">new</span> QuoteTask(company, travelInfo)); </span><br><span class="line">        </span><br><span class="line">    List&lt;Future&lt;TravelQuote&gt;&gt; futures = exec.invokeAll(tasks, time, unit);</span><br><span class="line">    List&lt;TravelQuote&gt; quotes = <span class="keyword">new</span> ArrayList&lt;TravelQuote&gt;(tasks.size());</span><br><span class="line">    Iterator&lt;QuoteTask&gt; taskIter = tasks.iterator(); </span><br><span class="line">    <span class="keyword">for</span> (Future&lt;TravelQuote&gt; f : futures) &#123;</span><br><span class="line">        QuoteTask task = taskIter.next(); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            quotes.add(f.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            quotes.add(task.getFailureQuote (e.getCause())); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">            quotes.add(task.getTimeoutQuote (e)); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(quotes, ranking);</span><br><span class="line">    <span class="keyword">return</span> quotes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Cancellation-and-Shutdown"><a href="#Cancellation-and-Shutdown" class="headerlink" title="Cancellation and Shutdown"></a>Cancellation and Shutdown</h1><ol>
<li>前面几章我们介绍了线程的创建和启动，但是没有介绍如何停止或者取消线程。Java提供了一种合作机制来停止线程：中断</li>
</ol>
<h2 id="Task-cancellation"><a href="#Task-cancellation" class="headerlink" title="Task cancellation"></a>Task cancellation</h2><ol>
<li>Java语言中，没有安全的方式可以抢占式的停止一个线程或者任务，想要安全的停止一个线程，只能使用合作的方式，即运行的线程和停止执行的代码遵循事先达成的协议。一种最简单的协议是使用一个”cancellation requested flag”，例子如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes</span><br><span class="line">            = <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInteger p = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span> (!cancelled) &#123;</span><br><span class="line">            p = p.nextProbablePrime();</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                primes.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;BigInteger&gt; <span class="title">aSecondOfPrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PrimeGenerator generator = <span class="keyword">new</span> PrimeGenerator();</span><br><span class="line">        exec.execute(generator);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            generator.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generator.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>从上面这个例子可以看出来，想要取消一个线程或者任务，我们需要定义一个cancellation policy来说明：在什么时候，以怎样的方式，取消什么任务。</li>
</ol>
<h3 id="Interruption"><a href="#Interruption" class="headerlink" title="Interruption"></a>Interruption</h3><ol>
<li><strong>前面PrimeGenerator有一个很严重的问题：如果我们是想要需要一个阻塞的方法，比如BlockingQueue.put，那么前面的例子并不适用。</strong>这种情况下我们就应该使用Java自带的取消机制：中断</li>
<li>以下是一个阻塞方法不适用前面”cancellation requested flag”的例子，如果queue已经满了，那么<code>queue.put</code>会一直阻塞下去，我们的<code>cancel()</code>方法不起作用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span> (!cancelled)</span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException consumed) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>每一个线程都有一个interrupted状态，当一个线程被中断，interrupted状态会被设置为true。Thread类提供了进行中断或者查询interrupted状态的方法：<code>interrupt()</code>方法会中断目标线程；<code>isInterrupted()</code>方法会返回一个线程的interrupted状态；<code>interrupted()</code>方法会清除当前线程的interrupted状态，并返回清除前的状态，这是Java提供的唯一一种清除interrupted状态的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123; ... &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123; ... &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一些阻塞的内置方法，比如<code>Thread.sleep</code>和<code>Object.wait</code>会去检测线程是否中断，如果发现中断，那么会清除interrupted状态，并且抛出InterruptedException，表明阻塞的操作由于中断而提前结束了</li>
<li>如果一个线程不是阻塞的，那么对这个线程的中断只是起到把interrupted状态设为true的作用，如果线程本身不处理，那么会一直保留interrupted状态</li>
<li><strong>所以说白了，中断其实就是针对Java中那些阻塞的方法的，可以让这些方法取消执行，然后通过抛出InterruptedException告诉调用的类：你调用的阻塞方法被中断了</strong></li>
<li><code>interrupted()</code>使用的时候要格外谨慎，如果它的返回值是true，代表清除之前的interrupted状态是true，这个时候一定要抛出InterruptedException</li>
<li>使用中断修复之前的例子：这里的<code>Thread.currentThread().isInterrupted()</code>不是一定需要的，因为本身<code>queue.put</code>就会接收中断信号。这里的好处是使得程序对于中断的响应更快，也就是在进入耗时比较长的质数计算之前先检测一下interrupted状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line"></span><br><span class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())</span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException consumed) &#123;</span><br><span class="line">            <span class="comment">/* Allow thread to exit */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Interruption-policies"><a href="#Interruption-policies" class="headerlink" title="Interruption policies"></a>Interruption policies</h3><ol>
<li>类似于任务应该定义好cancellation policy，线程也应该定义好自己的interruption policy。我们需要区分好任务和线程对于中断的反应，很多时候一个中断信号不止会取消任务，也会关闭线程</li>
<li>对于那种只是在线程中执行，但是不拥有线程的所有权的任务，比如在线程池中执行Java自带的阻塞库，往往任务只会catch InterruptedException然后继续抛出，因为它们并不拥有线程的所有权</li>
<li>由于每个线程都有自己的中断策略，除非你知道对于该线程而言中断意味着什么，否则不应该中断一个线程。</li>
</ol>
<h3 id="Responding-to-interruption"><a href="#Responding-to-interruption" class="headerlink" title="Responding to interruption"></a>Responding to interruption</h3><ol>
<li>当我们使用可以中断的阻塞类库，比如<code>Thread.sleep</code>和<code>BlockingQueue.put</code>，往往有两种常见的办法处理InterruptedException：</li>
</ol>
<ul>
<li>Propagate the exception (possibly after some task-specific cleanup), making your method an interruptible blocking method, too; or</li>
<li>Restore the interruption status so that code higher up on the call stack can deal with it.</li>
</ul>
<ol start="2">
<li>第一种方法向上传播异常很简单<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;Task&gt; queue;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.take(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果不能直接向上传播，比如在一个Runnable中不能抛异常，那么需要使用<code>Thread.currentThread().interrupt();</code>来保证中断不被吞掉</li>
</ol>
<h3 id="Example-timed-run"><a href="#Example-timed-run" class="headerlink" title="Example: timed run"></a>Example: timed run</h3><ol>
<li>前面例子中的的PrimeGenerator里的aSecondOfPrimes方法会开启计算质数并在一秒钟后取消，但是有一个问题，我们无法获取计算质数的任务是否抛出异常</li>
<li>为了解决这个问题，我们下面例子的timedRun方法会起一个子线程用来中断任务，而任务的执行放在主线程，这样我们就可以在主线程中进行异常的检查。这样看起来很美好，但违背了前面我们讨论的原则：中断的线程必须清除被中断线程的中断原则。子线程的中断任务执行的时候，我们已经对主线程在干嘛一无所知，有可能runnable任务已经执行完，此刻中断信号才进来，而此时主线程可能已经在执行别的代码了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService cancelExec = Executors。newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread taskThread = Thread.currentThread();</span><br><span class="line">    cancelExec.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            taskThread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeout, unit);</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>提升的版本我们分别用两个子线程分别执行RethrowableTask任务和中断任务，同时使用Thread.join等待RethrowableTask任务，join以后再抛出catch到的异常。这个方法的问题是我们需要依赖join的timeout，如果最后没有异常抛出，我们无法判断是任务正常执行还是join超时了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedRun2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService cancelExec = newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(<span class="keyword">final</span> Runnable r,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">RethrowableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">volatile</span> Throwable t;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.t = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">rethrow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> launderThrowable(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RethrowableTask task = <span class="keyword">new</span> RethrowableTask();</span><br><span class="line">        <span class="keyword">final</span> Thread taskThread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        taskThread.start();</span><br><span class="line">        cancelExec.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                taskThread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, timeout, unit);</span><br><span class="line">        taskThread.join(unit.toMillis(timeout));</span><br><span class="line">        task.rethrow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Cancellation-via-Future"><a href="#Cancellation-via-Future" class="headerlink" title="Cancellation via Future"></a>Cancellation via Future</h3><ol>
<li>前面我们已经使用过Future来管理任务的生命周期，所以这里我们也可以使用Future来完成任务的取消，<code>Future.get(boolean mayInterruptIfRunning)</code>方法可以接收一个boolean值来向执行的任务发送中断信号，由于通过Executor提交的任务线程的中断策略是取消任务，所以我们可以安全的把mayInterruptIfRunning设置为true来进行Executor里面执行任务的中断。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedRun</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService taskExec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Future&lt;?&gt; task = taskExec.submit(r);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            task.get(timeout, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="comment">// task will be cancelled below</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="comment">// exception thrown in task; rethrow</span></span><br><span class="line">            <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Harmless if task already completed</span></span><br><span class="line">            task.cancel(<span class="keyword">true</span>); <span class="comment">// interrupt if running</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>以上的例子在遇到TimeoutException和InterruptedException的时候会执行<code>task.cancel(true)</code>来取消任务，同时对于InterruptedException，中断会继续传播到timedRun的caller，在遇到其他ExecutionException的时候会把异常继续抛出</li>
</ol>
<h3 id="Dealing-with-non-interruptible-blocking"><a href="#Dealing-with-non-interruptible-blocking" class="headerlink" title="Dealing with non-interruptible blocking"></a>Dealing with non-interruptible blocking</h3><ol>
<li>前面我们提到了例如<code>Thread.sleep</code>等阻塞方法可以被中断，但是Java还有一些阻塞的场景没有实现中断</li>
</ol>
<ul>
<li>Synchronous socket I/O in java.io. The common form of blocking I/O in server applications is reading or writing to a socket. Unfortunately, the read and write methods in InputStream and OutputStream are not re- sponsive to interruption, but closing the underlying socket makes any threads blocked in read or write throw a SocketException.</li>
<li>Synchronous I/O in java.nio. Interrupting a thread waiting on an Interrupt- ibleChannel causes it to throw ClosedByInterruptException and close the channel (and also causes all other threads blocked on the channel to throw ClosedByInterruptException). Closing an InterruptibleChannel causes threads blocked on channel operations to throw AsynchronousCloseExcep- tion. Most standard Channels implement InterruptibleChannel.</li>
<li>Asynchronous I/O with Selector. If a thread is blocked in Selector.select (in java.nio.channels), calling close or wakeup causes it to return prema- turely.</li>
<li>Lock acquisition. If a thread is blocked waiting for an intrinsic lock, there is nothing you can do to stop it short of ensuring that it eventually acquires the lock and makes enough progress that you can get its attention some other way. However, the explicit Lock classes offer the lockInterruptib- ly method, which allows you to wait for a lock and still be responsive to interrupts—see Chapter 13.</li>
</ul>
<h2 id="Stopping-a-thread-based-service"><a href="#Stopping-a-thread-based-service" class="headerlink" title="Stopping a thread-based service"></a>Stopping a thread-based service</h2><ol>
<li>Java应用往往不会直接创建线程，而是通过创建服务(比如线程池)来管理线程。由于线程的所有权具有不可传递性，服务建立的线程，我们不能直接在应用中停止它，而是还是需要通过服务来停止。</li>
</ol>
<h3 id="Example-a-logging-service"><a href="#Example-a-logging-service" class="headerlink" title="Example: a logging service"></a>Example: a logging service</h3><ol>
<li>以一个producer-consumer模式的日志服务举例，以下的代码通过中断达到停止日志服务的目的，但是这种实现有一个问题：当作为consumer的LoggerThread被中断的时候，作为producer的LogWritter并不知道，还是会一直往queue里面发日志直到阻塞<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogWriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread logger;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogWriter</span><span class="params">(Writer writer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(CAPACITY);</span><br><span class="line">        <span class="keyword">this</span>.logger = <span class="keyword">new</span> LoggerThread(writer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        queue.put(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> PrintWriter writer;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LoggerThread</span><span class="params">(Writer writer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.writer = <span class="keyword">new</span> PrintWriter(writer, <span class="keyword">true</span>); <span class="comment">// autoflush</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                    writer.println(queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个进阶版的实现：这里没有直接同步<code>log</code>方法，而是只是同步isShutdown状态的改变，好处是这样的同步没有带上<code>queue.put(msg)</code>，BlockingQueue本身就是线程安全的，我们再往其上面加锁只会导致锁的力度太大。<strong>另外这里使用reservation变量，可以保证当停止日志服务的时候，queue里剩余的日志都会被处理完毕，随后writer才会关闭，随后LoggerThread停止</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread loggerThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PrintWriter writer;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">boolean</span> isShutdown;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="keyword">private</span> <span class="keyword">int</span> reservations;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogService</span><span class="params">(Writer writer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">        <span class="keyword">this</span>.loggerThread = <span class="keyword">new</span> LoggerThread();</span><br><span class="line">        <span class="keyword">this</span>.writer = <span class="keyword">new</span> PrintWriter(writer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        loggerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            isShutdown = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        loggerThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShutdown)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="comment">/*...*/</span>);</span><br><span class="line">            ++reservations;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.put(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (LogService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (isShutdown &amp;&amp; reservations == <span class="number">0</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        String msg = queue.take();</span><br><span class="line">                        <span class="keyword">synchronized</span> (LogService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                            --reservations;</span><br><span class="line">                        &#125;</span><br><span class="line">                        writer.println(msg);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; <span class="comment">/* retry */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="ExecutorService-shutdown"><a href="#ExecutorService-shutdown" class="headerlink" title="ExecutorService shutdown"></a>ExecutorService shutdown</h3><ol>
<li>ExecutorService提供两种停止方法：shutdown和shutdownNow。shutdownNow会立刻停止ExecutorService，但是会存在执行到一般的任务被打断，shutdown会把queue中所有的任务执行完成以后才会停止</li>
<li>使用ExecutorService的日志服务<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = newSingleThreadExecutor(); ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exec.shutdown();</span><br><span class="line">            exec.awaitTermination(TIMEOUT, UNIT);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> WriteTask(msg));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException ignored) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Poison-pills"><a href="#Poison-pills" class="headerlink" title="Poison pills"></a>Poison pills</h3></li>
<li>对于producer-consumer模式的服务，还有一种办法可以优雅的停止，当想要停止服务的时候，我们通过producer放入一个POISON到queue中，然后producer不再放入数据；当consumer收到POISON的时候，停止线程执行</li>
</ol>
<h3 id="Limitations-of-shutdownNow"><a href="#Limitations-of-shutdownNow" class="headerlink" title="Limitations of shutdownNow"></a>Limitations of shutdownNow</h3><ol>
<li>shutdownNow方法会取消正在执行的任务，并且返回所有提交到ExecutionService，但还没有开始执行的任务。一个很严重的缺陷是上述的返回值中不包括取消的正在执行的任务。</li>
</ol>
<h2 id="Handling-abnormal-thread-termination"><a href="#Handling-abnormal-thread-termination" class="headerlink" title="Handling abnormal thread termination"></a>Handling abnormal thread termination</h2><ol>
<li>子线程在运行的过程中可能遇到异常，我们可以主动的处理异常，同时通知主线程发生的异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) runTask(getTaskFromWorkQueue ());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123; </span><br><span class="line">        thrown = e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadExited(<span class="keyword">this</span>, thrown);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Uncaught-exception-handlers"><a href="#Uncaught-exception-handlers" class="headerlink" title="Uncaught exception handlers"></a>Uncaught exception handlers</h3><ol>
<li>上一章我们介绍了如何主动处理线程运行过程中的异常，Java线程同样也提供了UncaughtExceptionHandler机制来处理异常，默认的UncaughtExceptionHandler会把stack trace打印到system.err</li>
<li>需要注意的是，UncaughtExceptionHandler只对<code>Executor.execute(Runnable r)</code>起作用，对于<code>Future f = ExecutionService.submit(Runnable or Callable)</code>不起作用，相应的异常被包裹在ExecutionException中，通过<code>Future.get</code>来获取</li>
</ol>
<h2 id="JVM-shutdown"><a href="#JVM-shutdown" class="headerlink" title="JVM shutdown"></a>JVM shutdown</h2><ol>
<li>JVM有两种停止的方式：正常和突然。正常的关闭通过最后一个非守护线程调用<code>System.exit</code>，或者发送SIGINT信号或使用Ctrl-C；突然的关闭通过调用<code>Runtime.halt</code>或者操作系统直接杀死JVM进程</li>
</ol>
<h3 id="Shutdown-hooks"><a href="#Shutdown-hooks" class="headerlink" title="Shutdown hooks"></a>Shutdown hooks</h3><ol>
<li>JVM正常的关闭会调用所有注册的shutdown hooks，JVM并不保证shutdown hooks的执行顺序，当所有的shutdown hooks执行完毕以后，如果flag runFinalizersOnExit是true，那么JVM会执行finalizers。如果shutdown hooks和finalizers都执行完毕，那么JVM会停止；如果<br>shutdown hooks或finalizers执行遇到问题而阻塞，那么JVM需要通过突然的关闭来停止</li>
</ol>
<h3 id="Daemon-threads"><a href="#Daemon-threads" class="headerlink" title="Daemon threads"></a>Daemon threads</h3><ol>
<li>线程被分为两个种类：普通线程和守护线程，所有由主线程创建的子线程都是普通线程。当JVM停止的时候，所有守护线程会立刻停止，并不会执行finally块，所以守护线程必须是那些不需要清理的线程，常常用于进行垃圾回收或者资源清理</li>
</ol>
<h3 id="Finalizers"><a href="#Finalizers" class="headerlink" title="Finalizers"></a>Finalizers</h3><ol>
<li>finalizer方法是Java为每个对象提供的主动进行垃圾回收的办法，一般来说，程序通过使用finally块足以进行资源的回收。<strong>finalizer很容易使用错，所以避免使用它</strong></li>
</ol>
<h1 id="Applying-Thread-Pools"><a href="#Applying-Thread-Pools" class="headerlink" title="Applying Thread Pools"></a>Applying Thread Pools</h1><ol>
<li>第6章介绍了通过Executor和ExecutionService执行任务，以简化线程的使用，本章将介绍如何配置Executor和ExecutionService创建的thread pool</li>
</ol>
<h2 id="Implicit-couplings-between-tasks-and-execution-policies"><a href="#Implicit-couplings-between-tasks-and-execution-policies" class="headerlink" title="Implicit couplings between tasks and execution policies"></a>Implicit couplings between tasks and execution policies</h2><ol>
<li>不同的任务，我们ExecutionService的策略也必然需要对应的调整</li>
</ol>
<h3 id="Thread-starvation-deadlock"><a href="#Thread-starvation-deadlock" class="headerlink" title="Thread starvation deadlock"></a>Thread starvation deadlock</h3><ol>
<li>如果我们使用<code>Executors.newSingleThreadExecutor</code>，同时提交的任务依赖于提交的其他子任务，就会造成这种饥饿死锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDeadlock</span> </span>&#123;</span><br><span class="line">    ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadFileTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String fileName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LoadFileTask</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// Here&#x27;s where we would actually read the file</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderPageTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Future&lt;String&gt; header, footer;</span><br><span class="line">            header = exec.submit(<span class="keyword">new</span> LoadFileTask(<span class="string">&quot;header.html&quot;</span>));</span><br><span class="line">            footer = exec.submit(<span class="keyword">new</span> LoadFileTask(<span class="string">&quot;footer.html&quot;</span>));</span><br><span class="line">            String page = renderBody();</span><br><span class="line">            <span class="comment">// Will deadlock -- task waiting for result of subtask</span></span><br><span class="line">            <span class="keyword">return</span> header.get() + page + footer.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">renderBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Here&#x27;s where we would actually render the page</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Long-running-tasks"><a href="#Long-running-tasks" class="headerlink" title="Long-running tasks"></a>Long-running tasks</h3><ol>
<li>如果我们的任务都是耗时很长的任务，可能会导致线程资源不够用</li>
</ol>
<h2 id="Sizing-thread-pools"><a href="#Sizing-thread-pools" class="headerlink" title="Sizing thread pools"></a>Sizing thread pools</h2><ol>
<li>书中给了一个公式大概的计算合适的线程池大小</li>
</ol>
<h2 id="Configuring-ThreadPoolExecutor"><a href="#Configuring-ThreadPoolExecutor" class="headerlink" title="Configuring ThreadPoolExecutor"></a>Configuring ThreadPoolExecutor</h2><ol>
<li>Executor类提供了newCachedThreadPool, newFixedThreadPool, newScheduledThreadExecutor等默认的线程池，如果我们想要定制化自己的线程池，可以使用ThreadPoolExecutor</li>
</ol>
<h3 id="Thread-creation-and-teardown"><a href="#Thread-creation-and-teardown" class="headerlink" title="Thread creation and teardown"></a>Thread creation and teardown</h3><ol>
<li>以下是ThreadPoolExecutor的参数：corePoolSize是线程池默认维护的线程数，即使真正执行的任务数少于这个值，只有当队列满的时候，线程池才会扩容；maximumPoolSize是能扩容的最大线程数；keepAliveTime是当一个线程闲置超过这个时间，并且线程数大于corePoolSize的时候，线程会被销毁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> corePoolSize, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">    TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">    BlockingQueue&lt;Runnable&gt; workQueue, </span></span></span><br><span class="line"><span class="params"><span class="function">    ThreadFactory threadFactory, </span></span></span><br><span class="line"><span class="params"><span class="function">    RejectedExecutionHandler handler)</span> </span></span><br><span class="line"><span class="function"></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li>newFixedThreadPool会把corePoolSize和maximumPoolSize设置成相同的值，生成一个固定大小的线程池；newCachedThreadPool会把corePoolSize设置成0，maximumPoolSize设置成Integer.MAX_VALUE，keepAliveTime设置成一分钟，生成一个可以根据流量自动伸缩的线程池</li>
</ol>
<h3 id="Managing-queued-tasks"><a href="#Managing-queued-tasks" class="headerlink" title="Managing queued tasks"></a>Managing queued tasks</h3><ol>
<li>ThreadPoolExecutor允许提供一个BlockingQueue来处理进入线程池的任务，通常有三种基本策略：unbounded queue, bounded queue, and synchronous handoff</li>
</ol>
<h3 id="Saturation-policies"><a href="#Saturation-policies" class="headerlink" title="Saturation policies"></a>Saturation policies</h3><ol>
<li>如果使用的是bounded queue，那么相对应的我们需要配置饱和策略，饱和策略可以通过<code>setRejectedExecutionHandler</code>方法配置，一些提供的饱和策略有：AbortPolicy, CallerRunsPolicy, DiscardPolicy, and DiscardOldestPolicy</li>
<li>默认的abort policy会抛出RejectedExecutionException；DiscardPolicy会把新任务抛弃掉；DiscardOldestPolicy会把最老的任务抛弃掉</li>
</ol>
<h3 id="Thread-factories"><a href="#Thread-factories" class="headerlink" title="Thread factories"></a>Thread factories</h3><ol>
<li>ThreadPoolExecutor通过线程工厂创建新的线程，默认的线程工厂创建一个没有额外配置的普通线程，如果想要定制化的线程，我们可以创建自己的线程工厂</li>
</ol>
<h3 id="Customizing-ThreadPoolExecutor-after-construction"><a href="#Customizing-ThreadPoolExecutor-after-construction" class="headerlink" title="Customizing ThreadPoolExecutor after construction"></a>Customizing ThreadPoolExecutor after construction</h3><ol>
<li>ThreadPoolExecutor创建好以后，还可以通过自带的一些set方法配置前面提到的参数</li>
</ol>
<h2 id="Extending-ThreadPoolExecutor"><a href="#Extending-ThreadPoolExecutor" class="headerlink" title="Extending ThreadPoolExecutor"></a>Extending ThreadPoolExecutor</h2><ol>
<li>ThreadPoolExecutor提供了一些hooks，以方便我们扩展，包括beforeExecute, afterExecute, terminated。具体可以参考书中的例子</li>
</ol>
<h2 id="Parallelizing-recursive-algorithms"><a href="#Parallelizing-recursive-algorithms" class="headerlink" title="Parallelizing recursive algorithms"></a>Parallelizing recursive algorithms</h2><ol>
<li>对于递归的程序，可以使用并行处理，比串行处理效率高，书中有例子</li>
</ol>
<h1 id="Avoiding-Liveness-Hazards"><a href="#Avoiding-Liveness-Hazards" class="headerlink" title="Avoiding Liveness Hazards"></a>Avoiding Liveness Hazards</h1><h2 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h2><ol>
<li>哲学家就餐问题常用来讨论并行计算中多线程同步的问题：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98%E3%80%82%E5%85%B6%E4%B8%AD%E4%B8%80%E7%A7%8D%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E6%B3%95%E6%98%AF%E6%AF%8F%E4%B8%AA%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%83%BD%E5%85%88%E6%8B%BF%E8%87%AA%E5%B7%B1%E5%B7%A6%E6%89%8B%E8%BE%B9%E7%9A%84%E7%AD%B7%E5%AD%90%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E6%8B%BF%E5%8F%B3%E6%89%8B%E8%BE%B9%E7%9A%84%E7%AD%B7%E5%AD%90%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E4%BC%9A%E9%80%A0%E6%88%90%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E3%80%82%E5%9B%A0%E4%B8%BA%E5%BD%93%E4%BA%94%E4%B8%AA%E5%93%B2%E5%AD%A6%E5%AE%B6%E6%8B%BF%E4%BA%86%E8%87%AA%E5%B7%B1%E5%B7%A6%E6%89%8B%E8%BE%B9%E7%9A%84%E7%AD%B7%E5%AD%90%E4%BB%A5%E5%90%8E%EF%BC%8C%E6%A1%8C%E5%AD%90%E4%B8%8A%E7%9A%84%E4%BA%94%E6%94%AF%E7%AD%B7%E5%AD%90%E5%B0%B1%E9%83%BD%E8%A2%AB%E6%8B%BF%E5%AE%8C%E4%BA%86%EF%BC%8C%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%86%8D%E6%83%B3%E6%8B%BF%E5%8F%B3%E6%89%8B%E8%BE%B9%E7%9A%84%E7%AD%B7%E5%AD%90%E5%B0%B1%E4%BC%9A%E9%98%BB%E5%A1%9E%E4%BD%8F%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%AD%BB%E9%94%81">https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98。其中一种哲学家就餐问题的解法是每个哲学家都先拿自己左手边的筷子，然后再拿右手边的筷子，这样就会造成死锁问题。因为当五个哲学家拿了自己左手边的筷子以后，桌子上的五支筷子就都被拿完了，哲学家再想拿右手边的筷子就会阻塞住，也就是死锁</a></li>
</ol>
<h3 id="Lock-ordering-deadlocks"><a href="#Lock-ordering-deadlocks" class="headerlink" title="Lock-ordering deadlocks"></a>Lock-ordering deadlocks</h3><ol>
<li>由于使用了多个锁，且多个锁执行顺序的不同，可能导致死锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRightDeadlock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object left = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object right = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                doSomethingElse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomethingElse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>所以可以看出来死锁是由于多个锁的获取顺序不同导致的，假设程序中获取锁的顺序全是一致的，那么就会避免死锁问题</li>
</ol>
<h3 id="Dynamic-lock-order-deadlocks"><a href="#Dynamic-lock-order-deadlocks" class="headerlink" title="Dynamic lock order deadlocks"></a>Dynamic lock order deadlocks</h3><ol>
<li>有的时候死锁并不像前一个例子这样好观察到，比如下面的例子，如果我们有两个账户A和B，两个线程执行<code>transferMoney(A, B, 100)</code>和<code>transferMoney(B, A, 50)</code>，就有可能造成死锁，因为当第一个线程想要拿B账户的锁的时候，B账户的锁已经被第二个线程获取了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account fromAccount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 Account toAccount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 DollarAmount amount)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (fromAccount) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toAccount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                fromAccount.debit(amount);</span><br><span class="line">                toAccount.credit(amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>为了解决以上死锁问题，我们引入对象的hashcode，来确保获取锁的顺序是一致的，要不都是先A后B，要不都是先B后A。另外为了预防两个对象的hashcode一致(概率很低)，我们增加一个tieLock<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(<span class="keyword">final</span> Account fromAcct,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">final</span> Account toAcct,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">final</span> DollarAmount amount)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (fromAcct.getBalance().compareTo(amount) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    fromAcct.debit(amount);</span><br><span class="line">                    toAcct.credit(amount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fromHash = System.identityHashCode(fromAcct);</span><br><span class="line">        <span class="keyword">int</span> toHash = System.identityHashCode(toAcct);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromHash &lt; toHash) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromHash &gt; toHash) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (tieLock) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (fromAcct) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (toAcct) &#123;</span><br><span class="line">                        <span class="keyword">new</span> Helper().transfer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Resource-deadlocks"><a href="#Resource-deadlocks" class="headerlink" title="Resource deadlocks"></a>Resource deadlocks</h3><ol>
<li>Say you have two pooled resources, such as connection pools for two different databases. Resource pools are usually implemented with semaphores (see Section 5.5.3) to facilitate blocking when the pool is empty. If a task requires connections to both databases and the two resources are not always requested in the same order, thread A could be holding a connection to database D1 while waiting for a connection to database D2, and thread B could be holding a connection to D2 while waiting for a connection to D1</li>
<li>另外一种资源死锁是前面提到的thread-starvation deadlock</li>
</ol>
<h2 id="Avoiding-and-diagnosing-deadlocks"><a href="#Avoiding-and-diagnosing-deadlocks" class="headerlink" title="Avoiding and diagnosing deadlocks"></a>Avoiding and diagnosing deadlocks</h2><h3 id="Timed-lock-attempts"><a href="#Timed-lock-attempts" class="headerlink" title="Timed lock attempts"></a>Timed lock attempts</h3><ol>
<li>使用一个具有timeout时间的tryLock，这样即使出现死锁，timeout结束以后也会自动解开</li>
</ol>
<h3 id="Deadlock-analysis-with-thread-dumps"><a href="#Deadlock-analysis-with-thread-dumps" class="headerlink" title="Deadlock analysis with thread dumps"></a>Deadlock analysis with thread dumps</h3><ol>
<li>可以分析thread dump来分析死锁，具体见书中例子</li>
</ol>
<h2 id="Other-liveness-hazards"><a href="#Other-liveness-hazards" class="headerlink" title="Other liveness hazards"></a>Other liveness hazards</h2><h3 id="Starvation"><a href="#Starvation" class="headerlink" title="Starvation"></a>Starvation</h3><ol>
<li>饥饿指的是一个线程无法获取到需要的资源，从而无法继续执行。常见的饥饿有由于设置了线程的优先级，导致低优先级的线程一直无法得到执行。</li>
<li>饥饿强调的是由于无法获取需要的资源而导致线程无法继续运行，而死锁强调的是两个线程互相等待对方释放资源而卡死的情况</li>
</ol>
<h3 id="Livelock"><a href="#Livelock" class="headerlink" title="Livelock"></a>Livelock</h3><ol>
<li>活锁指的是一个线程尽管没有被阻塞，但是由于不停地重试某些任务，导致程序没有make progress，也可以理解为在做无用功。比如一个有问题的重试机制，重试前请求锁A，但是重试失败，释放锁A；然后继续尝试获取锁A，重试还是失败。</li>
<li>说白了死锁是加不上就死等，活锁是加不上就放开已获得的资源重试</li>
<li>另外一种活锁是两个线程互相谦让资源，导致程序没法继续执行，类似于路上的两个人互相让路，但都一直往同方向让</li>
<li>解决活锁问题的办法一般是引入一些随机时间</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-11-09T04:57:37.000Z" title="11/9/2021, 12:57:37 PM">2021-11-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-01-20T23:42:49.586Z" title="1/21/2022, 7:42:49 AM">2022-01-21</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">2 hours read (About 17850 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/11/09/Basics/CSAPP/">CSAPP</a></h1><div class="content"><h1 id="Representing-and-Manipulating-Information"><a href="#Representing-and-Manipulating-Information" class="headerlink" title="Representing and Manipulating Information"></a>Representing and Manipulating Information</h1><h2 id="Information-Storage"><a href="#Information-Storage" class="headerlink" title="Information Storage"></a>Information Storage</h2><ol>
<li>计算机程序把计算机的内存看成一段非常大的bytes数组，这个连续的bytes数组被称为虚拟内存(virtual memory)。虚拟内存的每一个byte都会被一个唯一的数字表示，这个数字称为这块内存的地址。所有的地址组成的集合被称为虚拟地址空间(virtual address space)</li>
</ol></div><a class="article-more button is-small is-size-7" href="/2021/11/09/Basics/CSAPP/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-10-16T01:36:49.000Z" title="10/16/2021, 9:36:49 AM">2021-10-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-12T18:05:26.431Z" title="11/13/2021, 2:05:26 AM">2021-11-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">an hour read (About 7100 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/10/16/Basics/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-/">C语言</a></h1><div class="content"><h1 id="计算机和编程语言"><a href="#计算机和编程语言" class="headerlink" title="计算机和编程语言"></a>计算机和编程语言</h1><ol>
<li>解释性语言vs编译语言：语言本无解释/编译之分，只是常用的执行方式而已，比如我们常说C语言是编译性语言，是因为大多数时候我们运行C语言都是先编译后运行，但是其实也是有C语言解释器存在的。</li>
<li>C语言发展与版本<ul>
<li>1989年ANSI发布了第一个标准-ANSI C</li>
<li>1990年ISO接受了ANCI的标准-C89</li>
<li>C的标准在1995年和1999年两次更新-C95和C99</li>
<li>本课程使用C99版本教学</li>
</ul>
</li>
</ol></div><a class="article-more button is-small is-size-7" href="/2021/10/16/Basics/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-10-15T21:28:42.000Z" title="10/16/2021, 5:28:42 AM">2021-10-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-02-21T05:07:52.788Z" title="2/21/2022, 1:07:52 PM">2022-02-21</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">an hour read (About 12324 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/10/16/Basics/Intro%20to%20Operating%20System/">Intro to Operating System</a></h1><div class="content"><h1 id="Virtualization"><a href="#Virtualization" class="headerlink" title="Virtualization"></a>Virtualization</h1><ol>
<li>虚拟化最重要的两个部分就是CPU虚拟化和内存虚拟化，通过对这两者进行抽象和虚拟化，即使我们的电脑只有一个CPU和一个物理内存，对于电脑上运行的多个进程来说，它们仿佛在使用自己独立的CPU和内存。其中CPU虚拟化使用的是time-sharing的方法，内存虚拟化使用的是space-sharing的方法。</li>
</ol></div><a class="article-more button is-small is-size-7" href="/2021/10/16/Basics/Intro%20to%20Operating%20System/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-06-25T17:40:19.000Z" title="6/26/2021, 1:40:19 AM">2021-06-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-12T15:14:27.487Z" title="11/12/2021, 11:14:27 PM">2021-11-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">31 minutes read (About 4652 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/26/Basics/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/">Java 8 新特性</a></h1><div class="content"><h1 id="Lambda-expressions"><a href="#Lambda-expressions" class="headerlink" title="Lambda expressions"></a>Lambda expressions</h1><h2 id="Default-Methods-for-Interfaces"><a href="#Default-Methods-for-Interfaces" class="headerlink" title="Default Methods for Interfaces"></a>Default Methods for Interfaces</h2><ol>
<li><p>Java 8允许我们在接口中定义non-abstract method，这在Java 8之前是不被允许的。定义的方法是使用default关键词：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>我们可以使用deault关键词定义的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里我们使用了匿名内部类。匿名内部类的一个很大的好处就是：接口是不能实例化的，如果要实例化，我们需要先定义实现这个接口的类。但很多时候，我们其实是不关心实现接口的类是怎样的，而只关心接口的方法是如何重写(override)的。匿名内部类就可以帮助我们达到目的。</p></div><a class="article-more button is-small is-size-7" href="/2021/06/26/Basics/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-05-31T04:31:11.000Z" title="5/31/2021, 12:31:11 PM">2021-05-31</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-12T18:05:08.969Z" title="11/13/2021, 2:05:08 AM">2021-11-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">4 hours read (About 36598 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/31/Basics/Computer%20Networking%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Computer Networking阅读笔记</a></h1><div class="content"><h1 id="Computer-Networks-and-the-Internet"><a href="#Computer-Networks-and-the-Internet" class="headerlink" title="Computer Networks and the Internet"></a>Computer Networks and the Internet</h1><h2 id="What-is-the-internet"><a href="#What-is-the-internet" class="headerlink" title="What is the internet"></a>What is the internet</h2><ol>
<li>计算机网络中，我们把所有连入网络的设备叫做主机(hosts)或者端系统(end systems)，端系统一般可以分成两大类：clients和servers</li>
<li>端系统之间由通信链路(communication links)和分组交换机(packet switches)连接。常见的通信链路包括同轴电缆，铜线，光纤和无线电频谱。常见的分组交换机有路由器(router)和链路层交换机(link-layer switch)</li>
<li>家用路由器与计算机网络中的路由器的区别： <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/52176116">https://www.zhihu.com/question/52176116</a></li>
</ol></div><a class="article-more button is-small is-size-7" href="/2021/05/31/Basics/Computer%20Networking%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-05-29T02:23:52.000Z" title="5/29/2021, 10:23:52 AM">2021-05-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-12T15:14:27.484Z" title="11/12/2021, 11:14:27 PM">2021-11-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">a few seconds read (About 57 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/29/Basics/Git%20Cherry%20Pick/">Git Cherry Pick</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html">http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html</a></p>
<p>Cherry pick 简单来说就是把另一个分支的某个commit直接放到当前的分支，如果在merge的时候遇到conflict，处理的方式与rebase类似</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-01T05:37:48.000Z" title="2/1/2021, 1:37:48 PM">2021-02-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-12T18:05:42.159Z" title="11/13/2021, 2:05:42 AM">2021-11-13</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">2 hours read (About 16225 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/01/Basics/Thinking%20in%20Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Thinking in Java阅读笔记</a></h1><div class="content"><h1 id="Initialization-amp-Clean-up"><a href="#Initialization-amp-Clean-up" class="headerlink" title="Initialization &amp; Clean up"></a>Initialization &amp; Clean up</h1><h2 id="Static-data-initialization"><a href="#Static-data-initialization" class="headerlink" title="Static data initialization"></a>Static data initialization</h2><ol>
<li>当新建一个类或者直接使用这个类里的static变量的时候，这个类里所有的static变量就会被初始化，static变量先于non-static变量进行初始化，并且整个程序中只有一份static变量的instance（即被所有对象共享）</li>
<li>static block: 跟static变量一样，随着类的加载而执行，只执行一次，并优先于主函数，可用于给类进行初始化</li>
</ol></div><a class="article-more button is-small is-size-7" href="/2021/02/01/Basics/Thinking%20in%20Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-03-27T20:59:43.000Z" title="3/28/2020, 4:59:43 AM">2020-03-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-12T15:14:27.492Z" title="11/12/2021, 11:14:27 PM">2021-11-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">a few seconds read (About 14 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/28/Basics/Package,%20classpath%20and%20jar/">Package, classpath and jar</a></h1><div class="content"><h1 id="Package-classpath-and-jar"><a href="#Package-classpath-and-jar" class="headerlink" title="Package, classpath and jar"></a>Package, classpath and jar</h1><p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976">https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976</a><br><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260466914339296">https://www.liaoxuefeng.com/wiki/1252599548343744/1260466914339296</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-10-04T01:14:39.000Z" title="10/4/2019, 9:14:39 AM">2019-10-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-12T15:14:27.490Z" title="11/12/2021, 11:14:27 PM">2021-11-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Basics/">Basics</a></span><span class="level-item">a few seconds read (About 73 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/10/04/Basics/Master%20Theorem/">Master Theorem</a></h1><div class="content"><h1 id="Master-Theorem-主定理"><a href="#Master-Theorem-主定理" class="headerlink" title="Master Theorem(主定理)"></a>Master Theorem(主定理)</h1><p>主定理用于在divide&amp;conquer问题中求时间复杂度，以前总是记不住，今天总结了一下，方便记忆。</p>
<p><img src="/images/blog/master.png"></p>
<p>Example: merge sort: T(n) = 2*T(n/2)+O(n)</p>
<p>a = 2, b =2, n^logba == n, 所以符合2.1, 所以结果是O(nlogn)</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/Basics/page/0/">Previous</a></div><div class="pagination-next"><a href="/categories/Basics/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/Basics/">1</a></li><li><a class="pagination-link" href="/categories/Basics/page/2/">2</a></li></ul></nav></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/Shiyu.jpg" alt="Shiyu Liu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Shiyu Liu</p><p class="is-size-6 is-block">Software Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Nashville</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">48</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">11</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ShiyuLiuColumbia" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ShiyuLiuColumbia"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Linkedin" href="https://www.linkedin.com/in/shiyu-liu-6623a3158/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:sl4401@columbia.edu"><i class="fas fa-envelope-open"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/BQ/"><span class="level-start"><span class="level-item">BQ</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Backend/"><span class="level-start"><span class="level-item">Backend</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Basics/"><span class="level-start"><span class="level-item">Basics</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/Distributed-System/"><span class="level-start"><span class="level-item">Distributed System</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Leetcode/"><span class="level-start"><span class="level-item">Leetcode</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><li><a class="level is-mobile" href="/categories/System-Design/"><span class="level-start"><span class="level-item">System Design</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">December 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">October 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">June 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">May 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">February 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">September 2019</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">April 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-05T15:47:04.000Z">2023-12-05</time></p><p class="title"><a href="/2023/12/05/Basics/Java%20Concurrency%20in%20Practice%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Java Concurrency in Practice阅读笔记</a></p><p class="categories"><a href="/categories/Basics/">Basics</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-09T04:57:37.000Z">2021-11-09</time></p><p class="title"><a href="/2021/11/09/Basics/CSAPP/">CSAPP</a></p><p class="categories"><a href="/categories/Basics/">Basics</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-16T01:36:49.000Z">2021-10-16</time></p><p class="title"><a href="/2021/10/16/Basics/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-/">C语言</a></p><p class="categories"><a href="/categories/Basics/">Basics</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-15T21:28:42.000Z">2021-10-16</time></p><p class="title"><a href="/2021/10/16/Basics/Intro%20to%20Operating%20System/">Intro to Operating System</a></p><p class="categories"><a href="/categories/Basics/">Basics</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-13T03:30:12.000Z">2021-10-13</time></p><p class="title"><a href="/2021/10/13/Backend/LoadBalancing/">LoadBalancing</a></p><p class="categories"><a href="/categories/Backend/">Backend</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Angular/"><span class="tag">Angular</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Computer-Network/"><span class="tag">Computer Network</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database/"><span class="tag">Database</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Encode/"><span class="tag">Encode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Host-file/"><span class="tag">Host file</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Unicode/"><span class="tag">Unicode</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Shiyu - Blog</a><p class="is-size-7"><span>&copy; 2024 Shiyu Liu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>