<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Paxos-based Key/Value Service - Shiyu - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Shiyu - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Shiyu - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="分布式的第三次作业，作业的内容是实现基于Paxos的Key&amp;#x2F;Value pair数据库"><meta property="og:type" content="blog"><meta property="og:title" content="Paxos-based Key/Value Service"><meta property="og:url" content="https://shiyuliucolumbia.github.io/2019/11/26/Basics/Paxos-based%20Key-Value%20Service/"><meta property="og:site_name" content="Shiyu - Blog"><meta property="og:description" content="分布式的第三次作业，作业的内容是实现基于Paxos的Key&amp;#x2F;Value pair数据库"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://shiyuliucolumbia.github.io/img/og_image.png"><meta property="article:published_time" content="2019-11-26T19:57:15.000Z"><meta property="article:modified_time" content="2021-11-12T15:14:27.494Z"><meta property="article:author" content="Shiyu Liu"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://shiyuliucolumbia.github.io/2019/11/26/Basics/Paxos-based%20Key-Value%20Service/"},"headline":"Paxos-based Key/Value Service","image":["https://shiyuliucolumbia.github.io/img/og_image.png"],"datePublished":"2019-11-26T19:57:15.000Z","dateModified":"2021-11-12T15:14:27.494Z","author":{"@type":"Person","name":"Shiyu Liu"},"publisher":{"@type":"Organization","name":"Shiyu - Blog","logo":{"@type":"ImageObject","url":{"text":"Shiyu - Blog"}}},"description":"分布式的第三次作业，作业的内容是实现基于Paxos的Key&#x2F;Value pair数据库"}</script><link rel="canonical" href="https://shiyuliucolumbia.github.io/2019/11/26/Basics/Paxos-based%20Key-Value%20Service/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Shiyu - Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-11-26T19:57:15.000Z" title="11/26/2019, 1:57:15 PM">2019-11-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-12T15:14:27.494Z" title="11/12/2021, 9:14:27 AM">2021-11-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Distributed-System/">Distributed System</a></span><span class="level-item">23 minutes read (About 3505 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">Paxos-based Key/Value Service</h1><div class="content"><p>分布式的第三次作业，作业的内容是实现基于Paxos的Key/Value pair数据库</p>
<span id="more"></span>

<h1 id="Assignment-3-Paxos-based-Key-Value-Service"><a href="#Assignment-3-Paxos-based-Key-Value-Service" class="headerlink" title="Assignment 3: Paxos-based Key/Value Service"></a>Assignment 3: Paxos-based Key/Value Service</h1><h3 id="Part-A-Due-Saturday-Nov-2-11-59-59pm"><a href="#Part-A-Due-Saturday-Nov-2-11-59-59pm" class="headerlink" title="Part A Due: Saturday Nov 2, 11:59:59pm"></a>Part A Due: Saturday Nov 2, 11:59:59pm</h3><h3 id="Part-B-Due-Saturday-Nov-9-11-59-59pm"><a href="#Part-B-Due-Saturday-Nov-9-11-59-59pm" class="headerlink" title="Part B Due: Saturday Nov 9, 11:59:59pm"></a>Part B Due: Saturday Nov 9, 11:59:59pm</h3><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Your Assignment 2 depends on a single master view server to pick the primary.<br>If the view server is not available (crashes or has network problems),<br>then your key/value service won’t work, even if both primary and<br>backup are available. It also has the less critical defect that it<br>copes with a server (primary or backup) that’s briefly unavailable<br>(e.g. due to a lost packet) by either blocking or declaring it dead;<br>the latter is very expensive because it requires a complete key/value<br>database transfer.</p>
<p>In this assignment you’ll fix above problems by using Paxos to manage the<br>replication of a key/value store. You won’t have anything<br>corresponding to a master view server. Instead, a set of replicas will<br>process all client requests in the same order, using Paxos to agree on<br>the order. Paxos will get the agreement right even if some of the<br>replicas are unavailable, or have unreliable network connections, or<br>even if subsets of the replicas are isolated in their own network<br>partitions. As long as Paxos can assemble a majority of replicas, it<br>can process client operations. Replicas that were not in the majority<br>can catch up later by asking Paxos for operations that they missed.</p>
<p>Your system will consist of the following players: clients, kvpaxos servers,<br>and Paxos peers. Clients send Put(), PutHash(), and Get() RPCs to key/value<br>servers (called kvpaxos servers). A client can send an RPC to any of the kvpaxos<br>servers, and should retry by sending to a different server if there’s a<br>failure. Each kvpaxos server contains a replica of the key/value database;<br>handlers for client Get() and Put() RPCs; and a Paxos peer. Paxos takes the form<br>of a library that is included in each kvpaxos server. A kvpaxos server talks to<br>its local Paxos peer (via method calls). The different Paxos peers talk to each<br>other via RPCs to achieve agreement on each operation.</p>
<p>Your Paxos library’s interface supports an indefinite sequence of<br>agreement “instances”. The instances are numbered with sequence numbers. Each<br>instance is either “decided” or not yet decided. A decided instance<br>has a value. If an instance is decided, then all the Paxos peers that<br>are aware that it is decided will agree on the same value for that<br>instance. The Paxos library interface allows kvpaxos to suggest a<br>value for an instance, and to find out whether an instance has been<br>decided and (if so) what that instance’s value is.</p>
<p>Your kvpaxos servers will use Paxos to agree on the order in which<br>client Put()s and Get()s execute. Each time a kvpaxos server receives<br>a Put() or Get() RPC, it will use Paxos to cause some Paxos instance’s<br>value to be a description of that Put() or Get(). That instance’s<br>sequence number determines when the Put() or Get() executes relative<br>to other Put()s and Get()s. In order to find the value to be returned<br>by a Get(), kvpaxos should first apply all Put()s that are ordered<br>before the Get() to its key/value database.</p>
<p>You should think of kvpaxos as using Paxos to implement a “log” of<br>Put/Get operations. That is, each Paxos instance is a log element, and<br>the order of operations in the log is the order in which all kvpaxos<br>servers will apply the operations to their key/value databases. Paxos<br>will ensure that the kvpaxos servers agree on this order.</p>
<p>Only RPC may be used for interaction between clients and servers,<br>between different servers, and between different clients. For example,<br>different instances of your server are not allowed to share Go<br>variables or files.</p>
<p>Your Paxos-based key/value storage system will have some limitations<br>that would need to be fixed in order for it to be a serious system. It<br>won’t cope with crashes, since it stores neither the key/value<br>database nor the Paxos state on disk. It requires the set of servers to be<br>fixed, so one cannot replace old servers. Finally, it is slow: many<br>Paxos messages are exchanged for each Put() and Get(). All of these<br>problems can be fixed.</p>
<p>You should consult the Paxos lecture notes and the Paxos assigned<br>reading. For a wider perspective, take a look at Chubby, Paxos Made Live,<br>Spanner, Zookeeper, Harp, Viewstamped Replication,<br>and <a target="_blank" rel="noopener" href="http://static.usenix.org/event/nsdi11/tech/full_papers/Bolosky.pdf">Gaios</a></p>
<h3 id="Collaboration-Policy"><a href="#Collaboration-Policy" class="headerlink" title="Collaboration Policy"></a>Collaboration Policy</h3><p>Please refer to Assignment 0.</p>
<h3 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h3><p>Do a <tt>git pull</tt> to get the latest assignment software. We supply you<br>with new skeleton code and new tests in <tt>src/paxos</tt> and<br><tt>src/kvpaxos</tt>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/4113</span><br><span class="line">$ git pull</span><br><span class="line">...</span><br><span class="line">$ <span class="built_in">cd</span> src/paxos</span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">Single proposer: --- FAIL: TestBasic (5.02 seconds)</span><br><span class="line">       test_test.go:48: too few decided; seq=0 ndecided=0 wanted=3</span><br><span class="line">Forgetting: --- FAIL: TestForget (5.03 seconds) </span><br><span class="line">       test_test.go:48: too few decided; seq=0 ndecided=0 wanted=6</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Ignore the huge number of “has wrong number of ins” and “type Paxos<br>has no exported methods” errors.</p>
<h3 id="Part-A-Paxos"><a href="#Part-A-Paxos" class="headerlink" title="Part A: Paxos"></a>Part A: Paxos</h3><p>First you’ll implement a Paxos library.<br><tt>paxos.go</tt> contains descriptions of the methods you must<br>implement. When you’re done, you should pass all the tests in the<br><tt>paxos</tt> directory (after ignoring Go’s many complaints):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/4113/src/paxos</span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">Test: Single proposer ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Many proposers, same value ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Many proposers, different values ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Out-of-order instances ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Deaf proposer ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Forgetting ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Lots of forgetting ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Paxos frees forgotten instance memory ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Many instances ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Minority proposal ignored ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Many instances, unreliable RPC ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: No decision <span class="keyword">if</span> partitioned ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Decision <span class="keyword">in</span> majority partition ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: All agree after full heal ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: One peer switches partitions ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: One peer switches partitions, unreliable ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Many requests, changing partitions ...</span><br><span class="line"> ... Passed</span><br><span class="line">PASS</span><br><span class="line">ok      paxos   59.523s</span><br></pre></td></tr></table></figure>

<p>Your implementation must support this interface:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">px = paxos.Make(peers []<span class="keyword">string</span>, me <span class="keyword">int</span>)</span><br><span class="line">px.Start(seq <span class="keyword">int</span>, v <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// start agreement on new instance</span></span><br><span class="line">px.Status(seq <span class="keyword">int</span>) (decided <span class="keyword">bool</span>, v <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// get info about an instance</span></span><br><span class="line">px.Done(seq <span class="keyword">int</span>) <span class="comment">// ok to forget all instances &lt;= seq</span></span><br><span class="line">px.Max() <span class="keyword">int</span> <span class="comment">// highest instance seq known, or -1</span></span><br><span class="line">px.Min() <span class="keyword">int</span> <span class="comment">// instances before this have been forgotten</span></span><br></pre></td></tr></table></figure>

<p>An application calls Make(peers,me) to create a Paxos peer. The peers<br>argument contains the ports of all the peers (including this one), and<br>the me argument is the index of this peer in the peers array.<br>Start(seq,v) asks Paxos to start agreement on instance seq, with<br>proposed value v; Start() should return immediately, without waiting<br>for agreement to complete. The application calls Status(seq) to find<br>out whether the Paxos peer thinks the instance has reached agreement,<br>and if so what the agreed value is.<br>Status() should consult the local Paxos peer’s state and return<br>immediately; it should not communicate with other peers.<br>The application may call Status()<br>for old instances (but see the discussion of Done() below).</p>
<p>Your implementation should be able to make progress on agreement for<br>multiple instances at the same time. That is, if application peers<br>call Start() with different sequence numbers at about the same time,<br>your implementation should run the Paxos protocol concurrently for all<br>of them. You should <strong>not</strong> wait for agreement to complete for<br>instance i before starting the protocol for instance i+1. Each instance<br>should have its own separate execution of the Paxos protocol.</p>
<p>A long-running Paxos-based server must forget about<br>instances that are no longer needed, and free the memory<br>storing information about those instances.<br>An instance is needed if the<br>application still wants to be able to call Status() for that instance,<br>or if another Paxos peer may not yet have reached agreement on that<br>instance. Your Paxos should implement freeing of instances in the<br>following way. When a particular peer application will no longer need<br>to call Status() for any instance &lt;= x, it should call Done(x). That<br>Paxos peer can’t yet discard the instances, since some other Paxos<br>peer might not yet have agreed to the instance. So each Paxos peer<br>should tell each other peer the highest Done argument supplied by its<br>local application. Each Paxos peer will then have a Done value<br>from each other peer. It should find the minimum, and discard all<br>instances with sequence numbers &lt;= that minimum. The Min() method<br>returns this minimum sequence number plus one.</p>
<p>It’s OK for your Paxos to piggyback the Done value in the agreement<br>protocol packets; that is, it’s OK for peer P1 to only learn P2’s<br>latest Done value the next time that P2 sends an agreement message to<br>P1. If Start() is called with a sequence number less than Min(),<br>the Start() call should be ignored. If Status() is called with a<br>sequence number less than Min(), Status() should return false<br>(indicating no agreement).</p>
<p>Here is Paxos pseudocode (for a single instance):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">proposer(v):</span><br><span class="line"> while not decided:</span><br><span class="line">   choose n, unique and higher than any n seen so far</span><br><span class="line">   send prepare(n) to all servers including self</span><br><span class="line">   if prepare_ok(n_a, v_a) from majority:</span><br><span class="line">     v&#x27; = v_a with highest n_a; choose own v otherwise</span><br><span class="line">     send accept(n, v&#x27;) to all</span><br><span class="line">     if accept_ok(n) from majority:</span><br><span class="line">       send decided(v&#x27;) to all</span><br><span class="line"></span><br><span class="line">acceptor&#x27;s state:</span><br><span class="line"> n_p (highest prepare seen)</span><br><span class="line"> n_a, v_a (highest accept seen)</span><br><span class="line"></span><br><span class="line">acceptor&#x27;s prepare(n) handler:</span><br><span class="line"> if n &gt; n_p</span><br><span class="line">   n_p = n</span><br><span class="line">   reply prepare_ok(n_a, v_a)</span><br><span class="line"> else</span><br><span class="line">   reply prepare_reject</span><br><span class="line"></span><br><span class="line">acceptor&#x27;s accept(n, v) handler:</span><br><span class="line"> if n &gt;= n_p</span><br><span class="line">   n_p = n</span><br><span class="line">   n_a = n</span><br><span class="line">   v_a = v</span><br><span class="line">   reply accept_ok(n)</span><br><span class="line"> else</span><br><span class="line">   reply accept_reject</span><br></pre></td></tr></table></figure>

<p>Here’s a reasonable plan of attack:</p>
<ol>
<li><p>Add elements to the Paxos struct in paxos.go to hold the state you’ll need,<br>according to the lecture pseudocode. You’ll need to define a struct to hold<br>information about each agreement instance.</p>
</li>
<li><p>Define RPC argument/reply type(s) for Paxos protocol messages, based on the<br>lecture pseudocode. The RPCs must include the sequence number for the agreement<br>instance to which they refer. Remember the field names in the RPC structures must<br>start with capital letters.</p>
</li>
<li><p>Write a proposer function that drives the Paxos protocol for an instance, and<br>RPC handlers that implement acceptors. Start a proposer function in its own thread<br>for each instance, as needed (e.g. in Start()).</p>
</li>
<li><p>At this point you should be able to pass the first few tests.</p>
</li>
<li><p>Now implement forgetting.</p>
</li>
</ol>
<p>Hint: more than one Paxos instance may be executing at a given time,<br>and they may be Start()’ed and/or decided out of order (e.g. seq 10 may<br>be decided before seq 5).</p>
<p>Hint: in order to pass tests assuming unreliable network, your paxos<br>should call the local acceptor through a function call rather than RPC.</p>
<p>Hint: remember that multiple application peers may call Start() on the<br>same instance, perhaps with different proposed values. An application<br>may even call Start() for an instance that has already been decided.</p>
<p>Hint: think about how your paxos will forget (discard) information about<br>old instances before you start writing code. Each Paxos peer will need to<br>store instance information in some data structure that allows<br>individual instance records to be deleted (so that the Go garbage<br>collector can free / re-use the memory).</p>
<p>Hint: you do not need to write code to handle the situation where<br>a Paxos peer needs to re-start after a crash. If one of your<br>Paxos peers crashes, it will never be re-started.</p>
<p>Hint: have each Paxos peer start a thread per un-decided instance<br>whose job is to eventually drive the instance to agreement, by<br>acting as a proposer.</p>
<p>Hint: a single Paxos peer may be acting simultaneously as acceptor and<br>proposer for the same instance. Keep these two activities as separate<br>as possible.</p>
<p>Hint: a proposer needs a way to choose a higher proposal number than<br>any seen so far. This is a reasonable exception to the rule that<br>proposer and acceptor should be separate. It may also be useful for the<br>propose RPC handler to return the highest known proposal number if it<br>rejects an RPC, to help the caller pick a higher one next time.<br>The <tt>px.me</tt> value will be different in each Paxos peer,<br>so you can use <tt>px.me</tt> to help ensure that proposal numbers<br>are unique.</p>
<p>Hint: figure out the minimum number of messages Paxos should use when<br>reaching agreement in non-failure cases and make your implementation<br>use that minimum.</p>
<p>Hint: the tester calls Kill() when it wants your Paxos to shut down;<br>Kill() sets px.dead. You should check px.dead in any loops you have<br>that might run for a while, and break out of the loop if px.dead is<br>true. It’s particularly important to do this in any long-running<br>threads you create.</p>
<h3 id="Part-B-Paxos-based-Key-Value-Server"><a href="#Part-B-Paxos-based-Key-Value-Server" class="headerlink" title="Part B: Paxos-based Key/Value Server"></a>Part B: Paxos-based Key/Value Server</h3><p>Now you’ll build kvpaxos, a fault-tolerant key/value storage system.<br>You’ll modify <tt>kvpaxos/client.go</tt>,<br><tt>kvpaxos/common.go</tt>, and <tt>kvpaxos/server.go</tt>.</p>
<p>Your kvpaxos replicas should stay identical; the only exception<br>is that some replicas may lag others if they are not<br>reachable. If a replica isn’t reachable for a while, but then starts<br>being reachable, it should eventually catch up (learn about operations<br>that it missed).</p>
<p>Your kvpaxos client code should try different replicas it knows about<br>until one responds. A kvpaxos<br>replica that is part of a majority of replicas that can all reach each<br>other should be able to serve client requests.</p>
<p>Your storage system must provide sequential consistency to applications that<br>use its client interface. That is, completed application calls to the<br>Clerk.Get(), Clerk.Put(), and Clerk.PutHash() methods in<br><tt>kvpaxos/client.go</tt> must appear to have affected all replicas in the same<br>order and have at-most-once semantics. A Clerk.Get() should see the value<br>written by the most recent Clerk.Put() (in that order) to the same key.  One<br>consequence of this is that you must ensure that each application call to<br>Clerk.Put() must appear in that order just once (i.e., write the key/value<br>database just once), even though internally your <tt>client.go</tt> may have to<br>send Put() and PutHash() RPCs multiple times until it finds a kvpaxos server<br>replica that replies.</p>
<p>Here’s a reasonable plan:</p>
<ol>
<li><p>Fill in the Op struct in server.go with the “value” information that kvpaxos will<br>use Paxos to agree on, for each client request. Op field names must start with capital<br>letters. You should use Op structs as the agreed-on values – for example, you should<br>pass Op structs to Paxos Start(). Go’s RPC can marshall/unmarshall Op structs; the<br>call to gob.Register() in StartServer() teaches it how.</p>
</li>
<li><p>Implement the Put() handler in server.go. It should enter a Put Op in the Paxos log<br>(i.e., use Paxos to allocate a Paxos instance, whose value includes the key and value<br>(so that other kvpaxoses know about the Put())).</p>
</li>
<li><p>Implement a Get() handler. It should enter a Get Op in the Paxos log, and then<br>“interpret” the the log before that point to make sure its key/value database reflects<br>all recent Put()s.</p>
</li>
<li><p>Add code to cope with duplicate client Put()s – i.e. situations in which Put() in<br>client.go sends the same request to multiple kvpaxos replicas. The Put()/PutHash()<br>should execute just once.</p>
</li>
</ol>
<p>Hint: your server should try to assign the next available Paxos<br>instance (sequence number) to each incoming client RPC. However, some<br>other kvpaxos replica may also be trying to use that instance for a<br>different client’s operation. So the kvpaxos server has to be prepared<br>to try different instances.</p>
<p>Hint: your kvpaxos servers should not directly communicate; they<br>should only interact with each other through the Paxos log.</p>
<p>Hint: as in Assignment 2, you will need to uniquely identify client<br>operations to ensure that they execute just once.<br>Also as in Assignment 2, you can assume that each clerk has only one<br>outstanding Put or Get.</p>
<p>Hint: a kvpaxos server should not complete a Get() RPC if it is not<br>part of a majority (so that it does not serve stale data). This means<br>that each Get() (as well as each Put()) must involve Paxos<br>agreement.</p>
<p>Hint: don’t forget to call the Paxos Done() method when a kvpaxos<br>has processed an instance and will no longer need it or any<br>previous instance.</p>
<p>Hint: your code will need to wait for Paxos instances to complete<br>agreement. The only way to do this is to periodically call Status(),<br>sleeping between calls. How long to sleep? A good plan is to check<br>quickly at first, and then more slowly:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">to := <span class="number">10</span> * time.Millisecond</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  decided, _ := kv.px.Status(seq)</span><br><span class="line">  <span class="keyword">if</span> decided &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(to)</span><br><span class="line">  <span class="keyword">if</span> to &lt; <span class="number">10</span> * time.Second &#123;</span><br><span class="line">    to *= <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hint: if one of your kvpaxos servers falls behind (i.e. did not<br>participate in the agreement for some instance), it will later need to<br>find out what (if anything) was agreed to. A reasonable way to to this<br>is to call Start(), which will either discover the previously<br>agreed-to value, or cause agreement to happen. Think about what value<br>would be reasonable to pass to Start() in this situation.</p>
<p>Hint: When the test fails, check for gob error (e.g. “rpc: writing<br>response: gob: type not registered for interface …”) in the log because go<br>doesn’t consider the error fatal, although it is fatal for the assignment. </p>
<h3 id="Handin-procedure"><a href="#Handin-procedure" class="headerlink" title="Handin procedure"></a>Handin procedure</h3><p>You hand in your assignment as before.</p>
<p>For Part A:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&quot;[you fill me in]&quot;</span></span><br><span class="line">$ git tag -a -m <span class="string">&quot;i finished assignment 3a&quot;</span> a3ahandin</span><br><span class="line">$ git push origin master</span><br><span class="line">$ git push origin a3ahandin</span><br></pre></td></tr></table></figure>

<p>For Part B:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&quot;[you fill me in]&quot;</span></span><br><span class="line">$ git tag -a -m <span class="string">&quot;i finished assignment 3b&quot;</span> a3bhandin</span><br><span class="line">$ git push origin master</span><br><span class="line">$ git push origin a3bhandin</span><br></pre></td></tr></table></figure>

<p>You should verify that you are able to see your final commit and tags<br>on the Github page of your repository for this assignment.</p>
<p>You will receive full credit if your software passes the<br><tt>test_test.go</tt> tests when we run your software on our machines.<br>We will use the timestamp of your <strong>last</strong> handin tag for the purpose<br>of calculating late days and we will only grade that version of the code.<br>(We’ll also know if you backdate the tag, don’t do that.)</p>
<h3 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h3><p>Please post questions on <a target="_blank" rel="noopener" href="https://www.piazza.com/columbia/fall2017/comsw4113/home">Piazza</a>.</p>
<hr>
<p>Part A 部分主要是基于Paxos协议的三个阶段进行编写：prepare, accecpt and decide。由于我们的系统是可以同时处理多个请求的，所以对于不同的请求我们用instance进行代表，每一个instance可以有decided或者undecided的状态，我们的paxos协议会使每一个instance最后变成decided状态，每一个instance都储存着操作的结果。<br>PartB使用我们之前写好的Paxos Library实现Key/Value存储，与作业2相似，我们仍旧需要实现at most once semantic，所以仍现需要每次发出get或者put的时候都一起发出一个sequence unique ID。由于我们的instances中存着操作的结果，所以我们每进行put或者get，都从instance number 0开始进行检查：从0开始检查每一个instanceSeqNum，如果decided(已经有别的操作占用这个instance)，那么将这个操作的结果写入自己的数据库中；如果没有decided，那么将这次的操作占用这个instance并等待所有pvserver同步完成(同步完成也就是decided)。<br><strong>所以本质上paxos协议(partA)是可以使所有的partition储存相同的信息，partB因为我们要建立有PUT和GET操作的数据库，所以相当于我们存储的相同的信息是这些操作的LOG集合</strong></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/12/09/Leetcode/Basic%20Calculator%E7%B1%BB%E5%9E%8B%E9%A2%98/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Basic Calculator类型题</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/11/23/Leetcode/Graph%E7%B1%BB%E5%9E%8B%E9%A2%98%E6%80%BB%E7%BB%93/"><span class="level-item">Graph类型题总结</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/Shiyu.jpg" alt="Shiyu Liu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Shiyu Liu</p><p class="is-size-6 is-block">Software Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Nashville</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">47</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">11</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ShiyuLiuColumbia" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ShiyuLiuColumbia"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Linkedin" href="https://www.linkedin.com/in/shiyu-liu-6623a3158/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:sl4401@columbia.edu"><i class="fas fa-envelope-open"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Assignment-3-Paxos-based-Key-Value-Service"><span class="level-left"><span class="level-item">1</span><span class="level-item">Assignment 3: Paxos-based Key/Value Service</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Questions"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Questions</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Shiyu - Blog</a><p class="is-size-7"><span>&copy; 2021 Shiyu Liu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>