<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Mapreduce and Primary-Backup Key-Value Service - Shiyu - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Shiyu - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Shiyu - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="今天写完了分布式的作业2，正好总结一下作业1-Mapreduce和作业2-Primary-Backup Key-Value Service。"><meta property="og:type" content="blog"><meta property="og:title" content="Mapreduce and Primary-Backup Key-Value Service"><meta property="og:url" content="https://shiyuliucolumbia.github.io/2019/10/12/Basics/Mapreduce%20and%20Primary-Backup%20Key-Value%20Service/"><meta property="og:site_name" content="Shiyu - Blog"><meta property="og:description" content="今天写完了分布式的作业2，正好总结一下作业1-Mapreduce和作业2-Primary-Backup Key-Value Service。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://shiyuliucolumbia.github.io/2019/10/12/Basics/Mapreduce%20and%20Primary-Backup%20Key-Value%20Service/lab-2a-vs.png"><meta property="article:published_time" content="2019-10-12T22:50:23.000Z"><meta property="article:modified_time" content="2021-11-12T15:14:27.489Z"><meta property="article:author" content="Shiyu Liu"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="lab-2a-vs.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://shiyuliucolumbia.github.io/2019/10/12/Basics/Mapreduce%20and%20Primary-Backup%20Key-Value%20Service/"},"headline":"Mapreduce and Primary-Backup Key-Value Service","image":["https://shiyuliucolumbia.github.io/2019/10/12/Basics/Mapreduce%20and%20Primary-Backup%20Key-Value%20Service/lab-2a-vs.png"],"datePublished":"2019-10-12T22:50:23.000Z","dateModified":"2021-11-12T15:14:27.489Z","author":{"@type":"Person","name":"Shiyu Liu"},"publisher":{"@type":"Organization","name":"Shiyu - Blog","logo":{"@type":"ImageObject","url":{"text":"Shiyu - Blog"}}},"description":"今天写完了分布式的作业2，正好总结一下作业1-Mapreduce和作业2-Primary-Backup Key-Value Service。"}</script><link rel="canonical" href="https://shiyuliucolumbia.github.io/2019/10/12/Basics/Mapreduce%20and%20Primary-Backup%20Key-Value%20Service/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Shiyu - Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-10-12T22:50:23.000Z" title="10/12/2019, 5:50:23 PM">2019-10-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-12T15:14:27.489Z" title="11/12/2021, 9:14:27 AM">2021-11-12</time></span><span class="level-item"><a class="link-muted" href="/categories/Distributed-System/">Distributed System</a></span><span class="level-item">44 minutes read (About 6568 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">Mapreduce and Primary-Backup Key-Value Service</h1><div class="content"><p>今天写完了分布式的作业2，正好总结一下作业1-Mapreduce和作业2-Primary-Backup Key-Value Service。</p>
<span id="more"></span>

<h1 id="Assignment-1-MapReduce"><a href="#Assignment-1-MapReduce" class="headerlink" title="Assignment 1: MapReduce"></a>Assignment 1: MapReduce</h1><h3 id="Due-Sunday-Sep-22-11-59-59pm"><a href="#Due-Sunday-Sep-22-11-59-59pm" class="headerlink" title="Due: Sunday Sep 22, 11:59:59pm"></a>Due: Sunday Sep 22, 11:59:59pm</h3><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In this assignment you’ll build a MapReduce library as a way to learn the Go<br>programming language and as a way to learn about fault tolerance in<br>distributed systems. In the first part you will write a simple<br>MapReduce program. In the second part you will write a Master that<br>hands out jobs to workers, and handles failures of workers. The<br>interface to the library and the approach to fault tolerance is<br>similar to the one described in the original<br><a target="_blank" rel="noopener" href="http://research.google.com/archive/mapreduce-osdi04.pdf">MapReduce paper</a>.</p>
<h3 id="Collaboration-Policy"><a href="#Collaboration-Policy" class="headerlink" title="Collaboration Policy"></a>Collaboration Policy</h3><p>Please refer to Assignment 0.</p>
<h3 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h3><p>You’ll implement this assignment (and all the assignments) in <a target="_blank" rel="noopener" href="http://www.golang.org/">Go 1.2 or<br>later</a>. The Go web site contains lots of<br>tutorial information which you may want to look at. We supply you with<br>a non-distributed MapReduce implementation, and a partial<br>implementation of a distributed implementation (just the boring bits).</p>
<p>It’s your responsibility to install Go in your development<br>environment. We recommend using your distribution’s package manager. </p>
<p>On OS X with <a target="_blank" rel="noopener" href="http://brew.sh/">homebrew</a>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install go</span><br></pre></td></tr></table></figure>

<p>On Ubuntu/Debian:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install golang</span><br></pre></td></tr></table></figure>

<p>On Arch:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S go</span><br></pre></td></tr></table></figure>


<h3 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h3><p> There is an input file <tt>kjv12.txt</tt> in src/main, which was<br>downloaded from <a target="_blank" rel="noopener" href="https://web.archive.org/web/20130530223318/http://patriot.net/~bmcgin/kjv12.txt">here</a>.<br>Compile the initial software we provide you with and run it with the downloaded input<br>file:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/4113</span><br><span class="line">$ <span class="built_in">cd</span> ~/4113/src/main</span><br><span class="line">$ go run wc.go master kjv12.txt sequential</span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./wc.go:11: missing <span class="built_in">return</span> at end of <span class="keyword">function</span></span><br><span class="line">./wc.go:15: missing <span class="built_in">return</span> at end of <span class="keyword">function</span></span><br></pre></td></tr></table></figure>

<p>The compiler produces two errors, because the implementation of the<br><tt>Map</tt> and <tt>Reduce</tt> functions is incomplete.</p>
<h3 id="Part-I-Word-count"><a href="#Part-I-Word-count" class="headerlink" title="Part I: Word count"></a>Part I: Word count</h3><p>Modify <tt>Map</tt> and <tt>Reduce</tt> so that <tt>wc.go</tt> reports the<br>number of occurrences of each word in alphabetical order.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ go run wc.go master kjv12.txt sequential</span><br><span class="line">Split kjv12.txt</span><br><span class="line">Split <span class="built_in">read</span> 4834757</span><br><span class="line">DoMap: <span class="built_in">read</span> split mrtmp.kjv12.txt-0 966954</span><br><span class="line">DoMap: <span class="built_in">read</span> split mrtmp.kjv12.txt-1 966953</span><br><span class="line">DoMap: <span class="built_in">read</span> split mrtmp.kjv12.txt-2 966951</span><br><span class="line">DoMap: <span class="built_in">read</span> split mrtmp.kjv12.txt-3 966955</span><br><span class="line">DoMap: <span class="built_in">read</span> split mrtmp.kjv12.txt-4 966944</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-0-0</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-1-0</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-2-0</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-3-0</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-4-0</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-0-1</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-1-1</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-2-1</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-3-1</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-4-1</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-0-2</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-1-2</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-2-2</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-3-2</span><br><span class="line">DoReduce: <span class="built_in">read</span> mrtmp.kjv12.txt-4-2</span><br><span class="line">Merge phaseMerge: <span class="built_in">read</span> mrtmp.kjv12.txt-res-0</span><br><span class="line">Merge: <span class="built_in">read</span> mrtmp.kjv12.txt-res-1</span><br><span class="line">Merge: <span class="built_in">read</span> mrtmp.kjv12.txt-res-2</span><br></pre></td></tr></table></figure>

<p>The output will be in the file “mrtmp.kjv12.txt”. Your implementation is<br>correct if the following command produces the following top 10 words:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sort -n -k2 mrtmp.kjv12.txt | tail -10</span><br><span class="line">unto: 8940</span><br><span class="line">he: 9666</span><br><span class="line">shall: 9760</span><br><span class="line"><span class="keyword">in</span>: 12334</span><br><span class="line">that: 12577</span><br><span class="line">And: 12846</span><br><span class="line">to: 13384</span><br><span class="line">of: 34434</span><br><span class="line">and: 38850</span><br><span class="line">the: 62075</span><br></pre></td></tr></table></figure>

<p>To make testing easy for you, run:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./test-wc.sh</span><br></pre></td></tr></table></figure>
<p>and it will report if your solution is correct or not.</p>
<p>Before you start coding reread Section 2 of the <a target="_blank" rel="noopener" href="http://research.google.com/archive/mapreduce-osdi04.pdf">MapReduce<br>paper</a> and our code for MapReduce, which is in <tt>mapreduce.go</tt> in<br>package <tt>mapreduce</tt>. In particular, you want to read the code of the<br>function <tt>RunSingle</tt> and the functions it calls. This will help you<br>understand what MapReduce does and learn Go by example.</p>
<p>Once you understand this code, implement <tt>Map</tt> and <tt>Reduce</tt> in<br><tt>wc.go</tt>.</p>
<p>Hint: you can use<br><a target="_blank" rel="noopener" href="http://golang.org/pkg/strings/#FieldsFunc"><tt>strings.FieldsFunc</tt></a><br>to split a string into components.</p>
<p>Hint: for the purposes of this exercise, you can consider a word to be<br>any contiguous sequence of letters, as determined by<br><a target="_blank" rel="noopener" href="http://golang.org/pkg/unicode/#IsLetter"><tt>unicode.IsLetter</tt></a>.<br>A good read on what strings are in Go is the <a target="_blank" rel="noopener" href="http://blog.golang.org/strings">Go Blog on strings</a>.</p>
<p>Hint: the strconv package (<a target="_blank" rel="noopener" href="http://golang.org/pkg/strconv/">http://golang.org/pkg/strconv/</a>) is handy to<br>convert strings to integers, etc.</p>
<p>You can remove the output file and all intermediate files with:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm mrtmp.*</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&quot;[you fill me in]&quot;</span></span><br><span class="line">$ git tag -a -m <span class="string">&quot;i finished assignment 1 part 1&quot;</span> a1p1</span><br><span class="line">$ git push origin master</span><br><span class="line">$ git push origin a1p1</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h3 id="Part-II-Distributing-MapReduce-jobs"><a href="#Part-II-Distributing-MapReduce-jobs" class="headerlink" title="Part II: Distributing MapReduce jobs"></a>Part II: Distributing MapReduce jobs</h3><p>In this part you will design and implement a master who distributes<br>jobs to a set of workers. We give you the code for the RPC messages<br>(see <tt>common.go</tt> in the <tt>mapreduce</tt> package) and the code<br>for a worker (see <tt>worker.go</tt> in the <tt>mapreduce</tt> package).</p>
<p>Your job is to complete <tt>master.go</tt> in the <tt>mapreduce</tt><br>package. In particular, the <tt>RunMaster()</tt> function in<br><tt>master.go</tt> should return only when all of the map and reduce tasks<br>have been executed. This function will be invoked from the <tt>Run()</tt><br>function in <tt>mapreduce.go</tt>.</p>
<p>The code in <tt>mapreduce.go</tt> already implements the<br><tt>MapReduce.Register</tt> RPC function for you, and passes the new<br>worker’s information to <tt>mr.registerChannel</tt>. You should process<br>new worker registrations by reading from this channel.</p>
<p>Information about the MapReduce job is in the <tt>MapReduce</tt> struct,<br>defined in <tt>mapreduce.go</tt>. Modify the <tt>MapReduce</tt> struct to<br>keep track of any additional state (e.g., the set of available workers),<br>and initialize this additional state in the <tt>InitMapReduce()</tt><br>function. The master does not need to know which Map or Reduce functions<br>are being used for the job; the workers will take care of executing the<br>right code for Map or Reduce.</p>
<p>In Part II, you don’t have to worry about the failures of the workers. You are<br>done with Part II when your implementation passes the first test set in<br><tt>test_test.go</tt> in the <tt>mapreduce</tt> package.</p>
<p><tt>test_test.go</tt> uses Go’s unit testing. From now on all exercises<br>(including subsequent assignments) will use it, but you can always run the actual<br>programs from the <tt>main</tt> directory. You run unit tests in a package<br>directory as follows:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>The master should send RPCs to the workers in parallel so that the workers<br>can work on jobs concurrently. You will find the <tt>go</tt> statement useful<br>for this purpose, and so is the <a target="_blank" rel="noopener" href="http://golang.org/pkg/net/rpc/">Go RPC documentation</a>.</p>
<p>The master may have to wait for a worker to finish before it can hand out<br>more jobs. You may find channels useful to synchronize the threads that are waiting<br>for reply with the master once the reply arrives. Channels are explained in the<br>document on <a target="_blank" rel="noopener" href="http://golang.org/doc/effective_go.html#concurrency">Concurrency in Go</a>.</p>
<p>We’ve given you code that sends RPCs via “UNIX-domain sockets”.<br>This means that RPCs only work between processes on the same machine.<br>It would be easy to convert the code to use TCP/IP-based<br>RPC instead, so that it would communicate between machines;<br>you’d have to change the first argument to calls to Listen() and Dial() to<br>“tcp” instead of “unix”, and the second argument to a port number<br>like “:5100”. You will need a shared distributed file system.</p>
<p>The easiest way to track down bugs is to insert log.Printf()<br>statements, collect the output in a file with <tt>go test &gt;<br>out</tt>, and then think about whether the output matches your<br>understanding of how your code should behave. The last step is most important.</p>
<p>Please let us know that you’ve gotten this far in the assignment, by<br>pushing a tag to github.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&quot;[you fill me in]&quot;</span></span><br><span class="line">$ git tag -a -m <span class="string">&quot;i finished assignment 1 part 2&quot;</span> a1p2</span><br><span class="line">$ git push origin master</span><br><span class="line">$ git push origin a1p2</span><br></pre></td></tr></table></figure>

<h3 id="Part-III-Handling-worker-failures"><a href="#Part-III-Handling-worker-failures" class="headerlink" title="Part III: Handling worker failures"></a>Part III: Handling worker failures</h3><p>In this part you will make the master handle worker failures. In<br>MapReduce handling failures of workers is relatively straightforward,<br>because the workers don’t have persistent state. If the worker fails,<br>any RPCs that the master issued to that worker will fail (e.g., due to<br>a timeout). Thus, if the master’s RPC to the worker fails, the master<br>should re-assign the job given to the failed worker to another worker.</p>
<p>An RPC failure doesn’t necessarily mean that the worker failed; the worker<br>may just be unreachable but still computing. Thus, it may happen that two<br>workers receive the same job and compute it. However, because jobs are<br>idempotent, it doesn’t matter if the same job is computed twice - both times it<br>will generate the same output. So, you don’t have to do anything special for this<br>case. (Our tests never fail workers in the middle of job, so you don’t even have<br>to worry about several workers writing to the same output file.)</p>
<p>You don’t have to handle failures of the master; we will assume it<br>won’t fail. Making the master fault tolerant is more difficult because<br>it keeps persistent state that must be replicated in order to make the master<br>fault tolerant. Keeping replicated state consistent in the presence of<br>failures is challenging. Much of the later assignments is devoted to this<br>challenge.</p>
<p>Your implementation must pass two remaining test cases in<br><tt>test_test.go</tt>. The first case tests the failure of one<br>worker. The second test case tests handling of many failures of<br>workers. Periodically, the test cases start new workers that the<br>master can use to make progress, but these workers fail after<br>handling a few jobs.</p>
<h3 id="Handin-procedure"><a href="#Handin-procedure" class="headerlink" title="Handin procedure"></a>Handin procedure</h3><p>You hand in your assignment exactly as you’ve been letting us know<br>your progress:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&quot;[you fill me in]&quot;</span></span><br><span class="line">$ git tag -a -m <span class="string">&quot;i finished assignment 1&quot;</span> a1handin</span><br><span class="line">$ git push origin master</span><br><span class="line">$ git push origin a1handin</span><br></pre></td></tr></table></figure>

<p>You should verify that you are able to see your final commit and your<br>a1handin tag on the Github page in your repository for this<br>assignment.</p>
<p>You will receive full credit if your software passes the<br><tt>test_test.go</tt> tests when we run your software on our machines.<br>We will use the timestamp of your <strong>last</strong> a1handin tag for the<br>purpose of calculating late days, and we will only grade that version of the<br>code. (We’ll also know if you backdate the tag, don’t do that.)</p>
<h3 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h3><p>Please post questions on <a target="_blank" rel="noopener" href="https://www.piazza.com/columbia/fall2017/comsw4113/home">Piazza</a>.</p>
<p>作业1：作业主要是重现了著名的Mapreduce方法。Mapreduce的思路并不复杂，由名字可以知道最重要的两个步骤map和reduce，在分布式中还partition和merge两部，也就是：先将任务partition成多个部分-&gt;对每个部分分别进行map和reduce，工作可以由不同的worker同时分布进行-&gt;将结果merge在一起。<br>举最常见的word count作为例子，先将文章partition成多个部分，然后对每一部分进行map，map的作用是将文章中的每个字转化成{word : 1}的模式；然后reduce将所有相同的key的value加在一起得到每部分的最终结果，然后各个部分再merge到一起得到结果。本身Mapreduce并不是很高深的方法，但它的优势在于很适合分布式系统，所以在作业中我们实现了master+worker的模式。</p>
<p><strong>我在作业中的思路是：先进行map操作，有多少个map任务(partition)，master就开多少个线程，这些线程不干别的，只是一直在等待可以空闲的worker，一有空闲的worker他们就去占用然后进行map操作，操作完再释放这个worker，所以这里我们使用一个workChannel去出栈入栈现在空闲的worker。每个线程的map操作完成后向master发送一个完成的信号(通过workDoneChannel)，master统计发现所有开的线程的任务都完成后在进行reduce，思路相同。</strong></p>
<hr>
<h1 id="Assignment-2-Primary-Backup-Key-Value-Service"><a href="#Assignment-2-Primary-Backup-Key-Value-Service" class="headerlink" title="Assignment 2: Primary/Backup Key/Value Service"></a>Assignment 2: Primary/Backup Key/Value Service</h1><h3 id="Part-A-Due-Saturday-Oct-5-11-59-59pm"><a href="#Part-A-Due-Saturday-Oct-5-11-59-59pm" class="headerlink" title="Part A Due: Saturday Oct 5, 11:59:59pm"></a>Part A Due: Saturday Oct 5, 11:59:59pm</h3><h3 id="Part-B-Due-Saturday-Oct-12-11-59-59pm"><a href="#Part-B-Due-Saturday-Oct-12-11-59-59pm" class="headerlink" title="Part B Due: Saturday Oct 12, 11:59:59pm"></a>Part B Due: Saturday Oct 12, 11:59:59pm</h3><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>In the MapReduce assignment handling failures is relatively easy<br>because the workers don’t maintain state. The master does maintain<br>state, but you didn’t have to make the master fault tolerant. This<br>assignment is a first step towards making stateful servers fault tolerant.</p>
<h3 id="Road-map-for-Assignment-2-4"><a href="#Road-map-for-Assignment-2-4" class="headerlink" title="Road map for Assignment 2-4"></a>Road map for Assignment 2-4</h3><p>In the next 3 assignments you will build several key/value<br>services. The service supports three RPCs: Put(key, value),<br>PutHash(key, value), and Get(key). The service maintains a simple<br>database of key/value pairs. Put() updates the value for a particular<br>key in the database. PutHash chains all values for a key together,<br>which is useful for testing purposes; PutHash stores the hash(old<br>value of the key in database, new supplied value) into database, and<br>returns the old value. Get() fetches the current value for a key.</p>
<p>These 3 assignments differ in the degree of fault tolerance,<br>performance, and scalability they provide for the key/value service:</p>
<p>In all three assignments you will have to do substantial design. We<br>give you a sketch of the overall design (and code for the boring<br>pieces), but you will have to flesh it out and nail down a complete<br>protocol. The test cases test failure scenarios to see if your<br>protocol is correct for that scenario. It is likely that some of the<br>test cases will point out a flaw in your design and protocol, and you<br>may have to redesign your implementation and protocol. Think<br>carefully before you start coding so that you can avoid many<br>iterations. We don’t give you a description of the test cases (other<br>than the Go code); in the real world, you would have to come up with<br>them yourself.</p>
<h3 id="Overview-of-Assignment-2"><a href="#Overview-of-Assignment-2" class="headerlink" title="Overview of Assignment 2"></a>Overview of Assignment 2</h3><p>In this assignment you’ll make a key/value service fault-tolerant<br>using a form of primary/backup replication. In order to ensure that<br>all parties (clients and servers) agree on which server is the<br>primary, and which is the backup, we’ll introduce a kind of master<br>server, called the viewservice. The viewservice monitors whether each<br>available server is alive or dead. If the current primary or backup<br>becomes dead, the viewservice selects a server to replace it. A client<br>checks with the viewservice to find the current primary. The servers<br>cooperate with the viewservice to ensure that at most one primary is<br>active at a time.</p>
<p>Your key/value service will allow replacement of failed servers. If<br>the primary fails, the viewservice will promote the backup to be<br>primary. If the backup fails, or is promoted, and there is an idle<br>server available, the viewservice will cause it to be the backup.<br>The primary will send its complete database to the new backup,<br>and then send subsequent Puts to the backup to ensure that the<br>backup’s key/value database remains identical to the primary’s.</p>
<p>It turns out that the primary must send Gets as well as Puts to the backup<br>(if there is one), and must wait for the backup to reply before<br>responding to the client. This helps prevent two servers from acting<br>as primary (a “split brain”). An example: S1 is the primary and S2 is<br>the backup. The viewservice decides (incorrectly) that S1 is dead,<br>and promotes S2 to be primary. If a client thinks that S1 is still the<br>primary and sends it an operation, S1 will forward the operation to<br>S2, and S2 will reply with an error indicating that it is no longer<br>the backup (assuming S2 obtained the new view from the viewservice).<br>S1 can then return an error to the client indicating that S1 might no<br>longer be the primary (reasoning that, since S2 rejected the<br>operation, a new view must have been formed); the client can then ask<br>the viewservice for the correct primary (S2) and send it the<br>operation.</p>
<p>A failed key/value server may restart, but it will do so without a<br>copy of the replicated data (i.e. the keys and values). That is, your<br>key/value server will keep the data in memory, not on disk. One<br>consequence of keeping data only in memory is that if there’s no<br>backup, and the primary fails, and then restarts, it cannot then act<br>as primary.</p>
<p>Only RPC may be used for interaction between clients and servers,<br>between different servers, and between different clients. For example,<br>different instances of your server are not allowed to share Go<br>variables or files.</p>
<p>The design outlined in the assignment has some fault-tolerance and<br>performance limitations:</p>
<p>We will address these limitations in later assignments by using better<br>designs and protocols. This assignment will make you understand what<br>the tricky issues are so that you can design better design/protocols.<br>Also, parts of this assignment’s design (e.g., a separate view<br>service) are uncommon in practice.</p>
<p>The primary/backup scheme in this assignment is not based on any<br>published protocol. In fact, this assignment doesn’t specify a<br>complete protocol; you must flesh out the protocol. The protocol has<br>similarities with Flat Datacenter Storage (the viewservice is like<br>FDS’s metadata server, and the primary/backup servers are like FDS’s<br>tractservers), though FDS pays far more attention to performance.<br>It’s also a bit like a MongoDB replica set (though MongoDB selects the<br>leader with a Paxos-like election). For a detailed description of a<br>(different) primary-backup-like protocol, see <a target="_blank" rel="noopener" href="http://www.cs.cornell.edu/home/rvr/papers/osdi04.pdf">Chain<br>Replication</a>.<br>Chain Replication has higher performance than this assignment’s<br>design, though it assumes that the viewservice never declares a<br>server dead when it is merely partitioned. See Harp and Viewstamped<br>Replication for a detailed treatment of high-performance<br>primary/backup and reconstruction of system state after various kinds<br>of failures.</p>
<h3 id="Collaboration-Policy-1"><a href="#Collaboration-Policy-1" class="headerlink" title="Collaboration Policy"></a>Collaboration Policy</h3><p>Please refer to Assignment 0.</p>
<h3 id="Software-1"><a href="#Software-1" class="headerlink" title="Software"></a>Software</h3><p>Do a <tt>git pull</tt> to get the latest assignment software. We supply you<br>with new skeleton code and new tests in <tt>src/viewservice</tt> and<br><tt>src/pbservice</tt>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/4113</span><br><span class="line">$ git pull</span><br><span class="line">...</span><br><span class="line">$ <span class="built_in">cd</span> src/viewservice</span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">2012/12/28 14:51:47 method Kill has wrong number of ins: 1</span><br><span class="line">First primary: --- FAIL: Test1 (1.02 seconds)</span><br><span class="line">    test_test.go:13: wanted primary /var/tmp/viewserver-35913-1, got </span><br><span class="line">FAIL</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">FAIL  _/afs/athena.mit.edu/user/r/t/rtm/4113/src/viewservice 1.041s</span><br></pre></td></tr></table></figure>

<p>Ignore the <tt>method Kill</tt> error message now and in the future.<br>Our test code fails because <tt>viewservice/server.go</tt> has empty<br>RPC handlers.</p>
<p>You can run your code as stand-alone programs using the source in<br><tt>main/viewd.go</tt>,<br><tt>main/pbd.go</tt>, and<br><tt>main/pbc.go</tt>.<br>See the comments in <tt>pbc.go</tt>.</p>
<h3 id="Part-A-The-Viewservice"><a href="#Part-A-The-Viewservice" class="headerlink" title="Part A: The Viewservice"></a>Part A: The Viewservice</h3><p>First you’ll implement a viewservice and make sure it passes our tests; in<br>Part B you’ll build the key/value service. Your viewservice won’t itself be<br>replicated, so it will be relatively straightforward. Part B is <em>much</em> harder than<br>part A, because the K/V service is replicated and you have to flesh out the<br>replication protocol.</p>
<p>The viewservice goes through a sequence of numbered<br><em>views</em>, each with a primary and (if possible) a backup.<br>A view consists of a view number and the identity (network port name) of<br>the view’s primary and backup servers.</p>
<p>The primary in a view must always be either the primary<br>or the backup of the previous view. This helps ensure<br>that the key/value service’s state is preserved.<br>An exception: when the viewservice first starts, it should<br>accept any server at all as the first primary.<br>The backup in a view can be any server (other than the primary),<br>or can be altogether missing if no server is available<br>(represented by an empty string, <tt>“”</tt>).</p>
<p>Each key/value server should send a Ping RPC once per<br><tt>PingInterval</tt><br>(see <tt>viewservice/common.go</tt>).<br>The viewservice replies to the Ping with a description of the current<br>view. A Ping lets the viewservice know that the key/value<br>server is alive; informs the key/value server of the current<br>view; and informs the viewservice of the most recent view<br>that the key/value server knows about.<br>If the viewservice doesn’t receive a Ping from a server<br>for <tt>DeadPings</tt> <tt>PingInterval</tt>s, the<br>viewservice should consider the server to be dead.<br>When a server re-starts after a crash, it should send<br>one or more Pings with an argument of zero to inform<br>the viewservice that it has crashed (of course, duplicate<br><tt>Ping(0)</tt> calls will be interpreted as repeated<br>crashes).</p>
<p>The viewservice proceeds to a new view when either it hasn’t<br>received a Ping from the primary or backup for <tt>DeadPings</tt><br><tt>PingInterval</tt>s, or<br>if the primary or backup crashed and restarted, or<br>if there is no backup and there’s an idle server<br>(a server that’s been Pinging but is<br>neither the primary nor the backup).<br>But the viewservice must <strong>not</strong> change views (i.e., return<br>a different view to callers) until<br>the primary from the current view acknowledges<br>that it is operating in the current view (by sending<br>a Ping with the current view number). If the viewservice has not yet<br>received an acknowledgment for the current view from the primary of<br>the current view, the viewservice should not change views even if it<br>thinks that the primary or backup has died.</p>
<p>The acknowledgment rule prevents the viewservice from getting more than one<br>view ahead of the key/value servers. If the viewservice could get arbitrarily<br>far ahead, then it would need a more complex design in which it kept a history<br>of views, allowed key/value servers to ask about old views, and<br>garbage-collected information about old views when appropriate. The downside of<br>the acknowledgement rule is that if the primary fails before it acknowledges the<br>view in which it is primary, then the viewservice cannot change views, spins<br>forever, and cannot make forward progress.</p>
<p>An example sequence of view changes:</p>
<p><img src="lab-2a-vs.png"></p>
<p>The above example is overspecified; for example, when the view server<br>gets <tt>Ping(1)</tt> from S1 for the first time, it is also OK for it<br>to return view 1, as long as it eventually switches to view 2 (which<br>includes S2).</p>
<p>We provide you with a complete <tt>client.go</tt> and<br>appropriate RPC definitions in <tt>common.go</tt>.<br>Your job is to supply the needed code in <tt>server.go</tt>.<br>When you’re done, you should pass all the <tt>viewservice</tt><br>tests:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/4113/src/viewservice</span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">Test: First primary ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: First backup ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Backup takes over <span class="keyword">if</span> primary fails ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Restarted server becomes backup ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Idle third server becomes backup <span class="keyword">if</span> primary fails ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Restarted primary treated as dead ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Viewserver waits <span class="keyword">for</span> primary to ack view ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Uninitialized server can<span class="string">&#x27;t become primary ...</span></span><br><span class="line"><span class="string"> ... Passed</span></span><br><span class="line"><span class="string">PASS</span></span><br><span class="line"><span class="string">ok   viewservice   7.457s</span></span><br></pre></td></tr></table></figure>

<p>The above output omits some benign Go RPC errors.</p>
<p>Hint: you’ll want to add field(s) to <tt>ViewServer</tt> in<br><tt>server.go</tt> in order to keep track of the most recent<br>time at which the viewservice has heard a Ping from each<br>server. Perhaps a <tt>map</tt> from server names to<br><tt>time.Time</tt>. You can find the current time with <tt>time.Now()</tt>.</p>
<p>Hint: add field(s) to <tt>ViewServer</tt> to keep track of the<br>current view.</p>
<p>Hint: you’ll need to keep track of whether the primary for the<br>current view has acknowledged it (in PingArgs.Viewnum).</p>
<p>Hint: your viewservice needs to make periodic decisions, for<br>example to promote the backup if the viewservice has missed <tt>DeadPings</tt><br>pings from the primary. Add this code to the <tt>tick()</tt><br>function, which is called once per <tt>PingInterval</tt>.</p>
<p>Hint: there may be more than two servers sending Pings. The<br>extra ones (beyond primary and backup) are volunteering<br>to be backup if needed.</p>
<p>Hint: the viewservice needs a way to detect that a primary<br>or backup has failed and re-started. For example, the primary<br>may crash and quickly restart without missing sending a<br>single Ping.</p>
<p>Hint: study the test cases before you start programming. If you fail a<br>test, you may have to look at the test code in <tt>test_test.go</tt> to figure<br>out what the failure scenario is.</p>
<p>The easiest way to track down bugs is to insert log.Printf()<br>statements, collect the output in a file with <tt>go test &gt;<br>out</tt>, and then think about whether the output matches your<br>understanding of how your code should behave. The last step is most important.</p>
<p>Remember that the Go RPC server framework starts a new thread for each<br>received RPC request. Thus if multiple RPCs arrive at the same time<br>(from multiple clients), there may be multiple threads running<br>concurrently in the server.</p>
<p>The tests kills a server by setting its <tt>dead</tt> flag. You must<br>make sure that your server terminates correctly when that flag is set, otherwise<br>you may fail to complete the test cases.</p>
<h3 id="Part-B-The-primary-backup-key-value-service"><a href="#Part-B-The-primary-backup-key-value-service" class="headerlink" title="Part B: The primary/backup key/value service"></a>Part B: The primary/backup key/value service</h3><p>Your key/value service should continue operating correctly as long as<br>there has never been a time at which no server was alive. It should<br>also operate correctly with partitions: a server that suffers from<br>temporary network failure without crashing, or can talk to some<br>computers but not others. If your service is operating with just one<br>server, it should be able to incorporate a recovered or idle server<br>(as backup), so that it can then tolerate another server failure.</p>
<p>Correct operation means that calls to Clerk.Get(k) return the latest<br>value set by a successful call to Clerk.Put(k,v) or<br>Clerk.PutHash(k,v), or an empty string if the key has never been<br>Put()’ed. All operations should provide at-most-once semantic.</p>
<p>You should assume that the viewservice never halts or crashes. </p>
<p>Your clients and servers may only communicate using RPC, and both<br>clients and servers must<br>send RPCs with the <tt>call()</tt> function in <tt>client.go</tt>.</p>
<p>It’s crucial that only one primary be active at any given time. You<br>should have a clear story worked out for why that’s the case for your<br>design. A danger: suppose in some view S1 is the primary; the viewservice changes<br>views so that S2 is the primary; but S1 hasn’t yet heard about the new<br>view and thinks it is still primary. Then some clients might talk to<br>S1, and others talk to S2, and not see each other’s Put()s.</p>
<p>A server that isn’t the active primary should either not respond to<br>clients, or respond with an error: it should set GetReply.Err or<br>PutReply.Err to something other than OK.</p>
<p>Clerk.Get(), Clerk.Put(), and Clerk.PutHash() should only return when they<br>have completed the operation. That is, Puts should keep trying until it has<br>updated the key/value database, and Clerk.Get() should keep trying until it has<br>retrieved the current value for the key (if any). Your server must filter out<br>the duplicate RPCs that these client re-tries will generate to ensure<br>at-most-once semantics for operations. You can assume that each clerk has only<br>one outstanding Put or Get. Think carefully about what the commit point is for<br>a Put.</p>
<p>A server should not talk to the viewservice for every Put/Get<br>it receives, since that would put the viewservice on the critical path<br>for performance and fault-tolerance. Instead servers should<br>Ping the viewservice periodically<br>(in <tt>pbservice/server.go</tt>‘s <tt>tick()</tt>)<br>to learn about new views.</p>
<p>Part of your one-primary-at-a-time strategy should rely on the<br>viewservice only promoting the backup from view <em>i</em><br>to be primary in view <em>i+1</em>. If the old primary from<br>view <em>i</em> tries to handle a client request, it will<br>forward it to its backup. If that backup hasn’t heard about<br>view <em>i+1</em>, then it’s not acting as primary yet, so<br>no harm done. If the backup has heard about view <em>i+1</em><br>and is acting as primary, it knows enough to reject the old<br>primary’s forwarded client requests.</p>
<p>You’ll need to ensure that the backup sees every update to the<br>key/value database, by a combination of the primary initializing it with<br>the complete key/value database and forwarding subsequent<br>client Puts.</p>
<p>The skeleton code for the key/value servers is in <tt>src/pbservice</tt>.<br>It uses your viewservice, so you’ll have to set up<br>your <tt>GOPATH</tt> as follows:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/4113</span><br><span class="line">$ <span class="built_in">cd</span> ~/4113/src/pbservice</span><br><span class="line">$ go <span class="built_in">test</span> -i</span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">Single primary, no backup: --- FAIL: TestBasicFail (2.00 seconds)</span><br><span class="line">    test_test.go:50: first primary never formed view</span><br><span class="line">--- FAIL: TestFailPut (5.55 seconds)</span><br><span class="line">    test_test.go:165: wrong primary or backup</span><br><span class="line">Concurrent Put()s to the same key: --- FAIL: TestConcurrentSame (8.51 seconds)</span><br><span class="line">...</span><br><span class="line">Partition an old primary: --- FAIL: TestPartition (3.52 seconds)</span><br><span class="line">    test_test.go:354: wrong primary or backup</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Here’s a recommended plan of attack:</p>
<p>You’re done if you can pass all the <tt>pbservice</tt> tests:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/4113/src/pbservice</span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">Test: Single primary, no backup ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Add a backup ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Primary failure ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Kill last server, new one should not be active ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: at-most-once Put; unreliable ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Put() immediately after backup failure ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Put() immediately after primary failure ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Concurrent Put()s to the same key ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Concurrent Put()s to the same key; unreliable ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Repeated failures/restarts ...</span><br><span class="line"> ... Put/Gets <span class="keyword">done</span> ... </span><br><span class="line"> ... Passed</span><br><span class="line">Test: Repeated failures/restarts; unreliable ...</span><br><span class="line"> ... Put/Gets <span class="keyword">done</span> ... </span><br><span class="line"> ... Passed</span><br><span class="line">Test: Old primary does not serve Gets ...</span><br><span class="line"> ... Passed</span><br><span class="line">Test: Partitioned old primary does not complete Gets ...</span><br><span class="line"> ... Passed</span><br><span class="line">PASS</span><br><span class="line">ok   pbservice    113.352s</span><br></pre></td></tr></table></figure>

<p>You’ll see some “method Kill has wrong number of ins” complaints<br>and lots of “rpc: client protocol error” and “rpc: writing response”<br>complaints; ignore them.</p>
<p>Hint: you’ll probably need to create new RPCs to forward client<br>requests from primary to backup, since the backup should reject<br>a direct client request but should accept a forwarded request.</p>
<p>Hint: you’ll probably need to create new RPCs to handle the transfer<br>of the complete key/value database from the primary to a new backup.<br>You can send the whole database in one RPC (for example,<br>include a <tt>map[string]string</tt> in the RPC arguments).</p>
<p>Hint: the state to filter duplicates must be replicated along with the key/value<br>state.</p>
<p>Hint: the tester arranges for RPC replies to be lost in tests whose<br>description includes “unreliable”. This will cause RPCs to be executed<br>by the receiver, but since the sender sees no reply, it cannot<br>tell whether the server executed the RPC.</p>
<p>You may find you want to generate numbers that have<br>a high probability of being unique. Try this:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/big&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nrand</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"> max := big.NewInt(<span class="keyword">int64</span>(<span class="number">1</span>) &lt;&lt; <span class="number">62</span>)</span><br><span class="line"> bigx, _ := rand.Int(rand.Reader, max)</span><br><span class="line"> x := bigx.Int64()</span><br><span class="line"> <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The tests kills a server by setting its <tt>dead</tt> flag. You must<br>make sure that your server terminates correctly when that flag is set, otherwise<br>you may fail to complete the test cases.</p>
<p>Hint: even if your viewserver passed all the tests in Part A, it<br>may still have bugs that cause failures in Part B.</p>
<p>Hint: study the test cases before you start programming</p>
<h3 id="Handin-procedure-1"><a href="#Handin-procedure-1" class="headerlink" title="Handin procedure"></a>Handin procedure</h3><p>You hand in your assignment as before.</p>
<p>For Part A:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&quot;[you fill me in]&quot;</span></span><br><span class="line">$ git tag -a -m <span class="string">&quot;i finished assignment 2a&quot;</span> a2ahandin</span><br><span class="line">$ git push origin master</span><br><span class="line">$ git push origin a2ahandin</span><br></pre></td></tr></table></figure>

<p>For Part B:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&quot;[you fill me in]&quot;</span></span><br><span class="line">$ git tag -a -m <span class="string">&quot;i finished assignment 2b&quot;</span> a2bhandin</span><br><span class="line">$ git push origin master</span><br><span class="line">$ git push origin a2bhandin</span><br></pre></td></tr></table></figure>

<p>You should verify that you are able to see your final commit and tags<br>on the Github page of your repository for this assignment.</p>
<p>You will receive full credit if your software passes the<br><tt>test_test.go</tt> tests when we run your software on our machines.<br>We will use the timestamp of your <strong>last</strong> handin tag for the purpose<br>of calculating late days and we will only grade that version of the code.<br>(We’ll also know if you backdate the tag, don’t do that.)</p>
<h3 id="Questions-1"><a href="#Questions-1" class="headerlink" title="Questions"></a>Questions</h3><p>Please post questions on <a target="_blank" rel="noopener" href="https://www.piazza.com/columbia/fall2017/comsw4113/home">Piazza</a>.</p>
<p>作业2：作业1中的wordCount由于是stateless，所以面对fault-tolerant处理方法很简单，但是大多数生活中的系统都是stateless的，所以我们后面三个作业逐步深入解决这个问题。<br>作业2中我们需要实现的是一个key/value数据库，他并不是stateless的，所以我们需要replication。因此这里我们采用Primary+Backup的组合，Primary是现在存储数据的数据库，Backup是后备且与Primary有完全一样数据的备份。<strong>那么问题来了：我们的client如何知道哪个数据库server是Primary哪个是Backup，我们不可能不同的client向两个数据库随便传数据，肯定是数据交互都是与Primary进行，Primary死掉Backup才会上位，这个作业我们采用的方式是假设有一个不会死掉的viewServer一直监视着Primary和Backup，client想要发数据前先去viewServer那里得到最新的Primary地址，然后进行数据交互</strong><br>PartA：PartA部分比较简单，主要就是实现一个viewServer，我们假设viewServer不会死掉，它的功能就是自身存储viewNumber+Primary+Backup，同时每隔固定的时间去Ping Primary和Backup当前viewNumber，这种时候Primary和Backup有两种情况：如果正常则回传viewNumber，死掉则无法回传，我们的viewServer在检测到Primary传回相同的viewNumber后得知Primary进行了ACK，如果viewServer已知Primary已经传回了ACK，同时长时间收不到Primary/backup的信号，那么认为他们死掉了，随即采取相应的解决措施，并改变viewNumber。作业里面有解释为什么一定要等Primary ACK后才可以改变viewNumber。<br>PartB：PartB部分比起PartA就要复杂的多了，主要原因是这里我们的Primary和Backup会经常死掉，而PartA的viewServer我们假设它不会死掉，<strong>所以其实PartB的关键就是要保证时时刻刻Primary与BackUp的数据是一致的</strong>。所以我么需要有一个机制去不停地将Primary的数据共享给我们的备份以确保Primary死掉以后Backup存储的数据是正确的，所以作业中我用了两个RPC，分别是当我的Primary检测到有新的Backup启动的时候，我把自己的数据发给他；另一个是每当client向Priamry put的时候，我都会发给Backup同时<strong>必须是先发给backup并确认backup接受这个数据没问题以后才更新我的Primary，否则如果Backup接受失败而Primary却更新了，那么系统就会出现问题</strong><br>另一个难点在于我们的系统会有网络故障的情况，也就是Primary与Backup之间可能会出现unreliable的通信问题。那么解决办法是我们实现at-most once的机制，client的put和get请求都有一个uniqueID，同时client的请求机制是如果没得到结果就一直不同的去请求，我们的Primary和Backup如果对于某个put执行完全成功了，我们把结果记录在{UniqueID：result}的map中，当下次client发来同样的ID的时候，我们直接返回，不再进行其他操作。<br>这里就遇到了一个很严重的bug：对于多个client同时发来的请求put1(1, 1)和put2(1, 2)，put1进入Primary后传给Backup，Backup执行成功返回Primary，但这时返回丢失，Primary返回给client失败(此时Backup{1, 1})，在client再次请求put1之前，put2进来了并且一切正常(此时Primary{1, 2}，Backup{1, 2})，之后client1再次发送有uniqueID的请求put1，由于Backup此前已经存有了这个UniqueID，那么不会更新结果，但Primary没有这个UniqueID，会更新为{1, 1}，这时就导致了Primary和Backup的不一样。详见testcase：TestConcurrentSameUnreliable。</p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/10/23/Leetcode/LinkedList%20Cycle%E9%97%AE%E9%A2%98/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">LinkedList Cycle问题</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/10/05/Leetcode/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/"><span class="level-item">股票买卖问题</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/Shiyu.jpg" alt="Shiyu Liu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Shiyu Liu</p><p class="is-size-6 is-block">Software Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Nashville</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">47</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">11</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ShiyuLiuColumbia" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ShiyuLiuColumbia"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Linkedin" href="https://www.linkedin.com/in/shiyu-liu-6623a3158/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:sl4401@columbia.edu"><i class="fas fa-envelope-open"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Assignment-1-MapReduce"><span class="level-left"><span class="level-item">1</span><span class="level-item">Assignment 1: MapReduce</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Questions"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Questions</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Assignment-2-Primary-Backup-Key-Value-Service"><span class="level-left"><span class="level-item">2</span><span class="level-item">Assignment 2: Primary/Backup Key/Value Service</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Questions-1"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Questions</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Shiyu - Blog</a><p class="is-size-7"><span>&copy; 2021 Shiyu Liu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>